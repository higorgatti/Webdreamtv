<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DreamTV Streaming ‚Äî v20251020-LOCAL-010-PLAYBACK-COMPLETO</title>
  <!-- Cache Bust: Force reload on changes -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <!-- VERS√ÉO ATUALIZADA: Limpeza de t√≠tulos TMDB implementada -->
  <!-- React UMD -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Tailwind CSS instalado via NPM (ver tailwind.config.js) -->
  <!-- Para produ√ß√£o, compile com: npx tailwindcss -i ./src/input.css -o ./dist/output.css -->
  <!-- Mantendo CDN apenas para desenvolvimento r√°pido -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- HLS.js para m3u8 no Chrome/Firefox/Edge -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
  <!-- Lucide Icons para a sidebar -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    /* Previne scroll - comportamento Netflix (100% fixo na tela) */
    html{margin:0;padding:0;height:100vh;width:100vw;overflow:hidden}
    body{margin:0;padding:0;height:100vh;width:100vw;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,system-ui,sans-serif}
    .star-bg{background:linear-gradient(135deg,#1a1a2e 0%,#16213e 50%,#0f1419 100%);position:relative;overflow:hidden}
    .star-bg::before{content:'';position:absolute;inset:0;pointer-events:none;z-index:0;background-image:radial-gradient(2px 2px at 20px 30px,#fff,transparent),radial-gradient(2px 2px at 60px 70px,#fff,transparent),radial-gradient(1px 1px at 50px 50px,#fff,transparent),radial-gradient(1px 1px at 130px 80px,#fff,transparent),radial-gradient(2px 2px at 90px 10px,#fff,transparent);background-repeat:repeat;background-size:200px 200px;opacity:.3;animation:twinkle 3s infinite}
    @keyframes twinkle{0%,100%{opacity:.3}50%{opacity:.5}}
    .gradient-text{background:linear-gradient(90deg,#a855f7,#ec4899,#3b82f6);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent}
    .frost{background:rgba(30,30,30,.72);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.08)}
    .card{transition:transform .2s ease,background .2s ease}
    .card:hover{transform:translateY(-2px)}
    .no-tap-highlight{-webkit-tap-highlight-color:transparent}
    .text-shadow{text-shadow:0 0 18px rgba(168,85,247,.35)}
    .hint{font-size:11px}
    .scrollbar-hide::-webkit-scrollbar{display:none}
    .scrollbar-hide{-ms-overflow-style:none;scrollbar-width:none}
    .line-clamp-3{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}
    @keyframes spin{to{transform:rotate(360deg)}}
    .animate-spin{animation:spin 1s linear infinite}
    @keyframes fade-in{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}
    .animate-fade-in{animation:fade-in 0.3s ease-out}
    @keyframes slideInRight{from{transform:translateX(100%)}to{transform:translateX(0)}}
    .netflix-card-hover{transition:all 0.3s cubic-bezier(0.5, 0, 0.1, 1)}
    .netflix-card-hover:hover{transform:scale(1.15) translateY(-8px);z-index:999}
    *::-webkit-scrollbar{width:8px;height:8px}
    *::-webkit-scrollbar-track{background:transparent}
    *::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.2);border-radius:4px}
    *::-webkit-scrollbar-thumb:hover{background:rgba(255,255,255,0.3)}

    /* Previne qualquer elemento de estourar a viewport horizontalmente */
    * {
      box-sizing: border-box;
    }

    /* Container principal sempre limitado √† viewport */
    #root, .star-bg {
      max-width: 100vw;
      overflow-x: hidden;
    }

    /* ===== LAYOUT COM SIDEBAR FIXA ===== */
    :root {
      --sidebar-w: 80px;
    }

    .app-container {
      display: flex;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* Sidebar fixa √† esquerda */
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: var(--sidebar-w);
      height: 100vh;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 0;
      gap: 8px;
      z-index: 1000;
      border-right: 1px solid rgba(168, 85, 247, 0.1);
    }

    /* Bot√µes da sidebar */
    .sidebar-btn {
      position: relative;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.6);
      background: transparent;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .sidebar-btn:hover {
      color: #fff;
      background: rgba(168, 85, 247, 0.1);
      transform: scale(1.1);
    }

    .sidebar-btn.active {
      color: #fff;
      background: rgba(168, 85, 247, 0.2);
    }

    .sidebar-btn.active::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 3px;
      height: 30px;
      background: #a855f7;
      border-radius: 0 3px 3px 0;
    }

    /* Tooltips da sidebar */
    .sidebar-btn::after {
      content: attr(data-tooltip);
      position: absolute;
      left: calc(100% + 12px);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10000;
    }

    .sidebar-btn:hover::after {
      opacity: 1;
    }

    /* Content area com margin */
    .main-content {
      margin-left: var(--sidebar-w);
      width: calc(100vw - var(--sidebar-w));
      height: 100vh;
      overflow-y: hidden;
      overflow-x: hidden;
    }

    /* Badge "L" para legendado */
    .lang-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: #a855f7;
      font-size: 11px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid rgba(168, 85, 247, 0.5);
      z-index: 10;
      letter-spacing: 0.5px;
    }

    /* ===== MODO PREVIEW (janela do meio) ===== */

    /* Container principal - ocupa tela toda */
    #playerContainer{
      position:fixed !important;
      top:0 !important;
      left:0 !important;
      width:100vw !important;
      height:100vh !important;
      margin:0 !important;
      padding:0 !important;
      overflow:hidden !important;
      background:#000 !important;
      display:block !important;
      user-select:none !important;
      -webkit-user-select:none !important;
    }

    /* Viewport wrapper - GRID para centraliza√ß√£o robusta sem conflitos */
    .player-viewport{
      position:relative !important;
      width:100% !important;
      height:100% !important;
      background:#000 !important;
      overflow:hidden !important;
      padding:0 !important;
      margin:0 !important;
    }

    /* Overlay do EPG - sobre o player */
    #playerContainer > .absolute{
      position:absolute !important;
      z-index:10 !important;
    }
    .absolute{position:absolute !important}
    .relative{position:relative !important}
    .fixed{position:fixed !important}
    .inset-0{top:0 !important;right:0 !important;bottom:0 !important;left:0 !important}
    .pointer-events-none{pointer-events:none !important}
    .pointer-events-auto{pointer-events:auto !important}
    .flex{display:flex !important}
    .flex-col{flex-direction:column !important}
    .items-start{align-items:flex-start !important}
    .items-center{align-items:center !important}
    .items-end{align-items:flex-end !important}
    .justify-start{justify-content:flex-start !important}
    .justify-center{justify-content:center !important}
    .justify-between{justify-content:space-between !important}
    .gap-2{gap:0.5rem !important}
    .gap-3{gap:0.75rem !important}
    .gap-4{gap:1rem !important}
    .gap-8{gap:2rem !important}
    .space-y-3>*+*{margin-top:0.75rem !important}


    /* ===== MODO FULLSCREEN (tela cheia - cobre 100%) ===== */

    /* Container em fullscreen */
    :fullscreen #playerContainer,
    :-webkit-full-screen #playerContainer,
    :-moz-full-screen #playerContainer,
    :-ms-fullscreen #playerContainer {
      width:100vw !important;
      height:100vh !important;
      background:#000 !important;
    }

    /* Viewport em fullscreen - mant√©m grid para centralizar */
    :fullscreen .player-viewport,
    :-webkit-full-screen .player-viewport,
    :-moz-full-screen .player-viewport,
    :-ms-fullscreen .player-viewport,
    #playerContainer:fullscreen .player-viewport,
    #playerContainer:-webkit-full-screen .player-viewport,
    #playerContainer:-moz-full-screen .player-viewport,
    #playerContainer:-ms-fullscreen .player-viewport {
      width:100vw !important;
      height:100vh !important;
      display:grid !important;
      place-items:center !important;
    }

    /* Overlay em FULLSCREEN - garantir que apare√ßa sobre o v√≠deo */
    :fullscreen > .absolute,
    :-webkit-full-screen > .absolute,
    :-moz-full-screen > .absolute,
    :-ms-fullscreen > .absolute,
    #playerContainer:fullscreen > .absolute,
    #playerContainer:-webkit-full-screen > .absolute,
    #playerContainer:-moz-full-screen > .absolute,
    #playerContainer:-ms-fullscreen > .absolute {
      z-index:9999 !important;
      display:flex !important;
    }

    /* ===== SIDEBAR NAVIGATION ===== */
    .sidebar {
      width: 80px;
      min-width: 80px;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      padding: 20px 0;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      height: 100vh;
      z-index: 100;
      flex-shrink: 0;
    }

    .sidebar-logo {
      color: #a855f7;
      font-size: 28px;
      font-weight: bold;
    }

    .sidebar-menu {
      display: flex;
      flex-direction: column;
      gap: 25px;
      align-items: center;
    }

    .sidebar-menu button, .sidebar-footer button {
      background: none;
      border: none;
      cursor: pointer;
      color: #888;
      transition: all 0.3s;
      position: relative;
      padding: 8px;
    }

    .sidebar-menu button.active::before {
      content: '';
      position: absolute;
      left: -15px;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 20px;
      background-color: #a855f7;
      border-radius: 2px;
    }

    .sidebar-menu button:hover, .sidebar-footer button:hover {
      color: #fff;
      transform: scale(1.1);
    }

    .sidebar-footer {
      display: flex;
      flex-direction: column;
      gap: 25px;
      align-items: center;
    }

    /* Main content com sidebar */
    .main-with-sidebar {
      flex: 1;
      height: 100vh;
      overflow-y: hidden;
      overflow-x: hidden;
      position: relative;
    }

    /* Ajustes para telas com sidebar - garantir que conte√∫do n√£o sobreponha */
    .main-with-sidebar .star-bg {
      min-height: 100vh;
      width: 100% !important;
      max-width: 100% !important;
    }

    /* For√ßar todos os containers dentro do main a respeitar a largura */
    .main-with-sidebar > * {
      max-width: 100% !important;
      box-sizing: border-box;
      overflow-x: hidden;
    }

    /* Container principal do app com sidebar */
    .app-container {
      display: flex;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #0b0d24 0%, #0e1530 50%, #0a0c1f 100%);
    }

    /* Fundo escuro com gradiente espacial */
    body.with-sidebar {
      background: linear-gradient(135deg, #0b0d24 0%, #0e1530 50%, #0a0c1f 100%);
      overflow: hidden;
    }

    /* ===== SMART TV MODE - 10-FOOT INTERFACE ===== */

    /* Estilos gerais para TV */
    body.tv-mode {
      font-size: 18px; /* Fontes maiores */
      cursor: none; /* Esconder cursor do mouse */
    }

    body.tv-mode * {
      cursor: none !important;
    }

    /* Remover hover states em modo TV (n√£o h√° mouse) */
    body.tv-mode .card:hover,
    body.tv-mode .sidebar-btn:hover,
    body.tv-mode button:hover {
      transform: none !important;
    }

    /* Focus vis√≠vel para navega√ß√£o por controle remoto */
    body.tv-mode *:focus {
      outline: 4px solid #a855f7 !important;
      outline-offset: 4px;
      box-shadow: 0 0 20px rgba(168, 85, 247, 0.6) !important;
    }

    /* Indicador de foco customizado para bot√µes */
    body.tv-mode button:focus,
    body.tv-mode [role="button"]:focus {
      background: rgba(168, 85, 247, 0.3) !important;
      border: 3px solid #a855f7 !important;
      transform: scale(1.08) !important;
      transition: all 0.15s ease !important;
    }

    /* Fontes maiores para legibilidade a 3 metros */
    body.tv-mode .text-sm { font-size: 16px !important; }
    body.tv-mode .text-base { font-size: 20px !important; }
    body.tv-mode .text-lg { font-size: 24px !important; }
    body.tv-mode .text-xl { font-size: 28px !important; }
    body.tv-mode .text-2xl { font-size: 32px !important; }
    body.tv-mode .text-3xl { font-size: 40px !important; }
    body.tv-mode .text-4xl { font-size: 48px !important; }

    /* Espa√ßamento maior entre elementos clic√°veis */
    body.tv-mode button,
    body.tv-mode [role="button"] {
      min-height: 60px !important;
      min-width: 60px !important;
      padding: 16px 24px !important;
      margin: 8px !important;
    }

    /* Cards maiores e mais espa√ßados */
    body.tv-mode .netflix-card-hover {
      margin: 12px !important;
    }

    /* Sidebar maior para TV */
    body.tv-mode .sidebar {
      width: 100px !important;
    }

    body.tv-mode .sidebar-btn {
      width: 70px !important;
      height: 70px !important;
    }

    /* Contraste alto para texto */
    body.tv-mode {
      color: #ffffff !important;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
    }

    /* Remover tooltip hover da sidebar (usar apenas foco) */
    body.tv-mode .sidebar-btn::after {
      opacity: 0 !important;
    }

    body.tv-mode .sidebar-btn:focus::after {
      opacity: 1 !important;
      font-size: 18px !important;
    }

    /* Indicador de navega√ß√£o num√©rica (para digita√ß√£o de canal) */
    .tv-channel-input {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #a855f7;
      border-radius: 20px;
      padding: 40px 60px;
      font-size: 72px;
      font-weight: bold;
      color: #fff;
      text-align: center;
      z-index: 10000;
      box-shadow: 0 10px 50px rgba(168, 85, 247, 0.5);
      animation: fade-in 0.2s ease-out;
      min-width: 300px;
    }

    /* Indicador de bot√£o pressionado */
    @keyframes button-press {
      0% { transform: scale(1); }
      50% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    body.tv-mode button:active,
    body.tv-mode [role="button"]:active {
      animation: button-press 0.2s ease !important;
    }

    /* Ajustes de scroll suave para navega√ß√£o por foco */
    body.tv-mode {
      scroll-behavior: smooth;
    }

    /* Player em TV - controles maiores */
    body.tv-mode video {
      width: 100% !important;
      height: 100% !important;
    }

    /* ===== P√ÅGINA DE DETALHES DE S√âRIE ===== */
    .serie-detail-page {
      position: relative;
      width: 100%;
      height: 100vh;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .serie-detail-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
      z-index: 0;
    }

    .serie-detail-backdrop::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(to right,
        rgba(0, 0, 0, 0.95) 0%,
        rgba(0, 0, 0, 0.85) 40%,
        rgba(0, 0, 0, 0.6) 70%,
        rgba(0, 0, 0, 0.4) 100%
      );
    }

    .serie-detail-content {
      position: relative;
      z-index: 1;
      padding: 100px 60px 60px 60px;
      max-width: 1400px;
    }

    .serie-detail-header h1 {
      font-size: 64px;
      font-weight: 700;
      color: #ffffff;
      margin: 0 0 16px 0;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
    }

    .serie-detail-metadata {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    .serie-detail-metadata span {
      font-size: 18px;
      color: #cccccc;
    }

    .serie-detail-rating-badge {
      background: #E85D04;
      color: #ffffff;
      padding: 4px 12px;
      border-radius: 4px;
      font-weight: 700;
      font-size: 16px;
    }

    .serie-detail-synopsis {
      font-size: 16px;
      line-height: 1.6;
      color: #e0e0e0;
      margin-bottom: 32px;
      max-width: 700px;
    }

    .serie-detail-actions {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .serie-detail-btn {
      padding: 14px 32px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .serie-detail-btn:hover {
      transform: scale(1.05);
      filter: brightness(1.1);
    }

    .serie-detail-btn:active {
      transform: scale(0.98);
    }

    .serie-detail-btn-watch {
      background: #E85D04;
      color: #ffffff;
      font-size: 18px;
      padding: 16px 40px;
    }

    .serie-detail-btn-trailer {
      background: #0077B6;
      color: #ffffff;
    }

    .serie-detail-btn-favorite {
      background: #2D6A4F;
      color: #ffffff;
    }

    .serie-detail-btn-episodes {
      background: #B5179E;
      color: #ffffff;
      width: 100%;
      max-width: 300px;
      justify-content: center;
    }

    .serie-detail-cast-section {
      margin-top: 48px;
    }

    .serie-detail-cast-section h2 {
      font-size: 32px;
      font-weight: 700;
      color: #ffffff;
      margin-bottom: 24px;
    }

    .serie-detail-cast-carousel {
      display: flex;
      gap: 16px;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 16px;
      scrollbar-width: thin;
    }

    .serie-detail-cast-card {
      min-width: 140px;
      max-width: 140px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .serie-detail-cast-card:hover {
      transform: scale(1.05);
      filter: brightness(1.2);
    }

    .serie-detail-cast-card img {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
    }

    .serie-detail-cast-card p {
      margin-top: 8px;
      font-size: 14px;
      color: #ffffff;
      text-align: center;
      font-weight: 500;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .serie-detail-content {
        padding: 80px 24px 40px 24px;
      }

      .serie-detail-header h1 {
        font-size: 36px;
      }

      .serie-detail-actions {
        flex-direction: column;
      }

      .serie-detail-btn {
        width: 100%;
        justify-content: center;
      }

      .serie-detail-btn-episodes {
        max-width: 100%;
      }
    }
  </style>
</head>
<body class="no-tap-highlight">
  <div id="app"></div>

  <!-- ===== LIBS CUSTOMIZADAS ===== -->
  <script>
  // ===== lib/queue.js - Sistema de fila com dedupe =====
  (function() {
    const CONC = 6, MAX = 35, WIN = 10000;
    let running = 0, tokens = MAX;
    const queue = [], inflight = new Map();

    setInterval(() => { tokens = MAX; console.log('[Queue] üîÑ Tokens recarregados:', MAX); }, WIN);

    window.schedule = function(key, task) {
      if (inflight.has(key)) {
        console.log(`[Queue] ‚ö° Dedupe HIT: ${key}`);
        return inflight.get(key);
      }

      const promise = new Promise((resolve, reject) => {
        queue.push(async () => {
          try {
            while (tokens <= 0 || running >= CONC) await new Promise(r => setTimeout(r, 200));
            tokens--; running++;
            console.log(`[Queue] ‚úÖ ${key} (${running}/${CONC}, ${tokens} tokens)`);
            const result = await task();
            resolve(result);
          } catch (error) {
            console.error(`[Queue] ‚ùå ${key}:`, error);
            reject(error);
          } finally {
            running--; inflight.delete(key); pump();
          }
        });
      });

      inflight.set(key, promise);
      pump();
      return promise;
    };

    function pump() {
      if (running < CONC && queue.length > 0) queue.shift()();
    }

    window.__queueStats = () => ({ running, queued: queue.length, inflight: inflight.size, tokens });
  })();

  // ===== lib/normalizeTitle.js - Normaliza√ß√£o de t√≠tulos =====
  window.prepareForTMDB = function(title) {
    if (!title) return { searchTitle: '', year: null, displayTitle: '', isLegendado: false, langType: 'dublado' };

    const originalTitle = title.trim();
    const isLegendado = /\(L\)\s*$/i.test(originalTitle);
    const searchTitle = originalTitle.replace(/\s*\(L\)\s*$/i, '').trim();
    const year = (searchTitle.match(/\b(19\d{2}|20\d{2})\b/) || [])[1];

    let cleanTitle = searchTitle
      .replace(/\s*\([LDld]\)\s*$/gi, '')
      .replace(/\s*\((HD|FHD|4K|CAM|WEB-DL|BluRay|BRRip|DVDRip|HDTV|WEBRip)\)\s*/gi, ' ')
      .replace(/\b(UHD|FHD|4K|1080p|720p|480p|2160p|HDR|TESTE4K|TESTE|10bit|8bit)\b/gi, '')
      .replace(/\s*\([^\)]*(?:RIP|WEB|BLU|DVD|CAM|HDTV)[^\)]*\)\s*/gi, ' ')
      .replace(/\s*-?\s*\d{4}\s*$/g, '')
      .replace(/[‚Äì‚Äî:]/g, ' ')
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .replace(/\s{2,}/g, ' ')
      .replace(/^[-\s]+|[-\s]+$/g, '')
      .trim();

    return {
      searchTitle: cleanTitle,
      year: year ? parseInt(year) : null,
      displayTitle: originalTitle,
      isLegendado,
      langType: isLegendado ? 'legendado' : 'dublado'
    };
  };

  // ===== lib/mergeMedia.js - Merge servidor/TMDB =====
  window.mergeMedia = function(server, tmdb) {
    if (!server) return null;

    const TMDB_IMG = 'https://image.tmdb.org/t/p';

    // ===== PRIORIDADE: Poster SERVIDOR, Backdrop TMDB =====
    const serverPoster = server.stream_icon || server.cover;
    const poster = serverPoster || (tmdb?.poster_path ? `${TMDB_IMG}/w500${tmdb.poster_path}` : null);

    // Backdrop: TMDB primeiro (melhor qualidade), depois servidor
    const backdrop = (tmdb?.backdrop_path ? `${TMDB_IMG}/w1280${tmdb.backdrop_path}` : null) ||
                     (server.backdrop_path?.includes('http') ? server.backdrop_path : null) ||
                     (server.backdrop?.includes('http') ? server.backdrop : null);

    const serverPlot = server.plot || server.description || '';
    const plot = (serverPlot.length >= 120) ? serverPlot : (tmdb?.overview || serverPlot);
    const year = server.releaseDate || server.year ||
                 (tmdb?.release_date ? Number(tmdb.release_date.slice(0, 4)) : null) ||
                 (tmdb?.first_air_date ? Number(tmdb.first_air_date.slice(0, 4)) : null);
    const rating = tmdb?.vote_average || server.rating || null;
    const trailer = tmdb?.videos?.results?.find(v => v.type === 'Trailer' && v.site === 'YouTube');

    console.log(`[mergeMedia] "${server.name || server.title}" - Poster: ${serverPoster ? '‚úÖ SERVIDOR' : 'üåê TMDB'}, Backdrop: üåê TMDB`);

    return {
      ...server,
      tmdbId: tmdb?.id || server.tmdbId,
      poster, backdrop, plot, year, rating,
      trailerKey: trailer?.key
    };
  };

  window.cacheStreamToTmdb = function(streamId, tmdbId) {
    if (!streamId || !tmdbId) return;
    try {
      const cache = JSON.parse(localStorage.getItem('streamTmdbCache') || '{}');
      cache[streamId] = { tmdbId, timestamp: Date.now() };
      const thirtyDays = 30 * 24 * 60 * 60 * 1000;
      Object.keys(cache).forEach(key => {
        if (Date.now() - cache[key].timestamp > thirtyDays) delete cache[key];
      });
      localStorage.setItem('streamTmdbCache', JSON.stringify(cache));
    } catch (e) { console.warn('[mergeMedia] Erro ao salvar cache:', e); }
  };

  window.getCachedTmdbId = function(streamId) {
    if (!streamId) return null;
    try {
      const cache = JSON.parse(localStorage.getItem('streamTmdbCache') || '{}');
      return cache[streamId]?.tmdbId || null;
    } catch (e) { return null; }
  };
  </script>

  <script>
  'use strict'
  const e = React.createElement
  const { useState, useEffect, useMemo, useRef } = React

  // ===== Sistema de Log para Debug =====
  const debugLogs = []
  const MAX_LOGS = 50 // Manter s√≥ os √∫ltimos 50 logs
  const originalLog = console.log

  console.log = function(...args) {
    // Salvar logs importantes (com emojis de debug)
    const msg = args.join(' ')
    if(msg.includes('üü¶') || msg.includes('üü©') || msg.includes('üü®') || msg.includes('üöÄ') || msg.includes('üî∑') || msg.includes('‚ö†Ô∏è') || msg.includes('‚úÖ') || msg.includes('‚ùå')) {
      const timestamp = new Date().toLocaleTimeString()
      debugLogs.push(`[${timestamp}] ${msg}`)
      // Manter s√≥ os √∫ltimos MAX_LOGS
      if(debugLogs.length > MAX_LOGS) debugLogs.shift()
    }
    originalLog.apply(console, args)
  }

  // Fun√ß√£o para baixar logs como arquivo
  window.downloadDebugLogs = () => {
    const content = debugLogs.join('\n')
    const blob = new Blob([content], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `debug-logs-${Date.now()}.txt`
    a.click()
    URL.revokeObjectURL(url)
  }

  // Fun√ß√£o para ver √∫ltimos N logs
  window.getLastLogs = (n = 20) => {
    return debugLogs.slice(-n).join('\n')
  }

  // Fun√ß√£o para mostrar dimens√µes da tela
  window.showDimensions = () => {
    console.clear()
    console.log('üé¨ ===== DIMENS√ïES DA TELA =====\n')

    console.log('üì∫ VIEWPORT (Tela Total):')
    console.log('   Largura: ' + window.innerWidth + 'px')
    console.log('   Altura: ' + window.innerHeight + 'px\n')

    setTimeout(() => {
      const featuredMovie = document.querySelector('[style*="overflow: hidden"]')
      if (featuredMovie) {
        const rect = featuredMovie.getBoundingClientRect()
        console.log('üé• BANNER PRINCIPAL (onde est√° a capa de fundo):')
        console.log('   Largura: ' + rect.width + 'px')
        console.log('   Altura: ' + rect.height + 'px')
        console.log('   Top: ' + rect.top + 'px')
        console.log('   Bottom: ' + rect.bottom + 'px\n')
      }

      const firstCard = document.querySelector('[id^="movie-"]')
      if (firstCard) {
        const rect = firstCard.getBoundingClientRect()
        console.log('üé¥ CARDS (filmes):')
        console.log('   Largura de cada card: ' + rect.width + 'px')
        console.log('   Altura de cada card: ' + rect.height + 'px')
        console.log('   Cards come√ßam em: ' + rect.top + 'px do topo\n')
      }

      console.log('‚úÖ COPIE essas informa√ß√µes e me envie!')
    }, 100)
  }

  // ===== FOR√áA LIMPEZA DE CACHE - Service Worker + Hard Reload =====
  console.log('[CACHE] Verificando Service Workers...')
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then(registrations => {
      if(registrations.length > 0) {
        console.log(`[CACHE] ‚ö†Ô∏è ${registrations.length} Service Worker(s) encontrado(s), removendo...`)
        registrations.forEach(registration => {
          registration.unregister()
          console.log('[CACHE] ‚úÖ Service Worker removido')
        })
        console.log('[CACHE] üîÑ RECARREGUE A P√ÅGINA (Ctrl+Shift+R) para aplicar mudan√ßas!')
      } else {
        console.log('[CACHE] ‚úÖ Nenhum Service Worker registrado')
      }
    })
  }

  // ===== LIMPAR CACHE TMDB ANTIGO (com t√≠tulos " - 2025") =====
  try {
    const oldCache = localStorage.getItem('tmdb_cache')
    if(oldCache) {
      const parsed = JSON.parse(oldCache)
      const keys = Object.keys(parsed)
      const hasOldFormat = keys.some(key => key.includes(' - 20'))
      if(hasOldFormat) {
        console.log('[CACHE] ‚ö†Ô∏è Cache TMDB antigo detectado (com " - 2025"), limpando...')
        localStorage.removeItem('tmdb_cache')
        console.log('[CACHE] ‚úÖ Cache TMDB limpo! Nova busca usar√° t√≠tulos limpos.')
      } else {
        console.log('[CACHE] ‚úÖ Cache TMDB OK (sem formato antigo)')
      }
    }
  } catch(e) {
    console.warn('[CACHE] Erro ao verificar cache TMDB:', e)
  }

  // Fun√ß√£o para copiar √∫ltimos N logs
  window.copyLastLogs = (n = 30) => {
    const logs = debugLogs.slice(-n).join('\n')
    navigator.clipboard.writeText(logs)
    alert(`√öltimos ${Math.min(n, debugLogs.length)} logs copiados!`)
  }

  // ===== Helpers =====
  function useLocalStorage(key, initial){
    const [val,setVal] = useState(()=>{
      try{ const v = localStorage.getItem(key); return v? JSON.parse(v): initial }catch{ return initial }
    })
    useEffect(()=>{ try{ localStorage.setItem(key, JSON.stringify(val)) }catch{} }, [key,val])
    return [val,setVal]
  }

  // ===== SMART TV DETECTION & REMOTE CONTROL SUPPORT =====

  // Detectar se est√° rodando em Smart TV
  const TVDetector = {
    isTV: false,
    platform: null,

    detect() {
      const ua = navigator.userAgent

      // Detectar plataformas de TV APENAS por User Agent (mais confi√°vel)
      if (/webOS|Web0S/i.test(ua)) {
        this.isTV = true
        this.platform = 'LG webOS'
      } else if (/Tizen/i.test(ua)) {
        this.isTV = true
        this.platform = 'Samsung Tizen'
      } else if (/AndroidTV|SmartTV|SMART-TV|GoogleTV/i.test(ua)) {
        this.isTV = true
        this.platform = 'Android TV'
      } else if (/BRAVIA|SonyDTV/i.test(ua)) {
        this.isTV = true
        this.platform = 'Sony Bravia'
      } else if (/HbbTV/i.test(ua)) {
        this.isTV = true
        this.platform = 'HbbTV'
      } else if (/NetCast/i.test(ua)) {
        this.isTV = true
        this.platform = 'LG NetCast'
      } else if (/CrKey|Chromecast/i.test(ua)) {
        this.isTV = true
        this.platform = 'Chromecast'
      }

      // N√ÉO detectar por resolu√ß√£o - computadores tamb√©m t√™m 1080p/4K
      // N√ÉO detectar por gamepad - gamers usam no PC

      if (this.isTV) {
        const w = window.screen.width
        const h = window.screen.height
        console.log(`üì∫ [TV MODE] Detectado: ${this.platform} (${w}x${h})`)
        document.body.classList.add('tv-mode')
      } else {
        console.log(`üíª [DESKTOP MODE] Navegador: ${ua.slice(0, 100)}`)
      }

      return this.isTV
    },

    isMobile() {
      return /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)
    }
  }

  // Mapa de teclas do controle remoto
  const RemoteKeyMap = {
    // Setas
    ARROW_UP: [38, 'ArrowUp'],
    ARROW_DOWN: [40, 'ArrowDown'],
    ARROW_LEFT: [37, 'ArrowLeft'],
    ARROW_RIGHT: [39, 'ArrowRight'],

    // A√ß√µes
    OK: [13, 'Enter'],
    BACK: [8, 27, 461, 10009, 'Backspace', 'Escape'], // 461=webOS back, 10009=Tizen back

    // N√∫meros
    NUM_0: [48, 96, '0'],
    NUM_1: [49, 97, '1'],
    NUM_2: [50, 98, '2'],
    NUM_3: [51, 99, '3'],
    NUM_4: [52, 100, '4'],
    NUM_5: [53, 101, '5'],
    NUM_6: [54, 102, '6'],
    NUM_7: [55, 103, '7'],
    NUM_8: [56, 104, '8'],
    NUM_9: [57, 105, '9'],

    // Bot√µes coloridos (Smart TVs)
    RED: [403, 'Red', 'ColorF0Red'],
    GREEN: [404, 'Green', 'ColorF1Green'],
    YELLOW: [405, 'Yellow', 'ColorF2Yellow'],
    BLUE: [406, 'Blue', 'ColorF3Blue'],

    // Controle de m√≠dia
    PLAY: [415, 'MediaPlayPause', 'Play'],
    PAUSE: [19, 'MediaPause', 'Pause'],
    STOP: [413, 'MediaStop', 'Stop'],
    REWIND: [412, 'MediaRewind', 'Rewind'],
    FORWARD: [417, 'MediaFastForward', 'FastForward'],

    // Outros
    INFO: [457, 'Info'],
    MENU: [18, 'Menu'],
    GUIDE: [458, 'Guide'],

    // Verifica se tecla/c√≥digo corresponde a um comando
    matches(keyMap, event) {
      return keyMap.includes(event.keyCode) || keyMap.includes(event.key) || keyMap.includes(event.code)
    }
  }

  // Sistema de navega√ß√£o por foco (para controle remoto)
  const FocusNavigator = {
    currentIndex: 0,
    items: [],
    containerSelector: null,

    init(selector) {
      this.containerSelector = selector
      this.updateItems()
      console.log(`üéÆ [FOCUS NAV] Inicializado: ${this.items.length} itens naveg√°veis`)
    },

    updateItems() {
      if (!this.containerSelector) return
      const container = document.querySelector(this.containerSelector)
      if (!container) return

      // Coletar todos os elementos foc√°veis
      this.items = Array.from(container.querySelectorAll(
        'button:not([disabled]), [role="button"]:not([disabled]), a[href], [tabindex]:not([tabindex="-1"])'
      ))

      // Se h√° um item focado, atualizar o √≠ndice
      const focused = document.activeElement
      const index = this.items.indexOf(focused)
      if (index !== -1) {
        this.currentIndex = index
      }
    },

    focus(index) {
      if (index < 0 || index >= this.items.length) return
      this.currentIndex = index
      const item = this.items[index]
      if (item) {
        item.focus()
        // Scroll suave para o elemento
        item.scrollIntoView({ behavior: 'smooth', block: 'center' })
      }
    },

    next() {
      this.updateItems()
      if (this.currentIndex < this.items.length - 1) {
        this.focus(this.currentIndex + 1)
      }
    },

    prev() {
      this.updateItems()
      if (this.currentIndex > 0) {
        this.focus(this.currentIndex - 1)
      }
    },

    select() {
      const item = this.items[this.currentIndex]
      if (item) {
        item.click()
      }
    }
  }

  // Executar detec√ß√£o de TV
  const isSmartTV = TVDetector.detect()

  // Armazenar globalmente para acesso pelos componentes
  window.__isSmartTV = isSmartTV
  window.__tvPlatform = TVDetector.platform

  // ===== Netflix Category Mapping =====
  function mapApiCategoryToNetflix(categoryName){
    const name = (categoryName || '').toLowerCase()
    if(/a√ß[a√£]o|action/i.test(name)) return 'action'
    if(/com[e√©]dia|comedy/i.test(name)) return 'comedy'
    if(/drama/i.test(name)) return 'drama'
    if(/terror|horror/i.test(name)) return 'horror'
    if(/fic[√ßc][a√£]o|sci-?fi|fantasy|fantasia/i.test(name)) return 'scifi'
    if(/romance/i.test(name)) return 'romance'
    if(/document[a√°]rio|documentary/i.test(name)) return 'documentary'
    if(/crian[√ßc]a|fam[i√≠]lia|kids|family/i.test(name)) return 'kids'
    if(/anime/i.test(name)) return 'anime'
    if(/cl[a√°]ssico|classic/i.test(name)) return 'classics'
    return null
  }

  function getNetflixCategoryDisplayName(categoryKey){
    const names = {
      'trending': 'Tend√™ncias agora',
      'popular': 'Populares',
      'top10': 'Top 10 no Brasil',
      'recent': 'Lan√ßados recentemente',
      'continue': 'Continuar assistindo',
      'recommended': 'Porque voc√™ assistiu',
      'action': 'A√ß√£o',
      'comedy': 'Com√©dia',
      'drama': 'Drama',
      'horror': 'Terror',
      'scifi': 'Fic√ß√£o cient√≠fica e fantasia',
      'romance': 'Romance',
      'documentary': 'Document√°rios',
      'kids': 'Crian√ßas e fam√≠lia',
      'anime': 'Animes',
      'classics': 'Cl√°ssicos'
    }
    return names[categoryKey] || categoryKey
  }

  function sanitizeServer(url){ if(!url) return '';
    const u = url.trim().replace(/\/$/,'')
    if(!/^https?:\/\//i.test(u)) return 'http://' + u
    return u
  }

  function buildURL(base, pathSegs){
    const b = sanitizeServer(base)
    return [b, ...pathSegs.map(s=>String(s).replace(/^\/+|\/+$/g,''))].join('/')
  }

  function maskUrlCredentials(url){
    try{
      const u = new URL(url)
      const qs = u.search.replace(/(username=)([^&]+)/i, '$1***').replace(/(password=)([^&]+)/i, '$1***')
      const path = u.pathname.replace(/\/(live|movie|series)\/([^/]+)\/([^/]+)\//i, '/$1/***/***/')
      return `${u.origin}${path}${qs}`
    }catch{ return url.replace(/(username=)([^&]+)/i, '$1***').replace(/(password=)([^&]+)/i, '$1***') }
  }

  function formatEPGTime(v){
    if(v==null) return '--:--'
    if(typeof v==='string' && /^\d{1,2}:\d{2}$/.test(v)) return v
    const n = Number(v)
    if(!isNaN(n)){
      // Timestamp em segundos ou milissegundos
      const ms = n > 1e12 ? n : (n > 1e10 ? n : n*1000)
      const d = new Date(ms)

      // FOR√áAR timezone UTC-3 (S√£o Paulo/Bras√≠lia)
      const utc = d.getTime() + (d.getTimezoneOffset() * 60000) // Converter para UTC
      const brTime = new Date(utc + (-3 * 3600000)) // UTC-3

      const hh = String(brTime.getHours()).padStart(2,'0')
      const mm = String(brTime.getMinutes()).padStart(2,'0')

      console.log(`formatEPGTime: ${v} ‚Üí UTC: ${d.toISOString()} ‚Üí BR (UTC-3): ${hh}:${mm}`)
      return `${hh}:${mm}`
    }
    return '--:--'
  }

  function decodeHtml(text){
    if(!text) return text
    const textarea = document.createElement('textarea')
    textarea.innerHTML = text
    return textarea.value
  }

  function decodeBase64(text){
    if(!text) return text
    try{
      // Tentar decodificar base64
      const decoded = atob(text)
      // Verificar se √© texto v√°lido (n√£o bin√°rio)
      if(/^[\x20-\x7E\u00A0-\uFFFF\s]*$/.test(decoded)){
        return decoded
      }
      return text
    }catch{
      // Se falhar, retornar o texto original
      return text
    }
  }

  function fixEncoding(text){
    if(!text || typeof text !== 'string') return text

    // Se o texto parece normal (caracteres ASCII comuns), n√£o mexe
    if(/^[a-zA-Z0-9\s\-\.,!?]+$/.test(text)) return text

    try{
      // Corrigir encoding UTF-8 interpretado como Latin-1
      // Converte "Tens√É¬£o" ‚Üí "Tens√£o"
      const fixed = decodeURIComponent(escape(text))

      // Verificar se ficou melhor ou pior
      // Se gerou caracteres de controle ou lixo, retorna original
      if(/[\x00-\x08\x0B\x0C\x0E-\x1F]/.test(fixed)){
        return text
      }

      return fixed
    }catch{
      return text
    }
  }

  function decodeEpgText(text){
    if(!text) return text
    const original = text

    // N√ÉO processar textos curtos/simples (como "SP2", "HD", etc)
    // Isso evita quebrar texto que j√° est√° correto
    if(text.length <= 10 && /^[A-Za-z0-9\s\-]+$/.test(text)){
      return text
    }

    // 1. Decodificar base64 (se aplic√°vel)
    let decoded = decodeBase64(text)
    // 2. Decodificar HTML entities
    decoded = decodeHtml(decoded)
    // 3. Corrigir encoding UTF-8 (por √∫ltimo) - APENAS se tiver caracteres problem√°ticos
    // N√ÉO aplicar em texto simples ASCII para evitar quebrar "SP2" ‚Üí "Hy"
    if(/[√É√Ä-√ø]/.test(decoded)){
      decoded = fixEncoding(decoded)
    }

    // Debug para casos problem√°ticos
    if(original.length < 10 && decoded !== original){
      console.log(`[decodeEpgText] "${original}" ‚Üí "${decoded}"`)
    }

    return decoded
  }

  // Normalizadores para respostas de pain√©is que n√£o retornam Arrays puros
  function toArray(x){
    if(Array.isArray(x)) return x
    if(x && typeof x==='object'){
      return Object.values(x)
    }
    return []
  }
  function getCatId(cat){
    return cat?.category_id ?? cat?.parent_id ?? cat?.id ?? cat?.CategoryID ?? cat?.categoryid ?? null
  }

  // ===== Quality Variants System =====
  function extractBaseName(channelName){
    if(!channelName) return ''
    // Remove sufixos de qualidade: FHD, FHD¬≤, HD, HD¬≤, SD, SD¬≤
    const cleanName = channelName
      .replace(/\s*\(?(FHD¬≤|FHD|HD¬≤|HD|SD¬≤|SD)\)?$/i, '')
      .replace(/\s*\[(FHD¬≤|FHD|HD¬≤|HD|SD¬≤|SD)\]$/i, '')
      .trim()
    return cleanName || channelName
  }

  function detectQuality(channelName){
    if(!channelName) return null
    const match = channelName.match(/(FHD¬≤|FHD|HD¬≤|HD|SD¬≤|SD)$/i)
    if(match) return match[1].toUpperCase()
    // Se n√£o tem sufixo, considera Original
    return null
  }

  function groupChannelsByBaseName(channels){
    const groups = {}
    for(const ch of channels){
      const baseName = extractBaseName(ch.name || '')
      if(!baseName) continue

      if(!groups[baseName]){
        groups[baseName] = {
          baseName,
          baseChannel: ch,
          variants: []
        }
      }

      const quality = detectQuality(ch.name || '')
      groups[baseName].variants.push({
        ...ch,
        quality: quality || 'Original',
        baseName
      })
    }

    return Object.values(groups)
  }

  function getUniqueChannels(channels){
    // Retorna apenas um canal por base name (para o menu esquerdo)
    const groups = groupChannelsByBaseName(channels)
    return groups.map(g => ({
      ...g.baseChannel,
      baseName: g.baseName,
      hasVariants: g.variants.length > 1,
      variantCount: g.variants.length
    }))
  }

  function getVariantsForChannel(channels, baseName){
    const groups = groupChannelsByBaseName(channels)
    const group = groups.find(g => g.baseName === baseName)
    return group ? group.variants : []
  }

  // ===== Pool de Requisi√ß√µes & Retry =====
  let inFlightRequests = 0
  const MAX_CONCURRENT_REQUESTS = 6

  async function withRequestPool(task) {
    while (inFlightRequests >= MAX_CONCURRENT_REQUESTS) {
      await new Promise(resolve => setTimeout(resolve, 50))
    }
    inFlightRequests++
    try {
      return await task()
    } finally {
      inFlightRequests--
    }
  }

  async function withRetry(fn, maxRetries = 2, delay = 500) {
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await fn()
      } catch (error) {
        // N√£o fazer retry em erros de valida√ß√£o ou abort
        if (i === maxRetries || error.name === 'AbortError' || error.message.includes('Expected JSON')) {
          throw error
        }
        // Backoff exponencial: 500ms, 1000ms, 2000ms
        const backoffDelay = delay * Math.pow(2, i)
        await new Promise(resolve => setTimeout(resolve, backoffDelay))
      }
    }
  }

  // ===== Xtream Codes API Client =====
  // Cliente completo para API Xtream Codes com controle de concorr√™ncia,
  // retry autom√°tico, timeout e cancelamento de requisi√ß√µes.
  //
  // IMPORTANTE: Este m√≥dulo N√ÉO altera layout/UI - apenas camada de dados.

  const XCClient = (() => {
    // AbortControllers ativos por tipo de opera√ß√£o
    const activeRequests = {
      vod: null,
      live: null,
      series: null,
      epg: null
    }

    // Cancelar requisi√ß√£o anterior do mesmo tipo
    function cancelPrevious(type) {
      if (activeRequests[type]) {
        activeRequests[type].abort()
        activeRequests[type] = null
      }
    }

    // Wrapper para fetch com timeout e abort
    async function fetchWithAbort(url, type, timeout = 10000) {
      cancelPrevious(type)

      const controller = new AbortController()
      activeRequests[type] = controller

      const timeoutId = setTimeout(() => controller.abort(), timeout)

      try {
        const res = await fetch(url, {
          signal: controller.signal,
          headers: { 'Accept': 'application/json' }
        })

        clearTimeout(timeoutId)

        const contentType = (res.headers.get('content-type') || '').toLowerCase()
        const text = await res.text()

        if (!res.ok) {
          throw new Error(`[HTTP ${res.status}] ${text.slice(0, 200)}`)
        }

        // Validar JSON
        if (!contentType.includes('application/json') && !contentType.includes('text/plain')) {
          throw new Error(`Expected JSON, got: ${contentType}`)
        }

        if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
          throw new Error('Received HTML instead of JSON')
        }

        return JSON.parse(text)
      } catch (error) {
        clearTimeout(timeoutId)
        if (error.name === 'AbortError') {
          console.log(`‚ö†Ô∏è Request ${type} cancelled`)
        }
        throw error
      } finally {
        if (activeRequests[type] === controller) {
          activeRequests[type] = null
        }
      }
    }

    // API Endpoints
    return {
      // ===== LIVES =====
      async getLiveCategories() {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_live_categories'
        })
        return fetchWithAbort(url, 'live')
      },

      async getLiveStreams() {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_live_streams'
        })
        return fetchWithAbort(url, 'live')
      },

      async getLiveStreamsByCategory(categoryId) {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_live_streams',
          category_id: String(categoryId)
        })
        return fetchWithAbort(url, 'live')
      },

      // ===== VOD =====
      async getVodCategories() {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_vod_categories'
        })
        return fetchWithAbort(url, 'vod')
      },

      async getVodStreams() {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_vod_streams'
        })
        return fetchWithAbort(url, 'vod')
      },

      // IMPORTANTE: API Xtream Codes N√ÉO suporta category_id para VOD
      // Esta fun√ß√£o existe para compatibilidade, mas faz filtro client-side
      async getVodStreamsByCategory(categoryId) {
        console.warn('‚ö†Ô∏è VOD API does not support category_id - using client-side filter')
        const allVods = await this.getVodStreams()

        if (!Array.isArray(allVods)) {
          return []
        }

        return allVods.filter(item =>
          item && String(item.category_id) === String(categoryId)
        )
      },

      async getVodInfo(vodId) {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_vod_info',
          vod_id: String(vodId)
        })
        return fetchWithAbort(url, 'vod')
      },

      // ===== SERIES =====
      async getSeriesCategories() {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_series_categories'
        })
        return fetchWithAbort(url, 'series')
      },

      async getSeries() {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_series'
        })
        return fetchWithAbort(url, 'series')
      },

      async getSeriesByCategory(categoryId) {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_series',
          category_id: String(categoryId)
        })
        return fetchWithAbort(url, 'series')
      },

      async getSeriesInfo(seriesId) {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_series_info',
          series_id: String(seriesId)
        })
        return fetchWithAbort(url, 'series')
      },

      // ===== EPG =====
      async getShortEpg(streamId, limit = 4) {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_short_epg',
          stream_id: String(streamId),
          limit: String(limit)
        })
        return fetchWithAbort(url, 'epg')
      },

      async getSimpleDateTable(streamId) {
        const url = '/api/player_api.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || '',
          action: 'get_simple_data_table',
          stream_id: String(streamId)
        })
        return fetchWithAbort(url, 'epg')
      },

      async getXmltvFull() {
        const url = '/api/xmltv.php?' + new URLSearchParams({
          username: window.__xcConfig?.username || '',
          password: window.__xcConfig?.password || ''
        })
        return fetchWithAbort(url, 'epg', 30000) // 30s timeout para EPG completo
      },

      // Cancelar todas as requisi√ß√µes em andamento
      cancelAll() {
        Object.values(activeRequests).forEach(controller => {
          if (controller) controller.abort()
        })
        activeRequests.vod = null
        activeRequests.live = null
        activeRequests.series = null
        activeRequests.epg = null
      }
    }
  })()

  // ===== LAZY IMAGE COMPONENT (OPTIMIZED) =====
  const LazyImage = React.memo(({ src, alt, style, className, placeholder }) => {
    const [imageSrc, setImageSrc] = useState(placeholder || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 450"%3E%3Crect fill="%23222" width="300" height="450"/%3E%3C/svg%3E')
    const [isLoaded, setIsLoaded] = useState(false)
    const imgRef = useRef(null)

    useEffect(() => {
      if (!src) return

      // Intersection Observer para lazy loading
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              // Imagem entrou na viewport, carregar!
              const img = new Image()
              img.src = src
              img.onload = () => {
                setImageSrc(src)
                setIsLoaded(true)
              }
              img.onerror = () => {
                // Fallback se imagem falhar
                setImageSrc(placeholder || imageSrc)
              }
              observer.unobserve(entry.target)
            }
          })
        },
        {
          rootMargin: '50px', // Come√ßa a carregar 50px antes de entrar na tela
          threshold: 0.01
        }
      )

      if (imgRef.current) {
        observer.observe(imgRef.current)
      }

      return () => {
        if (imgRef.current) {
          observer.unobserve(imgRef.current)
        }
      }
    }, [src])

    return e('img', {
      ref: imgRef,
      src: imageSrc,
      alt: alt || '',
      className: className || '',
      style: {
        ...style,
        transition: 'opacity 0.3s ease-in-out',
        opacity: isLoaded ? 1 : 0.7
      }
    })
  }, (prevProps, nextProps) => {
    // S√≥ re-render se src mudar
    return prevProps.src === nextProps.src &&
           prevProps.className === nextProps.className
  })

  // ===== SIDEBAR COMPONENT =====
  function Sidebar({ view, setView }) {
    const [activeMenu, setActiveMenu] = useState('home')

    // Atualizar √≠cone ativo baseado na view atual
    useEffect(() => {
      if (view === 'home') setActiveMenu('home')
      else if (view === 'channels' || view === 'live-categories') setActiveMenu('channels')
      else if (view === 'netflix-movies' || view === 'vod-categories') setActiveMenu('movies')
      else if (view === 'series-categories' || view === 'netflix-series') setActiveMenu('series')
      else if (view === 'novelas-categories' || view === 'netflix-novelas') setActiveMenu('novelas')
      else if (view === 'animes-categories' || view === 'netflix-animes') setActiveMenu('animes')
      else if (view === 'desenhos-categories' || view === 'netflix-desenhos') setActiveMenu('desenhos')
      else if (view === 'show-categories' || view === 'netflix-show') setActiveMenu('show')
      else if (view === 'collections') setActiveMenu('collections')
      else if (view === 'config') setActiveMenu('config')
    }, [view])

    // Inicializar √≠cones Lucide ap√≥s render (APENAS UMA VEZ)
    useEffect(() => {
      if (window.lucide) {
        window.lucide.createIcons()
      }
    }, []) // ===== CORRIGIDO: Array vazio para executar apenas na montagem =====

    const menuItems = [
      { id: 'home', icon: 'home', title: 'Home', action: () => setView('home') },
      { id: 'channels', icon: 'tv', title: 'Canais', action: () => setView('live-categories') },
      { id: 'movies', icon: 'film', title: 'Filmes', action: () => {
        // Resetar modo cole√ß√µes ao voltar para filmes
        if (window.resetNetflixMovies) {
          window.resetNetflixMovies()
        }
        if (window.updateNetflixMoviesState) {
          window.updateNetflixMoviesState({ showCollectionsView: false })
        }
        setView('netflix-movies')
      }},
      { id: 'series', icon: 'clapperboard', title: 'S√©ries', action: () => {
        // Resetar estado e abrir tela de s√©ries estilo Netflix
        console.log('üé¨ [Sidebar] Clicou em S√âRIES - Resetando estado...')
        if (window.resetNetflixMovies) {
          window.resetNetflixMovies()
        }
        setView('netflix-series')
      }},
      { id: 'novelas', icon: 'book-open', title: 'Novelas', action: () => {
        console.log('üì∫ [Sidebar] Clicou em NOVELAS - Resetando estado...')
        if (window.resetNetflixMovies) {
          window.resetNetflixMovies()
        }
        setView('netflix-novelas')
      }},
      { id: 'animes', icon: 'sparkles', title: 'Animes', action: () => {
        console.log('‚≠ê [Sidebar] Clicou em ANIMES - Resetando estado...')
        if (window.resetNetflixMovies) {
          window.resetNetflixMovies()
        }
        setView('netflix-animes')
      }},
      { id: 'desenhos', icon: 'palette', title: 'Desenhos', action: () => {
        console.log('üé® [Sidebar] Clicou em DESENHOS - Resetando estado...')
        if (window.resetNetflixMovies) {
          window.resetNetflixMovies()
        }
        setView('netflix-desenhos')
      }},
      { id: 'collections', icon: 'layers', title: 'Colet√¢neas', action: () => {
        // Resetar estado e abrir tela de filmes normalmente primeiro
        if (window.resetNetflixMovies) {
          window.resetNetflixMovies()
        }
        setView('collections')
        // Aguardar um pouco para garantir que o NetflixMovies carregou
        setTimeout(() => {
          if (window.updateNetflixMoviesState) {
            console.log('[Sidebar] Ativando modo cole√ß√µes')
            window.updateNetflixMoviesState({ showCollectionsView: true })
          }
        }, 500)
      }},
      { id: 'show', icon: 'mic', title: 'Show', action: () => {
        if (window.resetNetflixMovies) {
          window.resetNetflixMovies()
        }
        setView('netflix-show')
      }}
    ]

    return e('aside', { className: 'sidebar' },
      ...menuItems.map(item =>
        e('button', {
          key: item.id,
          className: `sidebar-btn ${activeMenu === item.id ? 'active' : ''}`,
          'data-tooltip': item.title,
          onClick: item.action
        }, e('i', { 'data-lucide': item.icon, style: { width: '24px', height: '24px' } }))
      ),

      // Configura√ß√µes no final
      e('button', {
        className: `sidebar-btn ${activeMenu === 'config' ? 'active' : ''}`,
        'data-tooltip': 'Configura√ß√µes',
        onClick: () => setView('config'),
        style: { marginTop: 'auto' }
      }, e('i', { 'data-lucide': 'settings', style: { width: '24px', height: '24px' } }))
    )
  }

  // ===== HOOK CUSTOMIZADO PARA CONTROLE REMOTO =====
  function useRemoteControl(handlers = {}) {
    const [channelInput, setChannelInput] = useState('')
    const channelInputTimerRef = useRef(null)

    useEffect(() => {
      const handleKeyDown = (event) => {
        // ===== IGNORAR EVENTOS DE INPUTS/TEXTAREAS =====
        // Permite que backspace e outras teclas funcionem normalmente em campos de texto
        const target = event.target
        const isInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable
        if (isInput) {
          // N√£o interceptar eventos de teclado quando estiver em inputs
          return
        }

        // Log apenas se estiver em modo TV (reduz polui√ß√£o no console)
        const isTVMode = window.__isSmartTV
        if (isTVMode) {
          console.log(`üéÆ [REMOTE] Tecla: ${event.key} | Code: ${event.keyCode}`)
        }

        // SETAS - Navega√ß√£o
        if (RemoteKeyMap.matches(RemoteKeyMap.ARROW_UP, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Seta CIMA')
          handlers.onUp?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.ARROW_DOWN, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Seta BAIXO')
          handlers.onDown?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.ARROW_LEFT, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Seta ESQUERDA')
          handlers.onLeft?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.ARROW_RIGHT, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Seta DIREITA')
          handlers.onRight?.()
          return
        }

        // OK/ENTER - Selecionar
        if (RemoteKeyMap.matches(RemoteKeyMap.OK, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] OK/ENTER')
          handlers.onSelect?.()
          return
        }

        // BACK - Voltar
        if (RemoteKeyMap.matches(RemoteKeyMap.BACK, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] VOLTAR')
          handlers.onBack?.()
          return
        }

        // N√öMEROS 0-9 - Navega√ß√£o direta por canal
        for (let num = 0; num <= 9; num++) {
          if (RemoteKeyMap.matches(RemoteKeyMap[`NUM_${num}`], event)) {
            event.preventDefault()
            if (isTVMode) console.log(`üì∫ [REMOTE] N√∫mero: ${num}`)

            // Acumular n√∫meros digitados
            const newInput = channelInput + num
            setChannelInput(newInput)

            // Limpar timer anterior
            if (channelInputTimerRef.current) {
              clearTimeout(channelInputTimerRef.current)
            }

            // Aguardar 1.5s para confirmar o canal
            channelInputTimerRef.current = setTimeout(() => {
              handlers.onChannelNumber?.(newInput)
              setChannelInput('')
            }, 1500)

            return
          }
        }

        // BOT√ïES COLORIDOS
        if (RemoteKeyMap.matches(RemoteKeyMap.RED, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Bot√£o VERMELHO - Favoritos')
          handlers.onRed?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.GREEN, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Bot√£o VERDE - Guia EPG')
          handlers.onGreen?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.YELLOW, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Bot√£o AMARELO - Configura√ß√µes')
          handlers.onYellow?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.BLUE, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] Bot√£o AZUL - Busca')
          handlers.onBlue?.()
          return
        }

        // CONTROLE DE M√çDIA
        if (RemoteKeyMap.matches(RemoteKeyMap.PLAY, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] PLAY/PAUSE')
          handlers.onPlayPause?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.STOP, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] STOP')
          handlers.onStop?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.REWIND, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] REWIND')
          handlers.onRewind?.()
          return
        }

        if (RemoteKeyMap.matches(RemoteKeyMap.FORWARD, event)) {
          event.preventDefault()
          if (isTVMode) console.log('üì∫ [REMOTE] FORWARD')
          handlers.onForward?.()
          return
        }
      }

      // Registrar listener
      document.addEventListener('keydown', handleKeyDown)

      // Cleanup
      return () => {
        document.removeEventListener('keydown', handleKeyDown)
        if (channelInputTimerRef.current) {
          clearTimeout(channelInputTimerRef.current)
        }
      }
    }, [channelInput, handlers])

    return { channelInput }
  }

  function App(){
    const [view,setView] = useState('config')
    const [account,setAccount] = useState(null)
    const [loading,setLoading] = useState(false)
    const [error,setError] = useState('')
    const [debug,setDebug] = useState(null)

    const [cfg,setCfg] = useLocalStorage('xtream_config', { server:'', username:'', password:'' })
    const [tmdbKey,setTmdbKey] = useLocalStorage('tmdb_api_key', '7e61dfdf698b31e14082e80a0ca9f9fa')
    const [tmdbCache,setTmdbCache] = useLocalStorage('tmdb_cache', {})

    // ===== SISTEMA DE CACHE EM MEM√ìRIA PARA TMDB (PERFORMANCE) =====
    // Cache em RAM para evitar parsing JSON do localStorage a cada leitura
    const tmdbMemCache = useRef({
      search: {},     // Cache de buscas por nome
      details: {},    // Cache de detalhes por ID
      images: new Set() // Set de URLs de imagens j√° carregadas
    })

    // ===== RATE LIMITER INTELIGENTE PARA TMDB =====
    // TMDB tem limite de ~40 requisi√ß√µes por 10 segundos
    const tmdbRateLimiter = useRef({
      queue: [],           // Fila de requisi√ß√µes pendentes
      processing: false,   // Flag de processamento
      requestTimes: [],    // Timestamps das √∫ltimas requisi√ß√µes
      maxRequests: 35,     // M√°ximo de requisi√ß√µes (seguro: 35/10s)
      timeWindow: 10000    // Janela de tempo (10 segundos)
    })

    // ===== BATCHING DE REQUISI√á√ïES TMDB =====
    // Agrupa m√∫ltiplas requisi√ß√µes em lotes para evitar rate limit
    const tmdbBatcher = useRef({
      pending: new Map(),  // Map de promises pendentes (evita duplicatas)
      timeout: null,       // Timeout para processar batch
      batchDelay: 100      // Delay para agrupar requisi√ß√µes (100ms)
    })

    // Sincronizar configura√ß√£o com XCClient
    useEffect(() => {
      window.__xcConfig = {
        username: cfg.username || '',
        password: cfg.password || ''
      }
    }, [cfg.username, cfg.password])

    // ===== INTEGRA√á√ÉO DE CONTROLE REMOTO PARA SMART TV =====
    const { channelInput } = useRemoteControl({
      onUp: () => {
        // Navegar para cima nas listas
        const focused = document.activeElement
        if (!focused || focused === document.body) {
          // Focar primeiro elemento naveg√°vel
          const firstFocusable = document.querySelector('button, [role="button"], a[href]')
          firstFocusable?.focus()
        }
      },
      onDown: () => {
        // Navegar para baixo nas listas
        const focused = document.activeElement
        if (!focused || focused === document.body) {
          const firstFocusable = document.querySelector('button, [role="button"], a[href]')
          firstFocusable?.focus()
        }
      },
      onLeft: () => {
        // Navegar para esquerda (pode ser EPG ou sidebar)
        // Deixar navega√ß√£o nativa do browser
      },
      onRight: () => {
        // Navegar para direita (pode ser EPG ou detalhes)
        // Deixar navega√ß√£o nativa do browser
      },
      onSelect: () => {
        // Simular clique no elemento focado
        const focused = document.activeElement
        if (focused && focused !== document.body) {
          focused.click()
        }
      },
      onBack: () => {
        // Voltar para view anterior
        if (view === 'player') {
          setView('home')
        } else if (view === 'netflix-movies' || view === 'live-categories') {
          setView('home')
        } else if (view !== 'home' && view !== 'config') {
          setView('home')
        }
      },
      onChannelNumber: (number) => {
        // Ir direto para o canal digitado
        // TODO: Implementar l√≥gica de sele√ß√£o direta de canal
      },
      onRed: () => {
        // Bot√£o vermelho: Favoritos
        // TODO: Implementar tela de favoritos
      },
      onGreen: () => {
        // Bot√£o verde: Guia EPG completo
        setView('live-categories')
      },
      onYellow: () => {
        // Bot√£o amarelo: Configura√ß√µes
        setView('config')
      },
      onBlue: () => {
        // Bot√£o azul: Busca
        // TODO: Implementar tela de busca global
      },
      onPlayPause: () => {
        // Controlar reprodu√ß√£o do v√≠deo
        const video = document.querySelector('video')
        if (video) {
          if (video.paused) {
            video.play()
          } else {
            video.pause()
          }
        }
      },
      onStop: () => {
        // Parar reprodu√ß√£o e voltar
        if (view === 'player') {
          setView('home')
        }
      },
      onRewind: () => {
        // Retroceder 10 segundos
        const video = document.querySelector('video')
        if (video) {
          video.currentTime = Math.max(0, video.currentTime - 10)
        }
      },
      onForward: () => {
        // Avan√ßar 10 segundos
        const video = document.querySelector('video')
        if (video) {
          video.currentTime = Math.min(video.duration, video.currentTime + 10)
        }
      }
    })

    const [liveCats,setLiveCats] = useState([])
    const [vodCats,setVodCats] = useState([])
    const [seriesCats,setSeriesCats] = useState([])

    // TV ao vivo
    const [selectedLiveCat,setSelectedLiveCat] = useState(null)
    const [liveStreams,setLiveStreams] = useState([])
    const [selectedChannel,setSelectedChannel] = useState(null)
    const [epg,setEpg] = useState([])
    const [selectedDay,setSelectedDay] = useState(0) // 0 = hoje, 1 = amanh√£, etc.
    const [selectedEpgId,setSelectedEpgId] = useState(null) // ID do programa EPG selecionado
    const [liveLeftMode,setLiveLeftMode] = useState('categories')
    const autoOpenLiveRef = useRef(false)
    // NEW: contagem por categoria (para badge da esquerda)
    const [liveCounts,setLiveCounts] = useState({})
    const [liveAllCount,setLiveAllCount] = useState(0)

    // Quality variants system
    const [channelVariants,setChannelVariants] = useLocalStorage('channel_quality_prefs', {})
    const [toast,setToast] = useState(null)

    // Gen√©rico
    const [selectedCat,setSelectedCat] = useState(null)
    const [items,setItems] = useState([])
    const [query,setQuery] = useState('')

    const [current,setCurrent] = useState(null)
    const [selectedContent, setSelectedContent] = useState(null) // Para p√°gina de detalhes

    // Trailer modal (global)
    const [trailerUrl, setTrailerUrl] = useState(null)
    const [showTrailerModal, setShowTrailerModal] = useState(false)

    // ==== API core ====
    async function parseJsonFromResponse(res){
      const ct = (res.headers.get('content-type')||'').toLowerCase()
      if(ct.includes('application/json')) return res.json()
      const text = await res.text()
      try{ return JSON.parse(text) }catch{ throw new Error('Resposta n√£o-JSON da API') }
    }

    async function fetchJsonAuto(url){
      setDebug({ url })
      const res = await fetch(url, { headers:{ 'Accept':'application/json' } })

      const contentType = (res.headers.get('content-type') || '').toLowerCase()
      const text = await res.text()

      if(!res.ok) {
        throw new Error(`[HTTP ${res.status}] ${text.slice(0, 200)}`)
      }

      // Validar que √© JSON e n√£o HTML
      if(!contentType.includes('application/json') && !contentType.includes('text/plain')) {
        throw new Error(`Expected JSON, got: ${contentType || 'unknown'} | body: ${text.slice(0, 200)}`)
      }

      // Verificar se n√£o √© HTML (fallback do SPA)
      if(text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
        throw new Error('Received HTML instead of JSON - check proxy configuration')
      }

      try {
        return JSON.parse(text)
      } catch(e) {
        throw new Error('Invalid JSON response: ' + text.slice(0, 200))
      }
    }

    // Cache para requisi√ß√µes da API (evitar loops)
    const apiCache = {}
    const CACHE_DURATION = 5 * 60 * 1000 // 5 minutos

    async function apiCall(action, params){
      if(!cfg.server || !cfg.username || !cfg.password){ throw new Error('Configura√ß√£o incompleta') }

      // Criar chave de cache baseada na action e params
      const cacheKey = `${action}_${JSON.stringify(params || {})}`
      const now = Date.now()

      // Verificar se existe no cache e ainda √© v√°lido
      if(apiCache[cacheKey] && (now - apiCache[cacheKey].timestamp) < CACHE_DURATION){
        console.log(`‚ú® [CACHE HIT] ${action}`, params)
        return apiCache[cacheKey].data
      }

      // Usar cfg.server para construir URL correta
      const usp = new URLSearchParams({ username:cfg.username, password:cfg.password, action, ...(params||{}) })
      const url = buildURL(cfg.server, ['player_api.php']) + '?' + usp.toString()

      console.log(`üì° [API CALL] ${action}`, params)

      // Usar pool de requisi√ß√µes + retry
      return await withRequestPool(async () => {
        return await withRetry(async () => {
          try {
            const data = await fetchJsonAuto(url)

            // Salvar no cache
            apiCache[cacheKey] = { data, timestamp: now }

            return data
          } catch(error) {
            // get_vod_info com 502/500 n√£o √© cr√≠tico (pode buscar direto no TMDB)
            if(action === 'get_vod_info' && (error.message.includes('502') || error.message.includes('500'))) {
              console.warn(`‚ö†Ô∏è [API WARNING] ${action}: Servidor temporariamente indispon√≠vel, usando TMDB direto`)
            } else {
              console.error(`‚ùå [API ERROR] ${action}:`, error.message)
            }
            throw error
          }
        })
      })
    }

    // Compat: alguns pain√©is exigem 'series' ao inv√©s de 'series_id' em get_series_info
    async function apiCallSeriesInfo(seriesId){
      let data = null
      try{ data = await apiCall('get_series_info', { series_id: seriesId }) }catch{}
      const hasEpisodes = data && (data.episodes || (data.info && data.info.name))
      if(!hasEpisodes){
        try{ const alt = await apiCall('get_series_info', { series: seriesId }); if(alt) data = alt }catch{}
      }
      if(!data) throw new Error('Falha ao obter informa√ß√µes da s√©rie')
      return data
    }

    // TMDB API - OTIMIZADO COM CACHE EM MEM√ìRIA + RATE LIMITING
    async function searchTMDB(title, type = 'movie'){
      let apiKey = localStorage.getItem('tmdb_api_key')
      if(!apiKey || apiKey === '""' || apiKey === '') {
        apiKey = '7e61dfdf698b31e14082e80a0ca9f9fa'
      }
      // Remove aspas se tiver
      apiKey = apiKey.replace(/"/g, '')
      const cacheKey = `${type}_${title}`

      // ===== NOVO: Verificar cache em mem√≥ria primeiro =====
      const cached = getMemCache('search', cacheKey)
      if (cached) return cached

      // ===== NOVO: Usar batching para evitar requisi√ß√µes duplicadas =====
      return batchedTMDBRequest(`search_${cacheKey}`, async () => {
        try{
          // ===== SANITIZER AGRESSIVO: Remove sufixos comuns de t√≠tulos VOD =====
          let cleanTitle = title
            .replace(/\s*\([LDlD]\)/gi, '')    // Remove (L) (D) de legendado/dublado
            .replace(/\s*\((HD|FHD|4K|CAM|WEB-DL|BluRay|BRRip|DVDRip)\)/gi, '') // Qualidade entre par√™nteses
            .replace(/\b(UHD|FHD|4K|1080p|720p|HDR|TESTE4K|TESTE|2160p)\b/gi, '') // Qualidade sem par√™nteses
            .replace(/\(.*?\)/g, '')           // Remove (qualquer coisa restante)
            .replace(/\s*-\s*\d{4}$/g, '')     // Remove " - 2025" do final
            .replace(/\s*\d{4}\s*$/g, '')      // Remove "2025" do final
            .replace(/\s*-\s*$/, '')           // Remove " - " do final
            .replace(/[‚Äì‚Äî:]/g, ' ')            // Travess√µes e dois-pontos viram espa√ßo
            .normalize('NFD')                  // Normaliza acentos
            .replace(/[\u0300-\u036f]/g, '')   // Remove diacr√≠ticos (acentos)
            .replace(/\s{2,}/g, ' ')           // Normaliza espa√ßos m√∫ltiplos (2+)
            .trim()

          // Se ficou vazio ap√≥s limpeza, n√£o buscar
          if(!cleanTitle || cleanTitle.length < 2) {
            console.warn(`[searchTMDB] T√≠tulo inv√°lido ap√≥s sanitiza√ß√£o: "${title}"`)
            return null
          }

          console.log(`[searchTMDB] Buscando: "${title}" ‚Üí "${cleanTitle}"`)
          const url = `https://api.themoviedb.org/3/search/${type}?api_key=${apiKey}&query=${encodeURIComponent(cleanTitle)}&language=pt-BR`

          // ===== NOVO: Usar fila com dedupe =====
          const data = await schedule(`search:${type}:${cleanTitle}`, async () => {
            const res = await fetch(url)
            return await res.json()
          })

          console.log(`[searchTMDB] Resultados: ${data.results?.length || 0}`)
          if(data.results?.[0]) {
            console.log('[searchTMDB] Encontrado:', data.results[0].title || data.results[0].name)
            console.log('[searchTMDB] Overview:', data.results[0].overview?.substring(0, 100))
          }

          const result = data.results && data.results[0] ? {
            title: data.results[0].title || data.results[0].name,
            overview: data.results[0].overview,
            poster: data.results[0].poster_path ? `https://image.tmdb.org/t/p/w500${data.results[0].poster_path}` : null,
            backdrop: data.results[0].backdrop_path ? `https://image.tmdb.org/t/p/w1280${data.results[0].backdrop_path}` : null,
            rating: data.results[0].vote_average,
            year: (data.results[0].release_date || data.results[0].first_air_date || '').substring(0, 4),
            tmdb_id: data.results[0].id
          } : null

          // ===== NOVO: Salvar em cache de mem√≥ria + localStorage =====
          setMemCache('search', cacheKey, result)
          return result
        }catch(err){
          console.error('[searchTMDB] Erro:', err)
          return null
        }
      })
    }

    // ===== FUN√á√ïES DE PERFORMANCE TMDB =====

    // Rate Limiter com Concorr√™ncia: Garante que n√£o ultrapassamos 35 req/10s E m√°ximo 6 simult√¢neas
    async function rateLimitedFetch(url, requestType = 'unknown') {
      const limiter = tmdbRateLimiter.current

      // Inicializar contador de requisi√ß√µes simult√¢neas
      if (!limiter.running) limiter.running = 0
      if (!limiter.queue) limiter.queue = []
      const MAX_CONCURRENT = 6

      // Se j√° estamos no m√°ximo de concorr√™ncia, enfileirar
      if (limiter.running >= MAX_CONCURRENT) {
        console.log(`[CONCURRENCY] üîÑ Enfileirando ${requestType} (${limiter.running}/${MAX_CONCURRENT} rodando, ${limiter.queue.length} na fila)`)
        return new Promise((resolve, reject) => {
          limiter.queue.push(() => rateLimitedFetch(url, requestType).then(resolve).catch(reject))
        })
      }

      const now = Date.now()

      // Limpar timestamps antigos (fora da janela de 10s)
      limiter.requestTimes = limiter.requestTimes.filter(time => now - time < limiter.timeWindow)

      // Se atingiu o limite de rate, aguardar
      if (limiter.requestTimes.length >= limiter.maxRequests) {
        const oldestRequest = limiter.requestTimes[0]
        const waitTime = limiter.timeWindow - (now - oldestRequest) + 100 // +100ms margem
        console.log(`[RATE LIMIT] ‚è≥ Aguardando ${Math.ceil(waitTime/1000)}s (${limiter.requestTimes.length}/${limiter.maxRequests} req)`)
        await new Promise(resolve => setTimeout(resolve, waitTime))
        return rateLimitedFetch(url, requestType) // Tentar novamente
      }

      // Incrementar contador de requisi√ß√µes simult√¢neas
      limiter.running++

      // Registrar requisi√ß√£o no rate limit
      limiter.requestTimes.push(Date.now())
      console.log(`[RATE LIMIT] ‚úÖ ${requestType}: ${limiter.requestTimes.length}/${limiter.maxRequests} req, ${limiter.running}/${MAX_CONCURRENT} simult√¢neas`)

      try {
        // Executar fetch
        return await fetch(url)
      } finally {
        // Decrementar contador
        limiter.running--

        // Processar pr√≥ximo item da fila
        if (limiter.queue.length > 0 && limiter.running < MAX_CONCURRENT) {
          const next = limiter.queue.shift()
          setTimeout(() => next(), 0) // Processar na pr√≥xima tick
        }
      }
    }

    // Batching: Agrupa requisi√ß√µes duplicadas (evita buscar mesmo filme 2x)
    function batchedTMDBRequest(key, fetchFunction) {
      const batcher = tmdbBatcher.current

      // Se j√° existe uma promise pendente para esta key, retornar ela
      if (batcher.pending.has(key)) {
        console.log(`[BATCH] ‚ôªÔ∏è Reutilizando requisi√ß√£o pendente: ${key}`)
        return batcher.pending.get(key)
      }

      // Criar nova promise
      const promise = fetchFunction().finally(() => {
        // Remover da fila ap√≥s completar
        batcher.pending.delete(key)
      })

      batcher.pending.set(key, promise)
      console.log(`[BATCH] üÜï Nova requisi√ß√£o: ${key} (${batcher.pending.size} pendentes)`)

      return promise
    }

    // Cache em mem√≥ria: Verifica cache RAM antes de localStorage
    function getMemCache(type, key) {
      const cache = tmdbMemCache.current

      if (type === 'search' && cache.search[key]) {
        console.log(`[MEM CACHE] ‚ö° Hit search: ${key}`)
        return cache.search[key]
      }

      if (type === 'details' && cache.details[key]) {
        console.log(`[MEM CACHE] ‚ö° Hit details: ${key}`)
        return cache.details[key]
      }

      // Tentar localStorage como fallback
      const cacheKey = type === 'search' ? key : `details_${key}`
      if (tmdbCache[cacheKey]) {
        console.log(`[STORAGE CACHE] üíæ Hit: ${cacheKey}`)
        // Copiar para mem√≥ria para pr√≥ximas leituras
        if (type === 'search') {
          cache.search[key] = tmdbCache[cacheKey]
        } else {
          cache.details[key] = tmdbCache[cacheKey]
        }
        return tmdbCache[cacheKey]
      }

      return null
    }

    // Salvar em ambos os caches (mem√≥ria + localStorage)
    function setMemCache(type, key, value) {
      const cache = tmdbMemCache.current

      if (type === 'search') {
        cache.search[key] = value
        setTmdbCache(prev => ({ ...prev, [key]: value }))
      } else {
        cache.details[key] = value
        const cacheKey = `details_${key}`
        setTmdbCache(prev => ({ ...prev, [cacheKey]: value }))
      }

      console.log(`[CACHE] üíæ Salvando ${type}: ${key}`)
    }

    // ===== LAZY LOADING INTELIGENTE DE IMAGENS =====
    // Pr√©-carrega imagens de forma controlada para evitar overhead
    const imagePreloader = useRef({
      loaded: new Set(),    // URLs j√° carregadas
      loading: new Set(),   // URLs sendo carregadas no momento
      queue: [],           // Fila de URLs para carregar
      processing: false,   // Flag de processamento
      maxConcurrent: 6     // M√°ximo de imagens simult√¢neas
    })

    // Pr√©-carrega uma imagem (retorna promise)
    function preloadImage(url) {
      const preloader = imagePreloader.current

      if (!url || preloader.loaded.has(url)) {
        return Promise.resolve() // J√° carregada
      }

      if (preloader.loading.has(url)) {
        // J√° est√° sendo carregada, aguardar
        return new Promise((resolve) => {
          const checkInterval = setInterval(() => {
            if (preloader.loaded.has(url) || !preloader.loading.has(url)) {
              clearInterval(checkInterval)
              resolve()
            }
          }, 100)
        })
      }

      // Marcar como carregando
      preloader.loading.add(url)

      return new Promise((resolve, reject) => {
        const img = new Image()

        img.onload = () => {
          preloader.loading.delete(url)
          preloader.loaded.add(url)
          console.log(`[IMAGE] ‚úÖ Carregada: ${url.substring(0, 60)}...`)
          resolve()
        }

        img.onerror = () => {
          preloader.loading.delete(url)
          console.warn(`[IMAGE] ‚ùå Erro ao carregar: ${url.substring(0, 60)}...`)
          reject()
        }

        img.src = url
      })
    }

    // Pr√©-carrega m√∫ltiplas imagens em lotes controlados
    async function preloadImagesInBatches(urls) {
      const preloader = imagePreloader.current
      const validUrls = urls.filter(url => url && !preloader.loaded.has(url))

      if (validUrls.length === 0) {
        console.log('[IMAGE] Todas as imagens j√° est√£o carregadas')
        return
      }

      console.log(`[IMAGE] üì¶ Pr√©-carregando ${validUrls.length} imagens em lotes de ${preloader.maxConcurrent}`)

      // Dividir em lotes
      for (let i = 0; i < validUrls.length; i += preloader.maxConcurrent) {
        const batch = validUrls.slice(i, i + preloader.maxConcurrent)
        console.log(`[IMAGE] Lote ${Math.floor(i / preloader.maxConcurrent) + 1}: ${batch.length} imagens`)

        // Carregar lote em paralelo
        await Promise.allSettled(batch.map(url => preloadImage(url)))

        // Pequeno delay entre lotes para n√£o sobrecarregar
        if (i + preloader.maxConcurrent < validUrls.length) {
          await new Promise(resolve => setTimeout(resolve, 200))
        }
      }

      console.log(`[IMAGE] ‚úÖ Pr√©-carregamento conclu√≠do`)
    }

    // Buscar detalhes completos do TMDB (g√™neros, dura√ß√£o, etc.) em pt-BR - OTIMIZADO
    async function getTMDBDetails(tmdb_id, type = 'movie'){
      let apiKey = localStorage.getItem('tmdb_api_key')
      if(!apiKey || apiKey === '""' || apiKey === '') {
        apiKey = '7e61dfdf698b31e14082e80a0ca9f9fa'
      }
      // Remove aspas se tiver
      apiKey = apiKey.replace(/"/g, '')

      if(!tmdb_id) {
        console.warn('[getTMDBDetails] Sem TMDB ID')
        return null
      }

      const cacheKey = `${type}_${tmdb_id}`

      // ===== NOVO: Verificar cache em mem√≥ria primeiro =====
      const cached = getMemCache('details', cacheKey)
      if (cached && cached.belongs_to_collection !== undefined) {
        return cached
      }

      // ===== NOVO: Usar batching para evitar requisi√ß√µes duplicadas =====
      return batchedTMDBRequest(`details_${cacheKey}`, async () => {
        try{
          // ===== BUSCAR DETALHES + CR√âDITOS (elenco e diretor) =====
          const url = `https://api.themoviedb.org/3/${type}/${tmdb_id}?api_key=${apiKey}&language=pt-BR&append_to_response=credits`
          console.log(`[getTMDBDetails] Buscando: ID ${tmdb_id}`)

          // ===== NOVO: Usar rate limiter =====
          const res = await rateLimitedFetch(url, `details:${tmdb_id}`)
          const data = await res.json()

          console.log('[getTMDBDetails] Resposta TMDB:', data.title || data.name)

          // ===== EXTRAIR ELENCO PRINCIPAL (top 5) =====
          const cast = data.credits?.cast?.slice(0, 5).map(actor => actor.name).join(', ') || null

          // ===== EXTRAIR DIRETOR =====
          const director = data.credits?.crew?.find(person => person.job === 'Director')?.name || null

          const result = {
            title: data.title || data.name,
            overview: data.overview || data.description,
            poster: data.poster_path ? `https://image.tmdb.org/t/p/w500${data.poster_path}` : null,
            backdrop: data.backdrop_path ? `https://image.tmdb.org/t/p/w1280${data.backdrop_path}` : null,
            rating: data.vote_average,
            vote_count: data.vote_count || 0, // ===== NOVO: Quantidade de votos =====
            year: (data.release_date || data.first_air_date || '').substring(0, 4),
            runtime: data.runtime || data.episode_run_time?.[0] || null,
            genres: data.genres ? data.genres.map(g => g.name).join(', ') : '',
            cast: cast, // ===== NOVO: Elenco =====
            director: director, // ===== NOVO: Diretor =====
            original_language: data.original_language?.toUpperCase() || null, // ===== NOVO: Idioma =====
            status: data.status || null, // ===== NOVO: Status (Released, etc) =====
            tmdb_id: data.id,
            belongs_to_collection: data.belongs_to_collection || null // Informa√ß√£o da cole√ß√£o
          }

          console.log('[getTMDBDetails] Overview encontrado:', result.overview?.substring(0, 100))
          if(result.belongs_to_collection) {
            console.log('[getTMDBDetails] üé¨ Collection encontrada:', result.belongs_to_collection.name, '(ID:', result.belongs_to_collection.id, ')')
          }

          // ===== OTIMIZA√á√ÉO: Fallback para EN-US se PT-BR n√£o tiver overview =====
          if(!result.overview){
            console.log('[getTMDBDetails] ‚ö†Ô∏è Sem overview em PT-BR, buscando EN-US...')
            try {
              const urlEn = `https://api.themoviedb.org/3/${type}/${tmdb_id}?api_key=${apiKey}&language=en-US`
              const resEn = await rateLimitedFetch(urlEn, `details-en:${tmdb_id}`)
              const dataEn = await resEn.json()
              result.overview = dataEn.overview || 'Sem descri√ß√£o dispon√≠vel.'
              console.log('[getTMDBDetails] ‚úÖ Overview EN-US obtido:', result.overview?.substring(0, 80))
            } catch(errEn) {
              console.warn('[getTMDBDetails] ‚ö†Ô∏è Falha ao buscar EN-US:', errEn.message)
              result.overview = 'Sem descri√ß√£o dispon√≠vel.'
            }
          }

          // ===== NOVO: Salvar em cache de mem√≥ria + localStorage =====
          setMemCache('details', cacheKey, result)
          return result
        }catch(err){
          console.error('[getTMDBDetails] Erro:', err)
          return null
        }
      })
    }

    // Buscar trailer do YouTube no TMDB
    async function getTMDBTrailer(tmdb_id, type = 'movie'){
      let apiKey = localStorage.getItem('tmdb_api_key')
      if(!apiKey || apiKey === '""' || apiKey === '') {
        apiKey = '7e61dfdf698b31e14082e80a0ca9f9fa'
      }
      apiKey = apiKey.replace(/"/g, '')

      if(!tmdb_id) return null

      const cacheKey = `trailer_${type}_${tmdb_id}`

      // ===== NOVO: Verificar cache em mem√≥ria primeiro =====
      const cached = getMemCache('details', cacheKey)
      if(cached) {
        console.log(`[getTMDBTrailer] ‚ö° Cache hit: ${cacheKey}`)
        return cached
      }

      // ===== NOVO: Usar batching para evitar duplicatas =====
      return batchedTMDBRequest(`trailer_${cacheKey}`, async () => {
        try{
          const url = `https://api.themoviedb.org/3/${type}/${tmdb_id}/videos?api_key=${apiKey}&language=pt-BR`
          // ===== NOVO: Rate limiting =====
          const res = await rateLimitedFetch(url, `trailer:${tmdb_id}`)
          const data = await res.json()

          // Buscar trailer oficial do YouTube
          const trailer = data.results?.find(v =>
            v.site === 'YouTube' &&
            (v.type === 'Trailer' || v.type === 'Teaser')
          )

          // Fallback para en-US se n√£o encontrar em pt-BR
          if(!trailer) {
            const urlEn = `https://api.themoviedb.org/3/${type}/${tmdb_id}/videos?api_key=${apiKey}&language=en-US`
            // ===== NOVO: Rate limiting =====
            const resEn = await rateLimitedFetch(urlEn, `trailer-en:${tmdb_id}`)
            const dataEn = await resEn.json()
            const trailerEn = dataEn.results?.find(v =>
              v.site === 'YouTube' &&
              (v.type === 'Trailer' || v.type === 'Teaser')
            )
            if(trailerEn) {
              const result = `https://www.youtube.com/embed/${trailerEn.key}`
              // ===== NOVO: Salvar em ambos os caches =====
              setMemCache('details', cacheKey, result)
              return result
            }
          }

          if(trailer) {
            const result = `https://www.youtube.com/embed/${trailer.key}`
            // ===== NOVO: Salvar em ambos os caches =====
            setMemCache('details', cacheKey, result)
            return result
          }

          return null
        }catch(err){
          console.error('[getTMDBTrailer] Erro:', err)
          return null
        }
      })
    }

    // ===== COLE√á√ïES TMDB =====
    // Identificar e agrupar cole√ß√µes a partir dos filmes locais
    async function findCollectionsInMovies(movies) {
      console.log('[findCollections] Analisando', movies.length, 'filmes para encontrar cole√ß√µes...')
      const collectionsMap = new Map()

      for(const movie of movies) {
        // Debug: mostrar se o filme tem collection
        if(movie.tmdb_collection) {
          console.log('[findCollections] üìΩÔ∏è', movie.name, '-> Collection:', movie.tmdb_collection)
        }

        // Se o filme j√° foi enriquecido e tem collection_id
        if(movie.tmdb_collection && movie.tmdb_collection.id) {
          const collectionId = movie.tmdb_collection.id

          if(!collectionsMap.has(collectionId)) {
            collectionsMap.set(collectionId, {
              id: collectionId,
              name: movie.tmdb_collection.name,
              poster: movie.tmdb_collection.poster_path ?
                `https://image.tmdb.org/t/p/w500${movie.tmdb_collection.poster_path}` : null,
              backdrop: movie.tmdb_collection.backdrop_path ?
                `https://image.tmdb.org/t/p/w1280${movie.tmdb_collection.backdrop_path}` : null,
              movies: []
            })
            console.log('[findCollections] ‚úÖ Nova cole√ß√£o:', movie.tmdb_collection.name, '(ID:', collectionId, ')')
          }

          collectionsMap.get(collectionId).movies.push(movie)
        }
      }

      console.log(`[findCollections] üé¨ Encontradas ${collectionsMap.size} cole√ß√µes`)
      const result = Array.from(collectionsMap.values())
      console.log('[findCollections] Cole√ß√µes completas:', result)
      return result
    }

    // Buscar informa√ß√µes completas de uma cole√ß√£o
    async function getTMDBCollection(collection_id) {
      let apiKey = localStorage.getItem('tmdb_api_key')
      if(!apiKey || apiKey === '""' || apiKey === '') {
        apiKey = '7e61dfdf698b31e14082e80a0ca9f9fa'
      }
      apiKey = apiKey.replace(/"/g, '')

      if(!collection_id) {
        console.warn('[getTMDBCollection] Sem collection ID')
        return null
      }

      const cacheKey = `collection_${collection_id}`
      if(tmdbCache[cacheKey]) {
        console.log(`[getTMDBCollection] Cache hit para collection ${collection_id}`)
        return tmdbCache[cacheKey]
      }

      try {
        const url = `https://api.themoviedb.org/3/collection/${collection_id}?api_key=${apiKey}&language=pt-BR`
        console.log(`[getTMDBCollection] Buscando: ${url}`)
        const res = await fetch(url)
        const data = await res.json()

        console.log('[getTMDBCollection] Resposta TMDB:', data)

        const result = {
          id: data.id,
          name: data.name,
          overview: data.overview,
          poster: data.poster_path ? `https://image.tmdb.org/t/p/w500${data.poster_path}` : null,
          backdrop: data.backdrop_path ? `https://image.tmdb.org/t/p/original${data.backdrop_path}` : null,
          parts: data.parts || [] // Array de filmes da cole√ß√£o
        }

        // Fallback para en-US se pt-BR n√£o tiver overview
        if(!result.overview) {
          console.log('[getTMDBCollection] Sem overview em PT-BR, buscando EN-US...')
          const urlEn = `https://api.themoviedb.org/3/collection/${collection_id}?api_key=${apiKey}&language=en-US`
          const resEn = await fetch(urlEn)
          const dataEn = await resEn.json()
          result.overview = dataEn.overview || ''
          if(!result.name) result.name = dataEn.name || ''
        }

        setTmdbCache(prev => ({ ...prev, [cacheKey]: result }))
        return result
      } catch(err) {
        console.error('[getTMDBCollection] Erro:', err)
        return null
      }
    }

    // ===== ENRIQUECIMENTO AUTOM√ÅTICO DE FILMES =====
    // Busca TMDB ID do servidor primeiro, depois fallback para busca por nome
    async function enrichMovieWithTMDB(movie, contentType = 'movie') {
      let apiKey = localStorage.getItem('tmdb_api_key')
      if(!apiKey || apiKey === '""' || apiKey === '') {
        apiKey = '7e61dfdf698b31e14082e80a0ca9f9fa'
      }
      // Remove aspas se tiver
      apiKey = apiKey.replace(/"/g, '')

      // Detectar tipo de conte√∫do (s√©rie ou filme) automaticamente
      const tmdbType = contentType === 'series' || movie.series_id ? 'tv' : 'movie'
      console.log(`[enrichMovieWithTMDB] Tipo detectado: ${tmdbType} para "${movie.name || movie.title}"`)

      // ===== GUARD: Verificar cache de enriquecimento PRIMEIRO =====
      // ===== CORRE√á√ÉO: Incluir nome do filme na chave quando stream_id for undefined =====
      const streamId = movie.stream_id || movie.id
      const movieName = movie.name || movie.title || ''
      const cacheKey = streamId && streamId !== 'undefined' ? streamId : `name_${movieName}`

      if (!window.__enrichmentCache) {
        window.__enrichmentCache = new Map()
      }

      if (window.__enrichmentCache.has(cacheKey)) {
        const cached = window.__enrichmentCache.get(cacheKey)
        console.log(`[ENRICH] ‚ö° Cache HIT por chave: ${cacheKey} - "${movieName}"`)
        return cached
      }

      console.log(`[DEBUG ENRICH] üîë Cache key: ${cacheKey} para "${movieName}"`)

      // ===== NOVO: Usar prepareForTMDB para normaliza√ß√£o =====
      const originalName = movie.name || movie.title
      const titleInfo = prepareForTMDB(originalName)

      // Adicionar propriedade para identificar legendado
      const movieWithLangType = {
        ...movie,
        langType: titleInfo.langType,
        isLegendado: titleInfo.isLegendado,
        displayName: titleInfo.displayTitle,      // Nome para exibir (com "(L)")
        searchName: titleInfo.searchTitle          // Nome para buscar no TMDB (limpo)
      }

      // Se j√° tem dados TMDB completos, retorna e cacheia
      if(movie.tmdb_overview && movie.tmdb_poster && movie.tmdb_backdrop) {
        const enriched = { ...movieWithLangType, ...movie }
        window.__enrichmentCache.set(cacheKey, enriched)
        return enriched
      }

      // ===== OTIMIZA√á√ÉO: Verificar cache por nome PRIMEIRO (mais r√°pido) =====
      const cleanName = titleInfo.searchTitle.toLowerCase().replace(/[^\w\s]/g, '').trim()
      const cachedSearch = getMemCache('search', cleanName)

      if (cachedSearch) {
        console.log(`[ENRICH] ‚ö° Cache HIT por nome: "${titleInfo.searchTitle}"`)
        const enriched = {
          ...movieWithLangType,
          tmdb_id: cachedSearch.tmdb_id,
          tmdb_poster: cachedSearch.poster,
          tmdb_backdrop: cachedSearch.backdrop,
          tmdb_overview: cachedSearch.overview,
          tmdb_rating: cachedSearch.rating,
          tmdb_vote_count: cachedSearch.vote_count,
          tmdb_year: cachedSearch.year,
          tmdb_runtime: cachedSearch.runtime,
          tmdb_genres: cachedSearch.genres,
          tmdb_cast: cachedSearch.cast,
          tmdb_director: cachedSearch.director,
          tmdb_language: cachedSearch.original_language,
          tmdb_status: cachedSearch.status,
          tmdb_collection: cachedSearch.belongs_to_collection
        }
        window.__enrichmentCache.set(cacheKey, enriched)
        return enriched
      }

      try {
        let tmdbId = movie.tmdb_id // Pode vir do cache ou do servidor
        console.log(`[ENRICH] üÜî tmdb_id do servidor: ${tmdbId} para "${titleInfo.searchTitle}"`)

        // ===== DESABILITADO: get_vod_info muito lento e n√£o retorna JSON =====
        // Ir direto para busca TMDB por nome (mais r√°pido e confi√°vel)

        // Estrat√©gia 1: Se tem TMDB ID (do servidor ou cache), busca detalhes completos
        if(tmdbId) {
          console.log(`[ENRICH] ‚úÖ Buscando detalhes TMDB por ID: ${tmdbId} (tipo: ${tmdbType})`)
          const details = await getTMDBDetails(tmdbId, tmdbType)

          if(details) {
            const enriched = {
              ...movieWithLangType,
              tmdb_id: tmdbId,
              tmdb_poster: details.poster,
              tmdb_backdrop: details.backdrop,
              tmdb_overview: details.overview,
              tmdb_rating: details.rating,
              tmdb_vote_count: details.vote_count,
              tmdb_year: details.year,
              tmdb_runtime: details.runtime,
              tmdb_genres: details.genres,
              tmdb_cast: details.cast,
              tmdb_director: details.director,
              tmdb_language: details.original_language,
              tmdb_status: details.status,
              tmdb_collection: details.belongs_to_collection
            }
            window.__enrichmentCache.set(cacheKey, enriched)
            return enriched
          }
        }

        // Estrat√©gia 2 (principal): Busca por nome (sem "(L)" para legendado)
        console.log(`[ENRICH] Buscando por nome "${titleInfo.searchTitle}"${titleInfo.isLegendado ? ' (legendado)' : ''} (tipo: ${tmdbType})`)
        const searchResult = await searchTMDB(titleInfo.searchTitle, tmdbType)

        if(searchResult) {
          console.log(`[ENRICH] ‚úÖ Encontrado por nome: TMDB ID ${searchResult.tmdb_id}`)

          // Buscar detalhes completos usando o ID encontrado
          console.log(`[ENRICH] üîç Buscando detalhes completos para TMDB ID ${searchResult.tmdb_id}...`)
          const fullDetails = await getTMDBDetails(searchResult.tmdb_id, tmdbType)

          if(fullDetails) {
            const enriched = {
              ...movieWithLangType,
              tmdb_id: searchResult.tmdb_id,
              tmdb_poster: fullDetails.poster,
              tmdb_backdrop: fullDetails.backdrop,
              tmdb_overview: fullDetails.overview,
              tmdb_rating: fullDetails.rating,
              tmdb_vote_count: fullDetails.vote_count,
              tmdb_year: fullDetails.year,
              tmdb_runtime: fullDetails.runtime,
              tmdb_genres: fullDetails.genres,
              tmdb_cast: fullDetails.cast,
              tmdb_director: fullDetails.director,
              tmdb_language: fullDetails.original_language,
              tmdb_status: fullDetails.status,
              tmdb_collection: fullDetails.belongs_to_collection
            }
            window.__enrichmentCache.set(cacheKey, enriched)
            return enriched
          }

          // Fallback: se detalhes falharem, usar dados b√°sicos da busca
          const enriched = {
            ...movieWithLangType,
            tmdb_id: searchResult.tmdb_id,
            tmdb_poster: searchResult.poster,
            tmdb_backdrop: searchResult.backdrop,
            tmdb_overview: searchResult.overview,
            tmdb_rating: searchResult.rating,
            tmdb_year: searchResult.year
          }
          window.__enrichmentCache.set(cacheKey, enriched)
          return enriched
        }

        console.warn(`[ENRICH] ‚ùå N√£o foi poss√≠vel enriquecer "${titleInfo.searchTitle}"`)
        window.__enrichmentCache.set(cacheKey, movieWithLangType)
        return movieWithLangType

      } catch(err) {
        console.warn(`[ENRICH] Erro ao enriquecer "${titleInfo.searchTitle}":`, err.message)
        window.__enrichmentCache.set(cacheKey, movieWithLangType)
        return movieWithLangType
      }
    }

    async function fetchAccountInfo(){
      if(!cfg.server || !cfg.username || !cfg.password){ throw new Error('Configura√ß√£o incompleta') }
      const qs = new URLSearchParams({ username:cfg.username, password:cfg.password })
      const url1 = buildURL(cfg.server, ['player_api.php']) + '?' + qs.toString() + '&action=get_account_info'
      const url2 = buildURL(cfg.server, ['player_api.php']) + '?' + qs.toString()
      try{ return await fetchJsonAuto(url1) }catch(e1){ return await fetchJsonAuto(url2) }
    }

    function explainLoginError(msg){
      if(/cors|network|falha de rede/i.test(msg)) return 'O painel bloqueou requisi√ß√µes do navegador (CORS) OU o DNS/porta est√° errado/fora do ar.'
      if(/401|403/.test(msg)) return 'Usu√°rio/senha incorretos ou bloqueados.'
      if(/404/.test(msg)) return 'Endpoint /player_api.php n√£o encontrado nesse DNS/porta.'
      if(/Resposta n√£o-JSON|Resposta inv√°lida/i.test(msg)) return 'Formato de resposta inesperado para a API.'
      return 'N√£o foi poss√≠vel autenticar com essas credenciais/URL.'
    }

    // Carregamento pontual por se√ß√£o
    async function loadCatsByType(type){
      try{
        if(type==='live'){
          const raw = await apiCall('get_live_categories')
          setLiveCats(toArray(raw))
        }else if(type==='vod'){
          const raw = await apiCall('get_vod_categories')
          setVodCats(toArray(raw))
        }else{
          const raw = await apiCall('get_series_categories')
          setSeriesCats(toArray(raw))
        }
      }catch(err){ setError(err.message) }
    }

    // Contar canais por categoria (apenas para Live)
    async function loadLiveCounts(){
      try{
        const all = toArray(await apiCall('get_live_streams'))
        const map = {}
        for(const s of all){
          const cid = s.category_id ?? s.categoryId ?? s.category ?? s.stream_category_id
          if(cid!=null) map[cid] = (map[cid]||0) + 1
        }
        setLiveCounts(map)
        setLiveAllCount(all.length)
      }catch{ /* silencioso: se falhar, mostramos 0 ou cat.total */ }
    }

    // S√≥ busca quando a view entrar E se ainda n√£o tiver sido pr√©-carregado
    useEffect(()=>{
      // Com o preload, as categorias j√° estar√£o carregadas na maioria dos casos
      // S√≥ carrega se realmente estiver vazio (fallback)
      if(view==='live-categories' && liveCats.length===0) {
        autoOpenLiveRef.current = false
        console.log('‚ö†Ô∏è [Fallback] Carregando Live Categories...')
        loadCatsByType('live')
      }
      if(view==='movie-categories' && vodCats.length===0) {
        console.log('‚ö†Ô∏è [Fallback] Carregando VOD Categories...')
        loadCatsByType('vod')
      }
      if(view==='series-categories' && seriesCats.length===0) {
        console.log('‚ö†Ô∏è [Fallback] Carregando Series Categories...')
        loadCatsByType('series')
      }
      if(view==='novelas-categories' && seriesCats.length===0) loadCatsByType('series')
      if(view==='animes-categories' && seriesCats.length===0) loadCatsByType('series')
      if(view==='desenhos-categories' && seriesCats.length===0) loadCatsByType('series')
      if(view==='show-categories' && vodCats.length===0) loadCatsByType('vod')
    }, [view])

    // Ao carregar as categorias do Live, abrimos a 1¬™ e, se necess√°rio, buscamos contagens
    useEffect(()=>{
      if(view==='live-categories' && liveCats.length>0){
        if(!selectedLiveCat && !autoOpenLiveRef.current){
          autoOpenLiveRef.current = true
          ;(async()=>{ try{ await openLiveCategory(liveCats[0], false) }catch(e){} })()
        }
        if(Object.keys(liveCounts).length===0){ loadLiveCounts() }
      }
    }, [view, liveCats, selectedLiveCat])

    // reset da flag ao sair da view
    useEffect(()=>{ if(view!=='live-categories') autoOpenLiveRef.current = false }, [view])

    useEffect(()=>{ // autoload se j√° tiver config
      if(cfg.server && cfg.username && cfg.password){
        setError('')
        fetchAccountInfo().then(info=> {
          setAccount(info.user_info||info)
          setView('home')

          // Pr√©-carregar categorias em background ap√≥s auto-login
          preloadAllCategories()
          // DESABILITADO: pr√©-carregamento de conte√∫do (causava loop infinito)
          // preloadTopVodContent()
        }).catch(err=> setError(explainLoginError(err.message||String(err))))
      }
    },[])

    // Pr√©-carregar TODAS as categorias em paralelo com cache localStorage
    async function preloadAllCategories(){
      console.log('üöÄ [Preload] Iniciando pr√©-carregamento de categorias...')

      const CACHE_KEY = 'categories_cache_v1'
      const CACHE_DURATION = 60 * 60 * 1000 // 1 hora em ms

      try{
        // Tentar carregar do cache primeiro
        const cached = localStorage.getItem(CACHE_KEY)
        if(cached){
          const { data, timestamp } = JSON.parse(cached)
          const age = Date.now() - timestamp

          if(age < CACHE_DURATION){
            console.log('üì¶ [Cache] Usando cache localStorage (idade: ' + Math.round(age/1000) + 's)')
            setLiveCats(toArray(data.live))
            setVodCats(toArray(data.vod))
            setSeriesCats(toArray(data.series))

            // Atualizar em background
            console.log('üîÑ [Cache] Atualizando cache em background...')
            updateCacheInBackground()
            return
          }
        }

        // Cache expirado ou n√£o existe - buscar da API
        await fetchAndCacheCategories()

      }catch(err){
        console.error('‚ùå [Preload] Erro ao carregar categorias:', err)
        // Se cache falhar, tentar buscar da API mesmo assim
        await fetchAndCacheCategories()
      }
    }

    // Buscar da API e salvar no cache
    async function fetchAndCacheCategories(){
      console.log('üåê [API] Buscando categorias da API...')
      const [liveData, vodData, seriesData] = await Promise.all([
        apiCall('get_live_categories').catch(()=>[]),
        apiCall('get_vod_categories').catch(()=>[]),
        apiCall('get_series_categories').catch(()=>[])
      ])

      const live = toArray(liveData)
      const vod = toArray(vodData)
      const series = toArray(seriesData)

      setLiveCats(live)
      setVodCats(vod)
      setSeriesCats(series)

      // Salvar no cache
      const CACHE_KEY = 'categories_cache_v1'
      try{
        localStorage.setItem(CACHE_KEY, JSON.stringify({
          data: { live, vod, series },
          timestamp: Date.now()
        }))
        console.log('üíæ [Cache] Categorias salvas no cache')
      }catch(e){
        console.warn('‚ö†Ô∏è [Cache] Falha ao salvar cache:', e)
      }

      console.log('‚úÖ [Preload] Categorias carregadas:', {
        live: live.length,
        vod: vod.length,
        series: series.length
      })
    }

    // Atualizar cache em background sem bloquear UI
    async function updateCacheInBackground(){
      try{
        const [liveData, vodData, seriesData] = await Promise.all([
          apiCall('get_live_categories').catch(()=>[]),
          apiCall('get_vod_categories').catch(()=>[]),
          apiCall('get_series_categories').catch(()=>[])
        ])

        const live = toArray(liveData)
        const vod = toArray(vodData)
        const series = toArray(seriesData)

        setLiveCats(live)
        setVodCats(vod)
        setSeriesCats(series)

        const CACHE_KEY = 'categories_cache_v1'
        localStorage.setItem(CACHE_KEY, JSON.stringify({
          data: { live, vod, series },
          timestamp: Date.now()
        }))
        console.log('‚úÖ [Cache] Cache atualizado em background')
      }catch(err){
        console.warn('‚ö†Ô∏è [Cache] Erro ao atualizar cache em background:', err)
      }
    }

    // Pr√©-carregar conte√∫do das 3 primeiras categorias de VOD em background
    async function preloadTopVodContent(){
      console.log('üé¨ [Preload] Pr√©-carregando conte√∫do das categorias principais...')

      try{
        // Pegar as 3 primeiras categorias de VOD
        const topCategories = vodCats.slice(0, 3)

        if(topCategories.length === 0){
          console.log('‚ö†Ô∏è [Preload] Nenhuma categoria VOD dispon√≠vel ainda')
          return
        }

        console.log('üì¶ [Preload] Carregando', topCategories.length, 'categorias principais:', topCategories.map(c => c.category_name))

        // Carregar filmes de cada categoria em paralelo
        const contentPromises = topCategories.map(async (cat) => {
          try{
            const catId = getCatId(cat)
            const data = await apiCall('get_vod_streams', { category_id: catId })
            const movies = toArray(data)
            console.log(`‚úÖ [Preload] ${cat.category_name}: ${movies.length} filmes carregados`)
            return { categoryId: catId, movies }
          }catch(err){
            console.warn(`‚ö†Ô∏è [Preload] Erro ao carregar ${cat.category_name}:`, err)
            return null
          }
        })

        const results = await Promise.all(contentPromises)

        // Guardar no cache
        const CONTENT_CACHE_KEY = 'vod_content_cache_v1'
        const validResults = results.filter(r => r !== null)

        if(validResults.length > 0){
          localStorage.setItem(CONTENT_CACHE_KEY, JSON.stringify({
            data: validResults,
            timestamp: Date.now()
          }))
          console.log('üíæ [Preload] Conte√∫do das categorias principais salvo no cache')
        }

      }catch(err){
        console.error('‚ùå [Preload] Erro ao pr√©-carregar conte√∫do:', err)
      }
    }

    async function onConnect(){
      if(!cfg.server || !cfg.username || !cfg.password){ setError('Preencha Servidor/Usu√°rio/Senha.'); return }
      setCfg(v=>({ ...v, server:sanitizeServer(v.server) }))
      setAccount(null); setError('')
      setLoading(true)
      try{
        const info = await fetchAccountInfo()
        setAccount(info.user_info||info)
        setView('home')

        // Pr√©-carregar categorias em background ap√≥s login
        preloadAllCategories()
        // DESABILITADO: pr√©-carregamento de conte√∫do (causava loop infinito)
        // preloadTopVodContent()
      }catch(err){
        setError(explainLoginError(err.message||String(err)))
      }finally{
        setLoading(false)
      }
    }

    function onLogout(){ setAccount(null); setLiveCats([]); setVodCats([]); setSeriesCats([]); setItems([]); setCurrent(null); setSelectedCat(null); setSelectedLiveCat(null); setLiveStreams([]); setEpg([]); setLiveCounts({}); setLiveAllCount(0); setView('config') }

    async function openCategory(cat, type){
      setSelectedCat({ ...cat, type }); setItems([]); setQuery(''); setView('channels'); setLoading(true)
      try{
        if(type==='live'){
          const data = await apiCall('get_live_streams', { category_id: getCatId(cat) })
          setItems(toArray(data))
        }else if(type==='vod'){
          const data = await apiCall('get_vod_streams', { category_id: getCatId(cat) })
          setItems(toArray(data))
        }else{ // series -> lista de s√©ries
          const data = await apiCall('get_series', { category_id: getCatId(cat) })
          setItems(toArray(data))
        }
      }catch(err){ setError(err.message) }
      finally{ setLoading(false) }
    }

    // ===== PLAYBACK / CATCH-UP API (MOCK - SUBSTITUIR POR SUA API REAL) =====

    // Retorna os dias que t√™m grava√ß√µes dispon√≠veis para um canal
    function getRecordedDays(channelId){
      // TODO: Chamar sua API real
      // Exemplo: GET /api/recordings/days?channel_id=123
      // Por enquanto, retorna √∫ltimos 4 dias como mock (3 dias atr√°s at√© hoje)
      const days = []
      for(let offset = -3; offset <= 0; offset++){ // -3, -2, -1, 0
        const d = new Date()
        d.setDate(d.getDate() + offset) // + offset porque offset √© negativo
        d.setHours(0,0,0,0)
        days.push(d)
      }
      return days
    }

    // Constr√≥i URL de playback para um programa gravado
    function getPlaybackUrl(channelId, startUtc, endUtc){
      if(!channelId || !startUtc) {
        console.warn('‚ö†Ô∏è getPlaybackUrl: channelId ou startUtc ausente', { channelId, startUtc })
        return null
      }

      // Converter timestamps Unix para segundos se necess√°rio
      const start = typeof startUtc === 'number' ? startUtc : parseInt(startUtc)
      const end = endUtc ? (typeof endUtc === 'number' ? endUtc : parseInt(endUtc)) : start + 3600
      const durationInSeconds = end - start
      const durationInMinutes = Math.ceil(durationInSeconds / 60)

      // Converter Unix timestamp para formato YYYY-MM-DD:HH-MM
      // Exemplo: 2025-10-19:02-00
      const startDate = new Date(start * 1000)
      const year = startDate.getFullYear()
      const month = String(startDate.getMonth() + 1).padStart(2, '0')
      const day = String(startDate.getDate()).padStart(2, '0')
      const hours = String(startDate.getHours()).padStart(2, '0')
      const minutes = String(startDate.getMinutes()).padStart(2, '0')
      const dateTimeFormat = `${year}-${month}-${day}:${hours}-${minutes}`

      // URL de timeshift do Xtream Codes
      // Formato real: /timeshift/{username}/{password}/{duration_minutes}/{datetime}/{stream_id}.m3u8
      // Exemplo: http://51.161.13.89/timeshift/testetv22/Heloisa1202eqdeq/75/2025-10-19:02-00/6640.m3u8
      const url = `${cfg.server}/timeshift/${cfg.username}/${cfg.password}/${durationInMinutes}/${dateTimeFormat}/${channelId}.m3u8`

      console.log('üé¨ getPlaybackUrl:', {
        channelId,
        startUnix: start,
        startDate: startDate.toISOString(),
        dateTimeFormat,
        durationMinutes: durationInMinutes,
        url
      })
      return url
    }

    // Verifica se um programa est√° gravado/dispon√≠vel
    function isProgramRecorded(program, channel, selectedDayOffset){
      // Verificar se o canal tem tv_archive habilitado
      const hasTvArchive = channel && (channel.tv_archive === 1 || channel.tv_archive === "1")

      if(!hasTvArchive){
        return false // Canal n√£o tem playback
      }

      // Apenas programas passados ou atuais podem ser reproduzidos
      // Programas futuros n√£o t√™m grava√ß√£o ainda
      if(selectedDayOffset >= -7 && selectedDayOffset <= 0){
        console.log(`üé¨ Playback dispon√≠vel: ${program.title} (tv_archive=${channel.tv_archive}, offset=${selectedDayOffset})`)
        return true // Canal tem playback e programa est√° dispon√≠vel (√∫ltimos 7 dias)
      }

      return false // Muito antigo ou futuro
    }

    // ===== TV AO VIVO =====
    async function openLiveCategory(cat, switchLeft = true){
      try{
        setLoading(true)
        setSelectedLiveCat(cat)
        const catId = getCatId(cat)
        if(!catId){ setLiveStreams([]); setSelectedChannel(null); setEpg([]); return }
        const data = await apiCall('get_live_streams', { category_id: catId })
        const fullList = toArray(data)

        // Agrupar e pegar apenas canais √∫nicos para exibir no menu
        const uniqueList = getUniqueChannels(fullList)

        // Usar tv_archive da API Xtream Codes (1 = tem playback, 0 ou null = n√£o tem)
        const uniqueListWithPlayback = uniqueList.map(ch => ({
          ...ch,
          hasPlayback: ch.tv_archive === 1 || ch.tv_archive === "1"
        }))

        console.log(`üì∫ Canais carregados: ${uniqueListWithPlayback.length} total, ${uniqueListWithPlayback.filter(c => c.hasPlayback).length} com playback (tv_archive=1)`)

        // Debug COMPLETO: agrupar canais por valor de tv_archive
        const byArchive = {}
        uniqueListWithPlayback.forEach(ch => {
          const key = `tv_archive=${ch.tv_archive}`
          if(!byArchive[key]) byArchive[key] = []
          byArchive[key].push(ch.name)
        })

        console.log('üîç AN√ÅLISE COMPLETA DE TV_ARCHIVE:')
        Object.keys(byArchive).forEach(key => {
          console.log(`  ${key}: ${byArchive[key].length} canais`)
          console.log(`    Exemplos: ${byArchive[key].slice(0, 3).join(', ')}${byArchive[key].length > 3 ? '...' : ''}`)
        })

        // Mostrar TODOS os canais com tv_archive (para debug)
        console.log('üìã LISTA COMPLETA (todos os canais):', uniqueListWithPlayback.map(ch => ({
          name: ch.name,
          tv_archive: ch.tv_archive,
          tv_archive_duration: ch.tv_archive_duration
        })))

        setLiveStreams(uniqueListWithPlayback)

        if(uniqueListWithPlayback.length>0){
          const firstChannel = uniqueListWithPlayback[0] // Usar lista COM hasPlayback
          const baseName = firstChannel.baseName

          // Buscar √∫ltima qualidade preferida para este canal
          const preferredQuality = channelVariants[baseName]
          const variants = getVariantsForChannel(fullList, baseName)

          // Tentar encontrar a qualidade preferida, sen√£o usar o primeiro
          let channelToPlay = variants.find(v => v.quality === preferredQuality) || variants[0] || firstChannel

          // Preservar hasPlayback E tv_archive do firstChannel
          const channelWithArchive = {
            ...channelToPlay,
            baseName,
            allVariants: variants,
            hasPlayback: firstChannel.hasPlayback,
            tv_archive: firstChannel.tv_archive // Preservar tv_archive original
          }

          console.log('üì∫ Canal selecionado ao abrir categoria:', {
            name: channelWithArchive.name,
            tv_archive: channelWithArchive.tv_archive,
            hasPlayback: channelWithArchive.hasPlayback,
            stream_id: channelWithArchive.stream_id
          })

          setSelectedChannel(channelWithArchive)
          await loadEpg(channelToPlay.stream_id || channelToPlay.id, 0) // 0 = hoje ao abrir categoria
        }else{ setSelectedChannel(null); setEpg([]) }
        if(switchLeft) setLiveLeftMode('channels')
      }catch(err){ setError(err.message); setLiveStreams([]) }
      finally{ setLoading(false) }
    }

    async function loadEpg(streamId, dateOffset = 0){
      try{
        // Calcular a data alvo baseada no offset
        const targetDate = new Date()
        targetDate.setDate(targetDate.getDate() + dateOffset)
        targetDate.setHours(0, 0, 0, 0)

        console.log(`üìÖ Carregando EPG: streamId=${streamId}, offset=${dateOffset}, data=${targetDate.toISOString().split('T')[0]}`)

        // Buscar EPG usando get_simple_data_table que suporta busca por data
        // Formato da data: YYYY-MM-DD
        const dateStr = targetDate.toISOString().split('T')[0]

        let data
        if(dateOffset === 0){
          // Hoje: usar get_short_epg (mais r√°pido)
          data = await apiCall('get_short_epg', { stream_id: streamId, limit: 100 })
        } else {
          // Outros dias: usar get_simple_data_table com data espec√≠fica
          data = await apiCall('get_simple_data_table', {
            stream_id: streamId,
            type: 'live'
          })
        }

        console.log('EPG Data raw:', data)

        const list = Array.isArray(data) ? data : (data && Array.isArray(data.epg_listings) ? data.epg_listings : [])

        if(!list || list.length === 0){
          console.log('EPG vazio ou n√£o dispon√≠vel')
          setEpg([])
          return
        }

        const norm = toArray(list).map((it,idx)=>{
          console.log('EPG Item original:', it)

          // Pegar o t√≠tulo de v√°rios campos poss√≠veis
          const rawTitle = it.title || it.name || it.has_archive || ''
          const rawDesc = it.description || it.desc || ''

          // Decodificar base64 + HTML entities
          const decodedTitle = decodeEpgText(rawTitle)
          const decodedDesc = decodeEpgText(rawDesc)

          console.log('T√≠tulo original:', rawTitle, '‚Üí Decodificado:', decodedTitle)
          console.log('Timestamps:', {
            start: it.start,
            start_time: it.start_time,
            start_timestamp: it.start_timestamp,
            end: it.end,
            end_time: it.end_time,
            stop: it.stop,
            stop_timestamp: it.stop_timestamp,
            end_timestamp: it.end_timestamp
          })

          // Tentar pegar hor√°rios de v√°rios campos poss√≠veis
          const startTime = it.start || it.start_time || it.start_timestamp
          const endTime = it.end || it.end_time || it.stop_timestamp || it.end_timestamp || it.stop

          return {
            id: it.id || it.event_id || idx,
            title: decodedTitle || 'Sem programa√ß√£o dispon√≠vel',
            start: formatEPGTime(startTime),
            end: formatEPGTime(endTime),
            description: decodedDesc,
            // Preservar timestamps originais para playback
            start_timestamp: it.start_timestamp || startTime,
            stop_timestamp: it.stop_timestamp || it.end_timestamp || endTime
          }
        })

        // FILTRAR apenas programas do dia selecionado
        const filtered = norm.filter(prog => {
          if(!prog.start_timestamp) return true // Se n√£o tem timestamp, incluir

          const progDate = new Date(prog.start_timestamp * 1000)
          progDate.setHours(0, 0, 0, 0)

          const isSameDay = progDate.getTime() === targetDate.getTime()

          if(!isSameDay && dateOffset !== 0){
            console.log(`‚ùå Programa "${prog.title}" de ${progDate.toISOString().split('T')[0]} filtrado (dia alvo: ${targetDate.toISOString().split('T')[0]})`)
          }

          return dateOffset === 0 || isSameDay // Se √© hoje, pega tudo. Sen√£o, filtra por dia
        })

        console.log(`üìä EPG: Total ${norm.length} programas ‚Üí Filtrados ${filtered.length} para o dia ${targetDate.toISOString().split('T')[0]}`)

        // Ordenar EPG por hor√°rio (do mais antigo ao mais recente)
        filtered.sort((a, b) => {
          const timeA = a.start_timestamp || 0
          const timeB = b.start_timestamp || 0
          return timeA - timeB
        })

        console.log('EPG Normalizado e ordenado:', filtered)
        setEpg(filtered)
      }catch(err){
        console.error('Erro ao carregar EPG:', err)
        setEpg([])
      }
    }

    async function playStream(item){
      try{
        let url = ''
        let isHls = false
        const id = item.stream_id || item.series_id || item.id

        if(selectedCat?.type==='live'){
          url = buildURL(cfg.server, ['live', cfg.username, cfg.password, id + '.m3u8'])
          isHls = true
        }else if(selectedCat?.type==='vod'){
          const ext = (item.container_extension || 'mp4').replace(/\.+/,'')
          url = buildURL(cfg.server, ['movie', cfg.username, cfg.password, id + '.' + ext])
          isHls = /m3u8/i.test(ext)
        }else{ // s√©ries: precisamos buscar epis√≥dios primeiro
          const sInfo = await apiCallSeriesInfo(id)
          const seasons = (sInfo.episodes && typeof sInfo.episodes === 'object') ? sInfo.episodes : {}
          const firstSeason = Object.keys(seasons).sort((a,b)=>Number(a)-Number(b))[0]
          const eps = seasons[firstSeason] || []
          const ep = eps[0]
          if(!ep) throw new Error('Sem epis√≥dios dispon√≠veis para esta s√©rie')
          const epId = ep.id || ep.episode_id || ep.stream_id || id
          const ext = (ep.container_extension || 'mp4').replace(/\.+/,'')
          url = buildURL(cfg.server, ['series', cfg.username, cfg.password, epId + '.' + ext])
          isHls = /m3u8/i.test(ext)
        }
        setCurrent({ name: item.name || item.title || 'Reprodu√ß√£o', url, isHls })
        setView('player')
      }catch(err){ setError(err.message) }
    }

    const filtered = useMemo(()=>{
      const q = query.trim().toLowerCase()
      if(!q) return items
      return items.filter(it=> (it.name||it.title||'').toLowerCase().includes(q))
    }, [items, query])

    // ===== UI =====
    // TopBar removido - layout fullscreen sem barra superior
    function TopBar(){
      return null // Retorna null para ocultar completamente a barra superior
    }

    function Home(){
      const [homeFocused, setHomeFocused] = useState(0)
      const homeOptions = ['live-categories', 'netflix-movies', 'netflix-series']

      useEffect(()=>{
        if(view!=='home') return

        const handleKeyDown = (e)=>{
          if(e.key==='ArrowRight' || e.key==='ArrowDown'){
            e.preventDefault()
            setHomeFocused(prev=> Math.min(prev + 1, 2))
          }else if(e.key==='ArrowLeft' || e.key==='ArrowUp'){
            e.preventDefault()
            setHomeFocused(prev=> Math.max(prev - 1, 0))
          }else if(e.key==='Enter'){
            e.preventDefault()
            setView(homeOptions[homeFocused])
          }
        }
        window.addEventListener('keydown', handleKeyDown)
        return ()=> window.removeEventListener('keydown', handleKeyDown)
      }, [view, homeFocused])

      return e('div', { className:'star-bg min-h-screen flex flex-col items-center justify-center p-8' },
        e('div', { className:'mb-16 text-center' },
          e('h1', { className:'text-6xl font-extrabold gradient-text text-shadow mb-2' }, 'DREAMTV'),
          e('p', { className:'text-gray-400 tracking-widest' }, 'STREAMING')
        ),
        e('div', { className:'flex flex-wrap justify-center gap-12 mb-16' },
          e('div', { onClick:()=>setView('live-categories'), className:'flex flex-col items-center cursor-pointer transition-all card ' + (homeFocused===0 ? 'opacity-100 scale-110' : 'opacity-80'), role:'button', tabIndex:0 },
            e('div', { className:'w-24 h-24 rounded-full bg-gradient-to-br from-purple-500 to-blue-500 flex items-center justify-center shadow-lg transition-all ' + (homeFocused===0 ? 'shadow-purple-500/80 ring-4 ring-purple-400' : 'shadow-purple-500/50') }, e('span', { className:'text-4xl' }, 'üì∫')),
            e('span',{className:'text-white mt-3 text-sm font-medium'}, 'TV ao vivo')
          ),
          e('div', { onClick:()=>setView('netflix-movies'), className:'flex flex-col items-center cursor-pointer transition-all card ' + (homeFocused===1 ? 'opacity-100 scale-110' : 'opacity-80') },
            e('div', { className:'w-24 h-24 rounded-full bg-zinc-700/60 flex items-center justify-center transition-all ' + (homeFocused===1 ? 'ring-4 ring-purple-400 bg-zinc-600' : '') }, e('span', { className:'text-4xl' }, 'üé¨')),
            e('span',{className:'text-white mt-3 text-sm font-medium'}, 'Filmes')
          ),
          e('div', { onClick:()=>setView('netflix-series'), className:'flex flex-col items-center cursor-pointer transition-all card ' + (homeFocused===2 ? 'opacity-100 scale-110' : 'opacity-80') },
            e('div', { className:'w-24 h-24 rounded-full bg-zinc-700/60 flex items-center justify-center transition-all ' + (homeFocused===2 ? 'ring-4 ring-purple-400 bg-zinc-600' : '') }, e('span', { className:'text-4xl' }, 'üé≠')),
            e('span',{className:'text-white mt-3 text-sm font-medium'}, 'S√©ries')
          )
        ),
        e('div', { className:'text-center text-xs text-gray-400 mb-4' }, '‚Üê ‚Üí Navegar | Enter Selecionar'),
        e('div', { className:'flex flex-col md:flex-row items-center gap-3' },
          error && e('button', { onClick: ()=>{ setError(''); setDebug(null) }, className:'bg-zinc-700/70 border border-zinc-600 text-white px-6 py-3 rounded-full hover:bg-zinc-600 transition-all' }, 'üîÑ Limpar aviso'),
          !account && e('button', { onClick:()=>setView('config'), className:'bg-purple-600 text-white px-6 py-3 rounded-full hover:bg-purple-500 transition-all' }, 'Configurar')
        ),
        error && e('div', { className:'mt-6 text-red-300 text-sm' }, 'Erro: ', error, debug? e('div', {className:'hint text-gray-400 mt-1'}, 'URL: ', maskUrlCredentials(debug.url||'')) : null),
        e('div', { className:'absolute bottom-6 left-6 text-gray-400 text-xs' },
          e('div', null, 'Vers√£o: 3.1.0 (Netflix Smart TV UI)'),
          account && e('div', null, 'Usu√°rio: ' + (account.username||''))
        )
      )
    }

    function Categories(){
      const isLive = view==='live-categories'
      const [focusedCatIdx, setFocusedCatIdx] = useState(0)
      const [focusedChannelIdx, setFocusedChannelIdx] = useState(0)

      // Helper: Decodificar Base64 se necess√°rio (t√≠tulos EPG podem vir codificados)
      const decodeMaybeBase64 = (str) => {
        if(!str || typeof str !== 'string') return 'Sem t√≠tulo'

        // Se j√° parece texto normal (tem espa√ßos, acentos, letras), retorna direto
        if(/[\s\u00C0-\u00FF]/.test(str) || !/[A-Za-z0-9+/=]/.test(str)){
          return str
        }

        // ESTRAT√âGIA 1: Tentar decodificar Base64 simples
        try {
          const decoded = atob(str)
          // Verificar se √© texto v√°lido UTF-8
          if(decoded && /^[\x20-\x7E\u00C0-\u00FF]+$/.test(decoded)){
            return decoded
          }

          // ESTRAT√âGIA 2: Tentar converter bytes para UTF-8 corretamente
          try {
            const utf8Decoded = decodeURIComponent(escape(decoded))
            if(utf8Decoded && utf8Decoded.length > 0 && !/[\x00-\x1F]/.test(utf8Decoded)){
              return utf8Decoded
            }
          } catch(e2) {
            // Falhou UTF-8, tenta pr√≥xima estrat√©gia
          }

          // ESTRAT√âGIA 3: Dupla decodifica√ß√£o Base64
          try {
            const doubleDecoded = atob(decoded)
            if(doubleDecoded && /^[\x20-\x7E\u00C0-\u00FF]+$/.test(doubleDecoded)){
              return doubleDecoded
            }
          } catch(e3) {
            // Falhou dupla decodifica√ß√£o
          }

          // Se passou por atob() mas n√£o validou, retorna original
          return str

        } catch(e) {
          // N√£o √© Base64 v√°lido, retorna original
          return str
        }
      }

      // Helper: Detectar se um programa EPG est√° "NO AR AGORA"
      const isProgramCurrent = (prog) => {
        if(!prog || !prog.start || !prog.end) return false
        try {
          const now = new Date()
          const currentMinutes = now.getHours() * 60 + now.getMinutes()

          // Parse start time (formato: "HH:mm")
          const startParts = prog.start.split(':')
          const startMinutes = parseInt(startParts[0]) * 60 + parseInt(startParts[1])

          // Parse end time (formato: "HH:mm")
          const endParts = prog.end.split(':')
          const endMinutes = parseInt(endParts[0]) * 60 + parseInt(endParts[1])

          // Programa atual est√° entre start e end
          return currentMinutes >= startMinutes && currentMinutes < endMinutes
        } catch(e) {
          return false
        }
      }

      // Atalhos de teclado para navega√ß√£o em categorias e canais
      useEffect(()=>{
        if(!isLive) return

        const handleKeyDown = (e)=>{
          // Navega√ß√£o nas CATEGORIAS
          if(liveLeftMode==='categories' && liveCats.length>0){
            if(e.key==='ArrowDown'){
              e.preventDefault()
              setFocusedCatIdx(prev=> Math.min(prev + 1, liveCats.length - 1))
            }else if(e.key==='ArrowUp'){
              e.preventDefault()
              setFocusedCatIdx(prev=> Math.max(prev - 1, 0))
            }else if(e.key==='ArrowRight' || e.key==='Enter'){
              e.preventDefault()
              const cat = liveCats[focusedCatIdx]
              if(cat) openLiveCategory(cat, true)
            }else if(e.key==='ArrowLeft' || e.key==='Escape'){
              e.preventDefault()
              setView('home')
            }
          }
          // Navega√ß√£o nos CANAIS
          else if(liveLeftMode==='channels' && liveStreams.length>0){
            if(e.key==='ArrowDown'){
              e.preventDefault()
              setFocusedChannelIdx(prev=> Math.min(prev + 1, liveStreams.length - 1))
            }else if(e.key==='ArrowUp'){
              e.preventDefault()
              setFocusedChannelIdx(prev=> Math.max(prev - 1, 0))
            }else if(e.key==='Enter'){
              e.preventDefault()
              const channel = liveStreams[focusedChannelIdx]
              if(channel){
                // Carregar variantes para este canal
                const loadChannelWithVariants = async ()=>{
                  try{
                    const catId = getCatId(selectedLiveCat)
                    const data = await apiCall('get_live_streams', { category_id: catId })
                    const fullList = toArray(data)
                    const baseName = channel.baseName
                    const variants = getVariantsForChannel(fullList, baseName)

                    // Buscar qualidade preferida
                    const preferredQuality = channelVariants[baseName]
                    let channelToPlay = variants.find(v => v.quality === preferredQuality) || variants[0] || channel

                    // Preservar hasPlayback e tv_archive do canal original
                    setSelectedChannel({
                      ...channelToPlay,
                      baseName,
                      allVariants: variants,
                      hasPlayback: channel.hasPlayback,
                      tv_archive: channel.tv_archive
                    })
                    await loadEpg(channelToPlay.stream_id || channelToPlay.id, selectedDay)

                    // Abrir em tela cheia ap√≥s 500ms (dar tempo pro video carregar)
                    setTimeout(()=>{
                      const container = document.getElementById('playerContainer')
                      if(container && !document.fullscreenElement){
                        container.requestFullscreen().catch(()=>{})
                      }
                    }, 500)
                  }catch(err){
                    setSelectedChannel(channel)
                    loadEpg(channel.stream_id||channel.id, selectedDay)
                  }
                }
                loadChannelWithVariants()
              }
            }else if(e.key==='ArrowLeft'){
              e.preventDefault()
              if(focusedChannelIdx === 0){
                // Se estiver no primeiro canal, volta para categorias
                setLiveLeftMode('categories')
                setFocusedChannelIdx(0)
              }
            }else if(e.key==='Escape'){
              e.preventDefault()
              // ESC sempre volta para categorias
              setLiveLeftMode('categories')
              setFocusedChannelIdx(0)
            }
          }
        }

        window.addEventListener('keydown', handleKeyDown)
        return ()=> window.removeEventListener('keydown', handleKeyDown)
      }, [isLive, liveLeftMode, liveCats, liveStreams, focusedCatIdx, focusedChannelIdx])

      // Scroll autom√°tico para item focado
      useEffect(()=>{
        if(liveLeftMode==='categories' && liveCats.length>0){
          const cat = liveCats[focusedCatIdx]
          if(cat){
            const el = document.getElementById('cat-' + getCatId(cat))
            if(el) el.scrollIntoView({ behavior:'smooth', block:'nearest' })
          }
        }else if(liveLeftMode==='channels' && liveStreams.length>0){
          const ch = liveStreams[focusedChannelIdx]
          if(ch){
            const el = document.getElementById('channel-' + (ch.stream_id||ch.id))
            if(el) el.scrollIntoView({ behavior:'smooth', block:'nearest' })
          }
        }
      }, [focusedCatIdx, focusedChannelIdx, liveLeftMode])

      // Reset √≠ndices ao trocar modo
      useEffect(()=>{
        if(liveLeftMode==='categories') setFocusedCatIdx(0)
        else setFocusedChannelIdx(0)
      }, [liveLeftMode])

      if(isLive){
        const totalAll = liveAllCount || (liveCats||[]).reduce((acc,c)=> acc + (Number(c.total)||0), 0)
        return e('div', { className:'star-bg h-screen p-4 md:p-6 relative overflow-hidden' },
          e(TopBar),
          e('div', { className:'grid grid-cols-12 gap-4' },
            // Esquerda: categorias ou canais
            e('div', { className:'col-span-12 md:col-span-3 space-y-3' },
              e('button', {
                className:'w-full frost rounded-lg px-4 py-3 flex items-center justify-between cursor-pointer transition-all hover:border-purple-400/40',
                onClick:()=> setLiveLeftMode('categories')
              },
                e('div', {
                  className:'flex items-center gap-3 text-white font-semibold',
                  style: { pointerEvents: 'none' }
                },
                  e('span', { className:'text-xl' }, '‚ñ¶'),
                  liveLeftMode==='categories' ? 'Todos' : (selectedLiveCat?.category_name || 'Categoria')
                ),
                e('span', {
                  className:'text-gray-300 font-bold',
                  style: { pointerEvents: 'none' }
                }, String(liveLeftMode==='categories' ? totalAll : (liveStreams?.length||0)))
              ),
              error && e('div', { className:'text-red-300 text-xs' }, 'Live: ', error),
              liveLeftMode==='categories' ?
                e('div', null,
                  toArray(liveCats).map((cat, idx)=> {
                    const catId = getCatId(cat)
                    const count = (liveCounts && liveCounts[String(catId)]) ?? cat.total ?? 0
                    const isFocused = idx === focusedCatIdx
                    const isSelected = selectedLiveCat && getCatId(selectedLiveCat)===catId
                    return e('button', {
                      key:catId||cat.category_name,
                      id: 'cat-' + catId,
                      onClick:()=>{ setFocusedCatIdx(idx); openLiveCategory(cat, true) },
                      className:'w-full rounded-lg px-4 py-3 text-left frost hover:border-purple-400/40 transition-all cursor-pointer ' + (isFocused ? ' ring-2 ring-purple-400 bg-purple-500/20 text-white' : isSelected ? ' ring-2 ring-white/70 bg-white/10 text-white':' text-white/90')
                    },
                      e('div', {
                        className:'flex items-center justify-between',
                        style: { pointerEvents: 'none' } // Permite clicks em toda a √°rea do button
                      },
                        e('span', { className:'truncate font-semibold' }, cat.category_name||'Sem nome'),
                        e('span', { className:'opacity-80 ml-3' }, String(count))
                      )
                    )
                  }),
                  e('div', { className:'text-center text-xs text-gray-400 mt-3 py-2' }, '‚Üë‚Üì Navegar | ‚Üí Enter Abrir | ‚Üê ESC Voltar')
                )
              :
                e('div', null,
                  toArray(liveStreams).map((item, idx)=> {
                    const key = item.stream_id || item.id || item.name
                    const isFocused = idx === focusedChannelIdx
                    const isSel = (selectedChannel && ((selectedChannel.stream_id||selectedChannel.id)===(item.stream_id||item.id)))

                    const handleChannelClick = async ()=>{
                      setFocusedChannelIdx(idx)

                      // Carregar variantes
                      try{
                        const catId = getCatId(selectedLiveCat)
                        const data = await apiCall('get_live_streams', { category_id: catId })
                        const fullList = toArray(data)
                        const baseName = item.baseName
                        const variants = getVariantsForChannel(fullList, baseName)
                        const preferredQuality = channelVariants[baseName]
                        let channelToPlay = variants.find(v => v.quality === preferredQuality) || variants[0] || item

                        // Preservar hasPlayback E tv_archive do item original
                        const channelWithArchive = {
                          ...channelToPlay,
                          baseName,
                          allVariants: variants,
                          hasPlayback: item.hasPlayback,
                          tv_archive: item.tv_archive
                        }

                        console.log('üì∫ Canal selecionado ao clicar:', {
                          name: channelWithArchive.name,
                          tv_archive: channelWithArchive.tv_archive,
                          hasPlayback: channelWithArchive.hasPlayback,
                          stream_id: channelWithArchive.stream_id
                        })

                        setSelectedChannel(channelWithArchive)
                        await loadEpg(channelToPlay.stream_id || channelToPlay.id, selectedDay)
                      }catch(err){
                        setSelectedChannel(item)
                        loadEpg(item.stream_id||item.id, selectedDay)
                      }
                    }

                    const handleChannelDoubleClick = ()=>{
                      // Abrir em tela cheia
                      setTimeout(()=>{
                        const container = document.getElementById('playerContainer')
                        if(container && !document.fullscreenElement){
                          container.requestFullscreen().catch(()=>{})
                        }
                      }, 300)
                    }

                    return e('button', {
                      key,
                      id: 'channel-' + (item.stream_id||item.id),
                      onClick: handleChannelClick,
                      onDoubleClick: handleChannelDoubleClick,
                      className:'w-full rounded-lg px-3 py-3 text-left frost hover:border-purple-400/40 transition-all ' + (isFocused ? ' ring-2 ring-purple-400 bg-purple-500/20 text-white' : isSel ? ' ring-2 ring-white/70 bg-white/10 text-white':' text-white/90')
                    },
                      e('div', { className:'flex items-center gap-3' },
                        // ID removido - mostrar apenas logo e nome
                        item.stream_icon ? e('img', { src:item.stream_icon, className:'w-8 h-8 object-contain rounded', alt:'' }) : e('div', { className:'w-8 h-8 rounded bg-zinc-600 grid place-items-center text-xs' }, 'TV'),
                        e('div', { className:'flex-1 truncate font-semibold' }, item.baseName || item.name || 'Sem t√≠tulo'),
                        // Badge REC vermelho se canal tem playback
                        item.hasPlayback && e('div', {
                          className: 'px-2 py-[2px] rounded text-[11px] font-bold',
                          style: { backgroundColor: '#DC2626', color: '#FFFFFF' }
                        }, 'REC')
                        // Badge HD verde removida
                      )
                    )
                  }),
                  e('div', { className:'text-center text-xs text-gray-400 mt-3 py-2' }, '‚Üë‚Üì Navegar | Enter Tela Cheia | 2√ó Clique Tela Cheia | ‚Üê ESC Voltar')
                )
            ),
            // Centro: player + info + EPG
            e('div', { className:'col-span-12 md:col-span-6 space-y-3' },
              e('div', { className:'relative rounded-lg overflow-hidden bg-black aspect-video frost' },
                e(LiveVideo, { channel:selectedChannel, epg:epg, onDbl:()=>toggleFullscreen('#liveVideo'), type: 'live' })
              ),
              e('div', { className:'space-y-2 max-h-[500px] overflow-y-auto scrollbar-hide pr-2' },
                (epg && epg.length>0 ? epg : Array.from({length:4}).map((_,i)=>({ id:'empty'+i, title:'Programa n√£o encontrado', start:'--:--', end:'--:--' }))).map((pg,i)=>{
                  // Determinar se √© passado, atual ou futuro usando TIMESTAMPS (mais preciso)
                  const now = new Date()
                  const startTime = pg.start_timestamp ? new Date(pg.start_timestamp * 1000) : null
                  const endTime = pg.stop_timestamp ? new Date(pg.stop_timestamp * 1000) : null

                  let isCurrent = false
                  let isPast = false
                  let isFuture = false

                  if (startTime && endTime) {
                    // Verificar se programa est√° AO VIVO AGORA
                    if (now >= startTime && now < endTime) {
                      isCurrent = true
                    } else if (now >= endTime) {
                      isPast = true
                    } else if (now < startTime) {
                      isFuture = true
                    }
                  } else {
                    // Fallback: usar fun√ß√£o antiga baseada em HH:mm
                    isCurrent = isProgramCurrent(pg)
                    if (!isCurrent) {
                      isPast = false
                      isFuture = true
                    }
                  }

                  const isRecorded = isProgramRecorded(pg, selectedChannel, selectedDay)

                  // Formatar hor√°rios usando formatEPGTime
                  const startFormatted = formatEPGTime(pg.start_timestamp || pg.start)
                  const endFormatted = formatEPGTime(pg.stop_timestamp || pg.end)

                  // Decodificar t√≠tulo (Base64 se necess√°rio)
                  const programTitle = decodeMaybeBase64(pg.title) || 'Programa n√£o encontrado'

                  // Debug: detectar t√≠tulos curtos/suspeitos
                  if(programTitle.length <= 3 && programTitle !== pg.title){
                    console.log('‚ö†Ô∏è T√≠tulo suspeito:', {
                      original: pg.title,
                      decodificado: programTitle,
                      horario: `${startFormatted} - ${endFormatted}`
                    })
                  }

                  // 3 ESTADOS VISUAIS:
                  // 1. ATUAL (ao vivo agora) ‚Üí texto VERDE + bolinha verde preenchida
                  // 2. PASSADO ‚Üí texto cinza claro + bolinha branca vazia
                  // 3. FUTURO ‚Üí texto cinza escuro + bolinha branca vazia

                  let textColor, dotStyle, isClickable, cursorClass, borderColor

                  // Debug: Logar programa atual detectado
                  if(isCurrent && i === 0){
                    console.log('üü¢ Programa AO VIVO:', pg.title, `${startFormatted} - ${endFormatted}`)
                  }

                  if(isCurrent){
                    // ATUAL - AO VIVO AGORA (VERDE BRILHANTE)
                    textColor = 'text-green-400'
                    dotStyle = 'bg-green-400' // Bolinha verde preenchida e brilhante
                    borderColor = 'border-green-400/40'
                    isClickable = isRecorded
                    cursorClass = isRecorded ? 'cursor-pointer hover:bg-green-400/10' : 'cursor-default'
                  } else if(isPast){
                    // PASSADO
                    textColor = 'text-slate-400'
                    dotStyle = 'border-2 border-slate-400' // Bolinha vazia
                    borderColor = 'border-slate-700'
                    isClickable = isRecorded
                    cursorClass = isRecorded ? 'cursor-pointer hover:bg-white/5' : 'cursor-default'
                  } else {
                    // FUTURO
                    textColor = 'text-slate-500'
                    dotStyle = 'border-2 border-slate-500' // Bolinha vazia
                    borderColor = 'border-slate-700'
                    isClickable = false
                    cursorClass = 'cursor-default'
                  }

                  const handleClick = ()=>{
                    console.log('üñ±Ô∏è Clique no EPG:', {
                      programa: pg.title,
                      isClickable,
                      isRecorded,
                      canal_tv_archive: selectedChannel?.tv_archive,
                      canal_hasPlayback: selectedChannel?.hasPlayback
                    })

                    if(!isClickable) {
                      console.warn('‚ö†Ô∏è Programa n√£o √© clic√°vel (tv_archive n√£o habilitado ou programa futuro)')
                      return
                    }

                    // Abrir playback do programa gravado
                    const channelId = selectedChannel?.stream_id || selectedChannel?.id
                    const startUtc = pg.start_timestamp || pg.start
                    const endUtc = pg.stop_timestamp || pg.end
                    const url = getPlaybackUrl(channelId, startUtc, endUtc)

                    if(url){
                      console.log('üé¨ Iniciando playback:', {
                        programa: pg.title,
                        horario: `${pg.start} - ${pg.end}`,
                        channelId,
                        startUtc,
                        endUtc,
                        url
                      })

                      // Iniciar playback no player
                      setCurrent({
                        name: `${selectedChannel?.name || 'Canal'} - ${pg.title}`,
                        url: url,
                        isHls: true,
                        num: selectedChannel?.num,
                        stream_icon: selectedChannel?.stream_icon,
                        stream_id: selectedChannel?.stream_id,
                        playback_mode: true,
                        playback_program: pg.title
                      })

                      // Mudar para tela do player
                      setView('player')

                      console.log('‚úÖ Player iniciado em modo playback')
                    } else {
                      console.log('‚ö†Ô∏è Playback n√£o dispon√≠vel para este programa')
                    }
                  }

                  return e('div', {
                    key:pg.id||i,
                    onClick: handleClick,
                    className:`px-3 py-3 flex items-center gap-3 transition-colors ${cursorClass} rounded-lg frost ${isCurrent ? 'border-emerald-400/40' : 'hover:border-purple-400/40'}`
                  },
                    // Bolinha indicadora (sempre vis√≠vel)
                    e('span', {
                      className:`w-2.5 h-2.5 rounded-full flex-shrink-0 ${dotStyle}`
                    }),
                    // Hor√°rio √† esquerda
                    e('span', { className:`text-sm font-medium whitespace-nowrap ${textColor}` },
                      `${startFormatted} - ${endFormatted}`
                    ),
                    // Nome do programa alinhado √† DIREITA
                    e('span', {
                      className:`text-sm ${isCurrent ? 'font-semibold' : 'font-normal'} ${textColor} ml-auto text-right`,
                      style: { maxWidth: '60%' }
                    },
                      programTitle
                    )
                  )
                })
              )
            ),
            // Direita: hora atual + trilho de dias (pixel-perfect)
            e('div', { className:'col-span-12 md:col-span-3 space-y-3' },
              // Hora atual no topo (como no print)
              e('div', { className:'text-right text-white/80 text-lg font-semibold px-2' },
                new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
              ),
              // Trilho de dias
              (()=>{
                const channelId = selectedChannel?.stream_id || selectedChannel?.id
                const hasPlayback = selectedChannel?.hasPlayback || false

                // Mostrar 7 dias: 3 antes + HOJE + 3 depois (para playback e EPG)
                // Exemplo: dia 11 hoje ‚Üí mostra dias 08, 09, 10, [11], 12, 13, 14
                const dayOffsets = [-3, -2, -1, 0, 1, 2, 3]

                const diasInfo = dayOffsets.map(off => `${dayNum(off)} ${dayWeek(off)}`).join(', ')
                const channelName = selectedChannel?.name || selectedChannel?.baseName || 'Sem canal'
                console.log(`üìÖ Trilho de dias: "${channelName}" hasPlayback=${hasPlayback} | Dias: [${diasInfo}]`)

                return dayOffsets.map((offset)=> {
                  const isSelected = selectedDay === offset

                  // Verificar se o dia tem grava√ß√µes dispon√≠veis
                  const recordedDays = channelId ? getRecordedDays(channelId) : []
                  const targetDate = new Date()
                  targetDate.setDate(targetDate.getDate() + offset) // + offset porque dayNum() usa soma
                  targetDate.setHours(0,0,0,0)

                  const isAvailable = hasPlayback ? recordedDays.some(d => {
                    const rd = new Date(d)
                    rd.setHours(0,0,0,0)
                    return rd.getTime() === targetDate.getTime()
                  }) : true // Sem playback = sempre dispon√≠vel (EPG futuro)

                  const handleDayClick = ()=>{
                    if(hasPlayback && !isAvailable) return // Playback: s√≥ clica se dispon√≠vel

                    setSelectedDay(offset)
                    setSelectedEpgId(null) // Limpar sele√ß√£o EPG ao trocar dia
                    console.log('Dia selecionado:', offset, 'Date:', targetDate.toISOString().split('T')[0])

                    // Recarregar EPG do canal para o dia selecionado
                    if(channelId){
                      loadEpg(channelId, offset) // Passa o offset do dia selecionado
                    }
                  }

                  return e('div', {
                    key:offset,
                    onClick: handleDayClick,
                    className:`rounded-xl px-6 py-6 text-center transition-all ${
                      hasPlayback && !isAvailable ? 'opacity-40 pointer-events-none cursor-not-allowed' :
                      isSelected ? 'bg-violet-600/90 ring-2 ring-white/20 cursor-pointer' : // ROXO pixel-perfect
                      'frost cursor-pointer hover:bg-white/5'
                    }`,
                    style: isSelected ? { transform: 'scale(1.02)' } : {},
                    title: hasPlayback && !isAvailable ? 'Sem grava√ß√µes dispon√≠veis' : ''
                  },
                    e('div', { className:`text-3xl font-bold ${isSelected ? 'text-white' : 'text-white/90'}` }, dayNum(offset)),
                    e('div', { className:`text-sm ${isSelected ? 'opacity-100 font-semibold' : 'opacity-80'} text-white` }, dayWeek(offset))
                  )
                })
              })()
            )
          )
        )
      }

      // Filmes/S√©ries gen√©ricos
      let cats = view==='movie-categories'? vodCats : seriesCats
      let title = view==='movie-categories'? 'Filmes ‚Äî Categorias' : 'S√©ries ‚Äî Categorias'
      let type = view==='movie-categories'? 'vod' : 'series'

      // Filtrar categorias de Filmes - remover shows, internacional, nacional
      if(view==='movie-categories'){
        cats = vodCats.filter(cat => {
          const name = (cat.category_name || '').toLowerCase()
          return !name.includes('show') && !name.includes('internacional') && !name.includes('nacional')
        })
      }

      // Filtrar categorias de S√©ries - remover novelas, crunchyroll, desenho
      if(view==='series-categories'){
        cats = seriesCats.filter(cat => {
          const name = (cat.category_name || '').toLowerCase()
          return !name.includes('novela') && !name.includes('crunchyroll') && !name.includes('desenho')
        })
      }

      // Filtrar apenas novelas se estiver na view de novelas
      if(view==='novelas-categories'){
        cats = seriesCats.filter(cat => {
          const name = (cat.category_name || '').toLowerCase()
          return name.includes('novela')
        })
        title = 'Novelas ‚Äî Categorias'
        type = 'series'
      }

      // Filtrar apenas animes (crunchyroll) se estiver na view de animes
      if(view==='animes-categories'){
        cats = seriesCats.filter(cat => {
          const name = (cat.category_name || '').toLowerCase()
          return name.includes('crunchyroll')
        })
        title = 'Animes ‚Äî Categorias'
        type = 'series'
      }

      // Filtrar apenas desenhos se estiver na view de desenhos
      if(view==='desenhos-categories'){
        cats = seriesCats.filter(cat => {
          const name = (cat.category_name || '').toLowerCase()
          return name.includes('desenho')
        })
        title = 'Desenhos ‚Äî Categorias'
        type = 'series'
      }

      // Filtrar apenas shows (internacional/nacional) se estiver na view de shows
      if(view==='show-categories'){
        cats = vodCats.filter(cat => {
          const name = (cat.category_name || '').toLowerCase()
          return name.includes('show') || name.includes('internacional') || name.includes('nacional')
        })
        title = 'Show ‚Äî Categorias'
        type = 'vod'
      }

      const [focusedIdx, setFocusedIdx] = useState(0)

      // Navega√ß√£o por teclado em Filmes/S√©ries/Novelas/Animes/Desenhos/Show
      useEffect(()=>{
        const isMovieOrSeries = (view==='movie-categories' || view==='series-categories' || view==='novelas-categories' || view==='animes-categories' || view==='desenhos-categories' || view==='show-categories')
        if(!isMovieOrSeries || !cats || cats.length===0) return

        const handleKeyDown = (e)=>{
          if(e.key==='ArrowDown'){
            e.preventDefault()
            setFocusedIdx(prev=> Math.min(prev + 1, cats.length - 1))
          }else if(e.key==='ArrowUp'){
            e.preventDefault()
            setFocusedIdx(prev=> Math.max(prev - 1, 0))
          }else if(e.key==='ArrowRight' || e.key==='Enter'){
            e.preventDefault()
            const cat = cats[focusedIdx]
            if(cat) openCategory(cat, type)
          }else if(e.key==='ArrowLeft' || e.key==='Escape'){
            e.preventDefault()
            setView('home')
          }
        }

        window.addEventListener('keydown', handleKeyDown)
        return ()=> window.removeEventListener('keydown', handleKeyDown)
      }, [view, cats, focusedIdx, type])

      // Scroll autom√°tico
      useEffect(()=>{
        if((view==='movie-categories' || view==='series-categories' || view==='novelas-categories' || view==='animes-categories' || view==='desenhos-categories' || view==='show-categories') && cats && cats.length>0){
          const cat = cats[focusedIdx]
          if(cat){
            const el = document.getElementById('vod-cat-' + getCatId(cat))
            if(el) el.scrollIntoView({ behavior:'smooth', block:'nearest' })
          }
        }
      }, [focusedIdx, view, cats])

      return e('div', { className:'star-bg h-screen p-6 overflow-hidden' },
        e(TopBar),
        e('div', { className:'flex items-center gap-3 mb-4' },
          e('button', { onClick:()=>setView('home'), className:'text-white text-xl hover:text-purple-400' }, '‚Üê'),
          e('h2', { className:'text-white text-2xl font-bold' }, title)
        ),
        cats && cats.length>0 ? e('div', { className:'grid grid-cols-1 gap-3 max-w-2xl' },
          toArray(cats).map((cat, idx)=> {
            const isFocused = idx === focusedIdx
            return e('button', {
              key:getCatId(cat)||cat.category_name,
              id: 'vod-cat-' + getCatId(cat),
              onClick:()=>{ setFocusedIdx(idx); openCategory(cat, type) },
              className:'frost rounded-lg p-4 flex items-center justify-between text-left text-white hover:border-purple-400/50 transition-all ' + (isFocused ? ' ring-2 ring-purple-400 bg-purple-500/20' : '')
            },
              e('div', { className:'flex items-center gap-4' },
                e('div', { className:'w-12 h-12 bg-zinc-700 rounded-lg grid place-items-center' }, e('span', { className:'text-2xl' }, 'üìÅ')),
                e('span', { className:'text-lg font-medium truncate' }, cat.category_name || 'Sem nome')
              ),
              e('span', { className:'text-gray-300 text-lg font-bold' }, String(cat.total || 0))
            )
          }),
          e('div', { className:'text-center text-xs text-gray-400 mt-3 py-2' }, '‚Üë‚Üì Navegar | ‚Üí Enter Abrir | ‚Üê ESC Voltar')
        ) : e('div', { className:'text-center text-gray-400 mt-12 flex flex-col items-center gap-4' },
          'Sem categorias',
          error ? e('div', { className:'text-red-300 text-sm' }, 'Erro: ', error, debug? e('div', {className:'hint text-gray-400 mt-1'}, 'URL: ', maskUrlCredentials(debug.url||'')) : null) : null
        )
      )
    }

    function LiveVideo({ channel, epg, onDbl, type = 'live' }){
      const vref = useRef(null)
      const hlsRef = useRef(null)
      const [showOverlay, setShowOverlay] = useState(true)
      const [currentTime, setCurrentTime] = useState('')
      const [selectedQuality, setSelectedQuality] = useState(null)
      const currentQualityRef = useRef(null) // Ref para n√£o causar re-render ao trocar qualidade
      const [isFullscreen, setIsFullscreen] = useState(false)
      const [videoResolution, setVideoResolution] = useState('1920√ó1080')
      const hideTimeoutRef = useRef(null)
      const [availableQualities, setAvailableQualities] = useState([])

      // ========== FUN√á√ïES HELPER ==========

      // Formatar t√≠tulo da p√≠lula evitando redund√¢ncia (ex: "GLOBO SP HD HD" -> "GLOBO SP HD")
      const formatPillTitle = (name, activeQuality) => {
        if(!name) return 'CANAL'
        const nameUpper = name.toUpperCase()
        // Se o nome j√° termina com o sufixo de qualidade, n√£o repetir
        if(activeQuality && nameUpper.endsWith(activeQuality.toUpperCase())){
          return nameUpper
        }
        return activeQuality ? `${nameUpper} ${activeQuality.toUpperCase()}` : nameUpper
      }

      // Decodificar Base64 se necess√°rio (t√≠tulos EPG podem vir codificados)
      const decodeMaybeBase64 = (str) => {
        if(!str || typeof str !== 'string') return 'Sem t√≠tulo'

        // Se j√° parece texto normal (tem espa√ßos, acentos, letras), retorna direto
        if(/[\s\u00C0-\u00FF]/.test(str) || !/[A-Za-z0-9+/=]/.test(str)){
          return str
        }

        // Tentar decodificar Base64
        try {
          const decoded = atob(str)

          // Verificar se √© texto v√°lido ASCII/UTF-8 simples
          if(decoded && /^[\x20-\x7E]+$/.test(decoded)){
            // Texto ASCII puro (como "SP2") - retorna direto
            return decoded
          }

          // Se tem caracteres UTF-8 especiais, tentar converter
          if(decoded && /[\u00C0-\u00FF]/.test(decoded)){
            try {
              const utf8Decoded = decodeURIComponent(escape(decoded))
              if(utf8Decoded && utf8Decoded.length > 0 && !/[\x00-\x1F]/.test(utf8Decoded)){
                return utf8Decoded
              }
            } catch(e2) {
              // Falhou convers√£o UTF-8, retorna decoded simples
              return decoded
            }
          }

          // Se decodificou mas n√£o √© texto v√°lido, retorna original
          return str

        } catch(e) {
          // N√£o √© Base64 v√°lido, retorna original
          return str
        }
      }

      // ========== FIM FUN√á√ïES HELPER ==========

      // Definir qualidade inicial com base no canal
      useEffect(()=>{
        if(channel && channel.quality){
          setSelectedQuality(channel.quality)
        }
      }, [channel?.stream_id, channel?.id])

      // Detectar variantes dispon√≠veis
      useEffect(()=>{
        if(!channel || !channel.allVariants) return
        const qualities = channel.allVariants.map(v => v.quality).filter(Boolean)
        setAvailableQualities(qualities.length > 0 ? qualities : ['Original'])
      }, [channel?.allVariants])

      useEffect(()=>{
        const v = vref.current
        if(!v) return

        // Cleanup anterior
        if(hlsRef.current){
          try{ hlsRef.current.destroy() }catch{}
          hlsRef.current = null
        }

        if(!channel){ v.removeAttribute('src'); v.load(); return }

        // Usar playback_url se dispon√≠vel (modo playback de programa gravado)
        const url = channel.playback_url || buildURL(cfg.server, ['live', cfg.username, cfg.password, (channel.stream_id||channel.id)+'.m3u8'])
        const canNative = v.canPlayType('application/vnd.apple.mpegURL')

        if(window.Hls && window.Hls.isSupported() && !canNative){
          const h = new Hls({ maxBufferLength:30 })
          hlsRef.current = h
          h.loadSource(url)
          h.attachMedia(v)
          h.on(window.Hls.Events.MANIFEST_PARSED, ()=>{
            const level = h.levels[h.currentLevel]
            if(level) setVideoResolution(`${level.width}√ó${level.height}`)
          })
          h.on(window.Hls.Events.ERROR, (event, data)=>{
            if(data.fatal){
              // Fallback autom√°tico para pr√≥xima qualidade
              handleQualityFallback()
            }
          })
        }else{ v.src = url }
        v.play().catch(()=>{})

        return ()=>{
          if(hlsRef.current){
            try{ hlsRef.current.destroy() }catch{}
            hlsRef.current = null
          }
        }
      }, [channel?.stream_id, channel?.id, channel?.playback_url])

      const handleQualityFallback = ()=>{
        if(!channel || !channel.allVariants) return
        const currentIdx = channel.allVariants.findIndex(v => v.quality === selectedQuality)
        if(currentIdx === -1) return

        // Tentar pr√≥xima qualidade
        const nextVariant = channel.allVariants[currentIdx + 1] || channel.allVariants[0]
        if(nextVariant && nextVariant.quality !== selectedQuality){
          showToast(`Falha na qualidade ${selectedQuality}. Mudando para ${nextVariant.quality}...`)
          switchQuality(nextVariant.quality)
        }
      }

      const switchQuality = (quality)=>{
        if(!channel || !channel.allVariants) return

        const variant = channel.allVariants.find(v => v.quality === quality)
        if(!variant) return

        // Salvar prefer√™ncia DIRETO no localStorage (sem state para n√£o causar re-render do pai)
        if(channel.baseName){
          try{
            const current = JSON.parse(localStorage.getItem('channel_quality_prefs') || '{}')
            current[channel.baseName] = quality
            localStorage.setItem('channel_quality_prefs', JSON.stringify(current))
          }catch{}
        }

        // Trocar a URL diretamente no HLS sem recriar o player (mant√©m fullscreen)
        const v = vref.current
        if(!v) return

        const url = buildURL(cfg.server, ['live', cfg.username, cfg.password, (variant.stream_id||variant.id)+'.m3u8'])

        if(hlsRef.current){
          // Se j√° tem HLS rodando, apenas trocar a source
          hlsRef.current.loadSource(url)
        }else{
          // Se for nativo, trocar o src
          v.src = url
          v.play().catch(()=>{})
        }

        // Atualizar qualidade na ref (n√£o causa re-render, mant√©m fullscreen)
        currentQualityRef.current = quality

        // For√ßar re-render apenas dos bot√µes (sem reconstruir o player container)
        setTimeout(()=> setSelectedQuality(quality), 100)
      }

      const showToast = (message)=>{
        setToast(message)
        setTimeout(()=> setToast(null), 3000)
      }

      // Atualizar hor√°rio atual
      useEffect(()=>{
        const updateTime = ()=>{
          const now = new Date()
          setCurrentTime(`${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`)
        }
        updateTime()
        const interval = setInterval(updateTime, 1000)
        return ()=> clearInterval(interval)
      }, [])

      // Auto-hide overlay
      const resetHideTimer = ()=>{
        setShowOverlay(true)
        if(hideTimeoutRef.current) clearTimeout(hideTimeoutRef.current)
        hideTimeoutRef.current = setTimeout(()=> setShowOverlay(false), 5000)
      }

      useEffect(()=>{
        resetHideTimer()
        return ()=> {
          if(hideTimeoutRef.current) clearTimeout(hideTimeoutRef.current)
        }
      }, [])

      // Detectar fullscreen
      useEffect(()=>{
        const handleFullscreen = ()=>{
          const isFS = !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
          )
          setIsFullscreen(isFS)
        }

        document.addEventListener('fullscreenchange', handleFullscreen)
        document.addEventListener('webkitfullscreenchange', handleFullscreen)
        document.addEventListener('mozfullscreenchange', handleFullscreen)
        document.addEventListener('MSFullscreenChange', handleFullscreen)

        return ()=> {
          document.removeEventListener('fullscreenchange', handleFullscreen)
          document.removeEventListener('webkitfullscreenchange', handleFullscreen)
          document.removeEventListener('mozfullscreenchange', handleFullscreen)
          document.removeEventListener('MSFullscreenChange', handleFullscreen)
        }
      }, [])
      

      // Navega√ß√£o por teclado: atalhos do HUD
      useEffect(()=>{
        if(!channel) return

        const handleKey = (e)=>{
          if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return

          // Enter/OK: toggle HUD ou fullscreen se n√£o estiver em fullscreen
          if(e.key === 'Enter'){
            e.preventDefault()
            e.stopPropagation()
            if(isFullscreen){
              setShowOverlay(prev => !prev)
            } else {
              toggleFullscreen()
            }
          }

          // F: fullscreen
          if(e.key === 'f' || e.key === 'F'){
            e.preventDefault()
            e.stopPropagation()
            toggleFullscreen()
          }

          // Q: focar qualidade (mostrar overlay)
          if(e.key === 'q' || e.key === 'Q'){
            e.preventDefault()
            e.stopPropagation()
            if(isFullscreen){
              setShowOverlay(true)
            }
          }

          // ESC/Back: fechar HUD ou sair do fullscreen
          if(e.key === 'Escape'){
            e.preventDefault()
            e.stopPropagation()
            if(showOverlay && isFullscreen){
              setShowOverlay(false)
            } else {
              const isFS = !!(
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
              )
              if(isFS){
                toggleFullscreen()
              }
            }
          }

          // ‚Üê / ‚Üí: navega√ß√£o entre canais (placeholder)
          if(e.key === 'ArrowLeft'){
            e.preventDefault()
            console.log('Previous channel')
          }
          if(e.key === 'ArrowRight'){
            e.preventDefault()
            console.log('Next channel')
          }
        }

        const container = document.getElementById('playerContainer')
        if(container){
          container.addEventListener('keydown', handleKey)
          return ()=> container.removeEventListener('keydown', handleKey)
        }
      }, [channel, isFullscreen, showOverlay])

      // Auto-hide do overlay ap√≥s 4s de inatividade (APENAS EM LIVE, N√ÉO EM VOD)
      useEffect(()=>{
        if(!isFullscreen || !showOverlay || type === 'vod') return

        // Limpar timeout anterior
        if(hideTimeoutRef.current){
          clearTimeout(hideTimeoutRef.current)
        }

        // Configurar novo timeout para esconder ap√≥s 4s
        hideTimeoutRef.current = setTimeout(()=>{
          setShowOverlay(false)
        }, 4000)

        // Fun√ß√£o para reexibir overlay ao mover mouse/tecla
        const handleActivity = ()=>{
          setShowOverlay(true)
          if(hideTimeoutRef.current){
            clearTimeout(hideTimeoutRef.current)
          }
          hideTimeoutRef.current = setTimeout(()=>{
            setShowOverlay(false)
          }, 4000)
        }

        document.addEventListener('mousemove', handleActivity)
        document.addEventListener('keydown', handleActivity)

        return ()=>{
          if(hideTimeoutRef.current){
            clearTimeout(hideTimeoutRef.current)
          }
          document.removeEventListener('mousemove', handleActivity)
          document.removeEventListener('keydown', handleActivity)
        }
      }, [isFullscreen, showOverlay, type])

      const toggleFullscreen = ()=>{
        const viewport = document.querySelector('.player-viewport')
        if(!viewport) return

        const isCurrentlyFullscreen = !!(
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
        )

        if(isCurrentlyFullscreen){
          // Sair do fullscreen
          if(document.exitFullscreen){
            document.exitFullscreen().catch(()=>{})
          }else if(document.webkitExitFullscreen){
            document.webkitExitFullscreen()
          }else if(document.mozCancelFullScreen){
            document.mozCancelFullScreen()
          }else if(document.msExitFullscreen){
            document.msExitFullscreen()
          }
        }else{
          // Entrar em fullscreen no viewport
          if(viewport.requestFullscreen){
            viewport.requestFullscreen().catch(()=>{})
          }else if(viewport.webkitRequestFullscreen){
            viewport.webkitRequestFullscreen()
          }else if(viewport.mozRequestFullScreen){
            viewport.mozRequestFullScreen()
          }else if(viewport.msRequestFullscreen){
            viewport.msRequestFullscreen()
          }
        }
      }

      // Calcular progresso do programa
      const getCurrentProgram = ()=>{
        if(!epg || epg.length === 0){
          console.log('EPG vazio, sem programa atual')
          return null
        }

        const now = new Date()
        const currentHour = now.getHours()
        const currentMin = now.getMinutes()
        const currentTimeNum = currentHour * 60 + currentMin

        console.log('Hora atual:', `${String(currentHour).padStart(2,'0')}:${String(currentMin).padStart(2,'0')}`, '(' + currentTimeNum + ' min)')
        console.log('EPG dispon√≠vel:', epg.length, 'programas')

        // Procurar programa atual
        for(let i = 0; i < epg.length; i++){
          const prog = epg[i]
          const startParts = (prog.start || '00:00').split(':')
          const endParts = (prog.end || '23:59').split(':')

          const startH = parseInt(startParts[0]) || 0
          const startM = parseInt(startParts[1]) || 0
          const endH = parseInt(endParts[0]) || 23
          const endM = parseInt(endParts[1]) || 59

          const startNum = startH * 60 + startM
          const endNum = endH * 60 + endM

          console.log(`Programa ${i}: "${prog.title}" - ${prog.start} a ${prog.end} (${startNum}-${endNum} min)`)

          if(currentTimeNum >= startNum && currentTimeNum < endNum){
            const progress = ((currentTimeNum - startNum) / (endNum - startNum)) * 100
            console.log('‚úì Programa atual encontrado:', prog.title, 'Progresso:', progress.toFixed(1) + '%')
            return { ...prog, progress }
          }
        }

        console.log('Nenhum programa no hor√°rio atual, usando primeiro da lista')
        return epg[0] ? { ...epg[0], progress: 0 } : null
      }

      const currentProg = getCurrentProgram()

      // Pr√≥ximo programa: encontrar o que vem depois do atual
      let nextProg = null
      if(currentProg && epg && epg.length > 0){
        const currentIdx = epg.findIndex(p => p.id === currentProg.id)
        if(currentIdx !== -1 && currentIdx + 1 < epg.length){
          nextProg = epg[currentIdx + 1]
        }
      }

      console.log('Programa atual:', currentProg?.title)
      console.log('Pr√≥ximo programa:', nextProg?.title)
      console.log('showOverlay:', showOverlay)
      console.log('channel:', channel)

      return e('div', {
        key: 'player-container-stable',
        id: 'playerContainer',
        tabIndex: 0,
        style: {
          position: isFullscreen ? 'fixed' : 'relative',
          top: isFullscreen ? 0 : 'auto',
          left: isFullscreen ? 0 : 'auto',
          width: isFullscreen ? '100vw' : '100%',
          height: isFullscreen ? '100vh' : '100%',
          margin: 0,
          padding: 0,
          overflow: 'hidden',
          backgroundColor: '#000',
          outline: 'none',
          zIndex: isFullscreen ? 99999 : 'auto'
        },
        onMouseMove: resetHideTimer,
        onClick: (e)=> {
          resetHideTimer()
          e.currentTarget.focus()
        },
        onDoubleClick: (e)=> {
          e.preventDefault()
          e.stopPropagation()
          toggleFullscreen()
        }
      },
        // Viewport wrapper - centraliza o v√≠deo perfeitamente
        e('div', {
          className: 'player-viewport',
          tabIndex: -1,
          style: { position: 'absolute', inset: 0 },
          onDoubleClick: (e)=> {
            e.preventDefault()
            e.stopPropagation()
            toggleFullscreen()
          }
        },
          e('video', {
            id:'liveVideo',
            autoPlay:true,
            ref:vref,
            controls:false,
            playsInline:true,
            muted:false,
            onDoubleClick: toggleFullscreen,
            style: isFullscreen ? {
              width: '100%',
              height: '100%',
              objectFit: 'cover',
              objectPosition: 'center',
              position: 'absolute',
              top: 0,
              left: 0,
              transform: 'none',
              margin: 0,
              padding: 0
            } : {
              width: '67%',
              height: '79%',
              objectFit: 'fill',
              objectPosition: 'center',
              position: 'relative',
              top: '-12%',
              left: '-10.5%',
              transform: 'scale(0.70)',
              transformOrigin: 'center',
              margin: 0,
              padding: 0
            }
          }),

          // OVERLAY PIXEL PERFECT - LAYOUT ID√äNTICO AO ALVO (apenas em LIVE, n√£o em VOD)
          showOverlay && isFullscreen && type === 'live' && e('div', {
            'data-testid': 'player-hud',
            style: {
              position: 'absolute',
              inset: 0,
              background: 'linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.6) 40%, transparent 100%)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'flex-end',
              alignItems: 'center',
              padding: `max(20px, env(safe-area-inset-bottom)) max(20px, env(safe-area-inset-left)) max(20px, env(safe-area-inset-right))`,
              zIndex: 999999,
              pointerEvents: 'auto',
              fontFamily: 'system-ui, -apple-system, sans-serif',
              gap: 'clamp(12px,1.5vw,20px)'
            }
          },
            // (A) P√çLULA CENTRAL - acima do cart√£o
            e('div', {
              style: {
                background: 'rgba(11, 16, 32, 0.80)',
                borderRadius: '9999px',
                padding: 'clamp(8px,1.2vw,12px) clamp(18px,2vw,28px)',
                color: '#FFFFFF',
                fontSize: 'clamp(16px,2.4vw,28px)',
                fontWeight: '600',
                letterSpacing: '0.5px',
                filter: 'drop-shadow(0 4px 6px rgba(0,0,0,0.3))',
                whiteSpace: 'nowrap',
                textTransform: 'uppercase'
              }
            }, formatPillTitle(channel?.name, selectedQuality)),

            // (B) CART√ÉO PRINCIPAL
            e('div', {
              style: {
                background: 'rgba(11, 16, 32, 0.92)',
                borderRadius: '20px',
                padding: 'clamp(12px,1.6vw,18px) clamp(16px,2vw,28px)',
                filter: 'drop-shadow(0 8px 16px rgba(0,0,0,0.4))',
                display: 'grid',
                gridTemplateColumns: 'auto auto 1fr 1fr auto',
                alignItems: 'center',
                gap: 'clamp(10px,1.4vw,18px)',
                width: '100%',
                maxWidth: '1400px'
              }
            },
              // Col 1: N¬∫ do canal
              e('div', {
                style: {
                  fontSize: 'clamp(22px,2vw,28px)',
                  fontWeight: '600',
                  color: '#FFFFFF'
                }
              }, String(channel?.num || '---')),

              // Col 2: Logo do canal
              channel?.stream_icon && e('img', {
                src: channel.stream_icon,
                style: {
                  width: 'clamp(34px,3vw,44px)',
                  height: 'clamp(34px,3vw,44px)',
                  borderRadius: '50%',
                  backgroundColor: 'rgba(11,16,32,0.8)',
                  padding: '4px',
                  objectFit: 'contain'
                }
              }),

              // Col 3: Programa atual (centro-esquerda)
              e('div', {
                style: {
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 'clamp(6px,0.8vw,10px)',
                  minWidth: 0
                }
              },
                // Linha 1: Hor√°rio + AO VIVO / PLAYBACK
                e('div', {
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: 'clamp(8px,1vw,12px)'
                  }
                },
                  e('div', {
                    style: {
                      fontSize: 'clamp(12px,1.2vw,14px)',
                      color: '#C7D2FE'
                    }
                  }, currentProg ? `${currentProg.start || '00:00'} ‚Äì ${currentProg.end || '00:00'}` : ''),
                  e('div', {
                    style: {
                      background: channel?.playback_mode ? '#F59E0B' : '#E11D48',
                      color: '#FFFFFF',
                      borderRadius: '6px',
                      padding: '2px 8px',
                      fontSize: 'clamp(10px,1.1vw,12px)',
                      fontWeight: '600'
                    }
                  }, channel?.playback_mode ? 'üé¨ PLAYBACK' : 'AO VIVO')
                ),
                // Linha 2: T√≠tulo do programa (usa playback_program se estiver em modo playback)
                e('div', {
                  style: {
                    fontSize: 'clamp(18px,2.2vw,26px)',
                    fontWeight: '600',
                    color: '#FFFFFF',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap'
                  }
                }, channel?.playback_mode ? (channel?.playback_program || 'Playback') : decodeMaybeBase64(currentProg?.title)),
                // Barra de progresso
                e('div', {
                  style: {
                    width: '100%',
                    height: '6px',
                    backgroundColor: 'rgba(255,255,255,0.2)',
                    borderRadius: '9999px',
                    overflow: 'hidden'
                  }
                },
                  e('div', {
                    style: {
                      width: `${currentProg?.progress || 0}%`,
                      height: '100%',
                      backgroundColor: '#EF4444',
                      borderRadius: '9999px',
                      transition: 'width 1s linear'
                    }
                  })
                )
              ),

              // Col 4: Pr√≥ximo programa (centro-direita)
              nextProg && e('div', {
                style: {
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 'clamp(6px,0.8vw,10px)',
                  minWidth: 0
                }
              },
                // Badge NEXT
                e('div', {
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: 'clamp(6px,0.8vw,10px)'
                  }
                },
                  e('div', {
                    style: {
                      background: '#CBD5E1',
                      color: '#0B1020',
                      borderRadius: '6px',
                      padding: '2px 8px',
                      fontSize: 'clamp(10px,1.1vw,12px)',
                      fontWeight: '600'
                    }
                  }, 'NEXT')
                ),
                // T√≠tulo do pr√≥ximo + hor√°rio
                e('div', {
                  style: {
                    fontSize: 'clamp(14px,1.6vw,18px)',
                    fontWeight: '600',
                    color: '#FFFFFF',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap'
                  }
                }, `${decodeMaybeBase64(nextProg.title)} ${nextProg.start || ''} ‚Äì ${nextProg.end || ''}`)
              ),

              // Col 5: Hora + Resolu√ß√£o
              e('div', {
                style: {
                  textAlign: 'right'
                }
              },
                e('div', {
                  style: {
                    fontSize: 'clamp(14px,1.6vw,18px)',
                    fontWeight: '600',
                    color: '#FFFFFF',
                    marginBottom: 'clamp(2px,0.4vw,4px)'
                  }
                }, currentTime),
                e('div', {
                  style: {
                    fontSize: 'clamp(12px,1.4vw,14px)',
                    color: 'rgba(255,255,255,0.8)'
                  }
                }, videoResolution)
              )
            ),

            // (C) FAIXA INFERIOR (CHIPS)
            e('div', {
              style: {
                background: 'rgba(11, 16, 32, 0.85)',
                borderRadius: '9999px',
                padding: 'clamp(8px,1.2vw,12px) clamp(12px,1.6vw,18px)',
                filter: 'drop-shadow(0 4px 12px rgba(0,0,0,0.4))',
                display: 'flex',
                alignItems: 'center',
                gap: 'clamp(8px,1vw,12px)',
                justifyContent: 'center',
                flexWrap: 'wrap'
              }
            },
              // Navega√ß√£o (‚Üê ‚Üí)
              e('button', {
                onClick: () => console.log('Previous channel'),
                style: {
                  background: 'rgba(255,255,255,0.15)',
                  color: '#FFFFFF',
                  border: '1px solid rgba(255,255,255,0.2)',
                  padding: 'clamp(6px,0.8vw,8px) clamp(10px,1.2vw,14px)',
                  borderRadius: '9999px',
                  fontSize: 'clamp(14px,1.4vw,16px)',
                  fontWeight: '500',
                  cursor: 'pointer',
                  outline: 'none',
                  transition: 'all 0.2s'
                }
              }, '‚Üê'),

              e('button', {
                onClick: () => console.log('Next channel'),
                style: {
                  background: 'rgba(255,255,255,0.15)',
                  color: '#FFFFFF',
                  border: '1px solid rgba(255,255,255,0.2)',
                  padding: 'clamp(6px,0.8vw,8px) clamp(10px,1.2vw,14px)',
                  borderRadius: '9999px',
                  fontSize: 'clamp(14px,1.4vw,16px)',
                  fontWeight: '500',
                  cursor: 'pointer',
                  outline: 'none',
                  transition: 'all 0.2s'
                }
              }, '‚Üí'),

              // Favorito (‚≠ê)
              e('button', {
                onClick: () => console.log('Toggle favorite'),
                style: {
                  background: 'rgba(255,255,255,0.15)',
                  color: '#FFFFFF',
                  border: '1px solid rgba(255,255,255,0.2)',
                  padding: 'clamp(6px,0.8vw,8px) clamp(10px,1.2vw,14px)',
                  borderRadius: '9999px',
                  fontSize: 'clamp(14px,1.4vw,16px)',
                  fontWeight: '500',
                  cursor: 'pointer',
                  outline: 'none',
                  transition: 'all 0.2s'
                }
              }, '‚≠ê'),

              // EPG/Info (üìã)
              e('button', {
                onClick: () => console.log('Show EPG/Info'),
                style: {
                  background: 'rgba(255,255,255,0.15)',
                  color: '#FFFFFF',
                  border: '1px solid rgba(255,255,255,0.2)',
                  padding: 'clamp(6px,0.8vw,8px) clamp(10px,1.2vw,14px)',
                  borderRadius: '9999px',
                  fontSize: 'clamp(14px,1.4vw,16px)',
                  fontWeight: '500',
                  cursor: 'pointer',
                  outline: 'none',
                  transition: 'all 0.2s'
                }
              }, 'üìã'),

              // Chips de qualidade (FHD, FHD¬≤, HD, HD¬≤, SD, SD¬≤)
              availableQualities.length > 0 && availableQualities.map(quality =>
                e('button', {
                  key: quality,
                  onClick: () => switchQuality(quality),
                  style: {
                    background: selectedQuality === quality ? '#22C55E' : 'rgba(255,255,255,0.15)',
                    color: selectedQuality === quality ? '#0B1020' : '#FFFFFF',
                    border: selectedQuality === quality ? '2px solid #34D399' : '1px solid rgba(255,255,255,0.2)',
                    padding: 'clamp(6px,0.8vw,8px) clamp(10px,1.2vw,14px)',
                    borderRadius: '9999px',
                    fontSize: 'clamp(12px,1.2vw,14px)',
                    fontWeight: selectedQuality === quality ? '600' : '500',
                    cursor: 'pointer',
                    outline: 'none',
                    transition: 'all 0.2s'
                  }
                }, quality)
              ),

              // Bot√£o Original (AUTO)
              e('button', {
                onClick: () => {
                  if(hlsRef.current) {
                    hlsRef.current.currentLevel = -1
                    setSelectedQuality(null)
                  }
                },
                style: {
                  background: !selectedQuality ? '#22C55E' : 'rgba(255,255,255,0.15)',
                  color: !selectedQuality ? '#0B1020' : '#FFFFFF',
                  border: !selectedQuality ? '2px solid #34D399' : '1px solid rgba(255,255,255,0.2)',
                  padding: 'clamp(6px,0.8vw,8px) clamp(10px,1.2vw,14px)',
                  borderRadius: '9999px',
                  fontSize: 'clamp(12px,1.2vw,14px)',
                  fontWeight: !selectedQuality ? '600' : '500',
                  cursor: 'pointer',
                  outline: 'none'
                }
              }, 'Original'),

              // Bot√£o Full Screen (VERDE DESTACADO)
              e('button', {
                onClick: toggleFullscreen,
                style: {
                  background: '#16A34A',
                  color: '#FFFFFF',
                  border: '2px solid #34D399',
                  padding: 'clamp(8px,1.2vw,10px) clamp(14px,1.8vw,20px)',
                  borderRadius: '9999px',
                  fontSize: 'clamp(12px,1.2vw,14px)',
                  fontWeight: '600',
                  cursor: 'pointer',
                  outline: 'none',
                  boxShadow: '0 0 12px rgba(52, 211, 153, 0.3)'
                }
              }, isFullscreen ? 'Sair da Tela Cheia' : 'Full Screen')
            )
          )
        ),

        // OVERLAY DESABILITADO (ser√° refeito)
        false && e('div', {
          style: {
            position: 'absolute',
            bottom: 0,
            left: 0,
            right: 0,
            background: 'linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.7) 60%, transparent 100%)',
            padding: '60px 30px 30px',
            zIndex: 99999,
            pointerEvents: 'none'
          }
        },
          e('div', {
            style: {
              maxWidth: '1400px',
              margin: '0 auto',
              pointerEvents: 'auto'
            }
          },
            // Nome do canal (topo)
            e('div', {
              style: {
                textAlign: 'center',
                marginBottom: '20px'
              }
            },
              e('div', {
                style: {
                  display: 'inline-block',
                  backgroundColor: 'rgba(30, 40, 60, 0.9)',
                  padding: '8px 24px',
                  borderRadius: '20px',
                  fontSize: '16px',
                  fontWeight: '700',
                  color: '#fff',
                  letterSpacing: '1px'
                }
              }, (channel?.name || 'CANAL').toUpperCase())
            ),

            // Container principal
            e('div', {
              style: {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                backgroundColor: 'rgba(15, 20, 30, 0.92)',
                borderRadius: '16px',
                padding: '24px 32px',
                boxShadow: '0 8px 32px rgba(0,0,0,0.6)'
              }
            },
              // ESQUERDA: N√∫mero + Logo + Programa Atual
              e('div', {
                style: {
                  display: 'flex',
                  alignItems: 'center',
                  gap: '20px',
                  flex: 1
                }
              },
                // N√∫mero do canal
                e('div', {
                  style: {
                    fontSize: '32px',
                    fontWeight: '700',
                    color: '#fff',
                    minWidth: '60px',
                    textAlign: 'center'
                  }
                }, String(channel?.num || channel?.stream_id || '‚Äî')),

                // Logo do canal
                channel?.stream_icon && e('img', {
                  src: channel.stream_icon,
                  style: {
                    width: '56px',
                    height: '56px',
                    borderRadius: '50%',
                    backgroundColor: '#fff',
                    padding: '4px',
                    objectFit: 'contain'
                  }
                }),

                // Programa atual
                e('div', {
                  style: {
                    flex: 1,
                    minWidth: 0
                  }
                },
                  // T√≠tulo + AO VIVO
                  e('div', {
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      gap: '12px',
                      marginBottom: '6px'
                    }
                  },
                    e('div', {
                      style: {
                        fontSize: '20px',
                        fontWeight: '700',
                        color: '#fff',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis'
                      }
                    }, currentProg?.title || 'Programa Atual'),
                    e('div', {
                      style: {
                        backgroundColor: '#E50914',
                        color: '#fff',
                        fontSize: '11px',
                        fontWeight: '800',
                        padding: '4px 10px',
                        borderRadius: '4px',
                        letterSpacing: '0.5px'
                      }
                    }, 'AO VIVO')
                  ),

                  // Hor√°rios
                  currentProg && e('div', {
                    style: {
                      fontSize: '14px',
                      color: '#aaa',
                      marginBottom: '8px'
                    }
                  }, `${currentProg.start || '00:00'} ‚Äì ${currentProg.end || '00:00'}`),

                  // Barra de progresso
                  currentProg && e('div', {
                    style: {
                      width: '100%',
                      height: '5px',
                      backgroundColor: 'rgba(255,255,255,0.2)',
                      borderRadius: '3px',
                      overflow: 'hidden'
                    }
                  },
                    e('div', {
                      style: {
                        width: `${currentProg.progress || 0}%`,
                        height: '100%',
                        backgroundColor: '#E50914',
                        transition: 'width 1s linear'
                      }
                    })
                  )
                )
              ),

              // CENTRO: Pr√≥ximo programa
              nextProg && e('div', {
                style: {
                  marginLeft: '32px',
                  marginRight: '32px',
                  minWidth: '200px'
                }
              },
                e('div', {
                  style: {
                    backgroundColor: 'rgba(60, 70, 90, 0.8)',
                    padding: '4px 12px',
                    borderRadius: '6px',
                    fontSize: '11px',
                    fontWeight: '700',
                    color: '#fff',
                    marginBottom: '6px',
                    display: 'inline-block'
                  }
                }, 'PR√ìXIMO'),
                e('div', {
                  style: {
                    fontSize: '14px',
                    color: '#aaa',
                    marginBottom: '4px'
                  }
                }, `${nextProg.start || '00:00'} ‚Äì ${nextProg.end || '00:00'}`),
                e('div', {
                  style: {
                    fontSize: '15px',
                    fontWeight: '600',
                    color: '#fff',
                    whiteSpace: 'nowrap',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    maxWidth: '250px'
                  }
                }, nextProg.title)
              ),

              // DIREITA: Hora + Resolu√ß√£o
              e('div', {
                style: {
                  textAlign: 'right',
                  minWidth: '100px'
                }
              },
                e('div', {
                  style: {
                    fontSize: '28px',
                    fontWeight: '700',
                    color: '#fff',
                    marginBottom: '4px'
                  }
                }, currentTime),
                e('div', {
                  style: {
                    fontSize: '13px',
                    fontWeight: '600',
                    color: '#aaa'
                  }
                }, videoResolution)
              )
            ),

            // BOT√ïES DE QUALIDADE
            availableQualities.length > 0 && e('div', {
              style: {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '12px',
                marginTop: '20px'
              }
            },
              e('div', {
                style: {
                  fontSize: '13px',
                  fontWeight: '600',
                  color: '#aaa',
                  marginRight: '8px'
                }
              }, 'QUALIDADE:'),

              availableQualities.map(quality =>
                e('button', {
                  key: quality,
                  onClick: () => switchQuality(quality),
                  style: {
                    backgroundColor: selectedQuality === quality ? '#E50914' : 'rgba(60, 70, 90, 0.8)',
                    color: '#fff',
                    border: 'none',
                    padding: '8px 20px',
                    borderRadius: '6px',
                    fontSize: '13px',
                    fontWeight: '700',
                    cursor: 'pointer',
                    transition: 'all 0.2s',
                    outline: 'none',
                    letterSpacing: '0.5px'
                  },
                  onMouseEnter: (e) => {
                    if(selectedQuality !== quality) {
                      e.target.style.backgroundColor = 'rgba(80, 90, 110, 0.9)'
                    }
                  },
                  onMouseLeave: (e) => {
                    if(selectedQuality !== quality) {
                      e.target.style.backgroundColor = 'rgba(60, 70, 90, 0.8)'
                    }
                  }
                }, quality)
              )
            )
          )
        )
      )
    }

    function toggleFullscreen(sel){
      const el = document.querySelector(sel)
      if(!el) return
      if(document.fullscreenElement){ document.exitFullscreen().catch(()=>{}) }
      else{ el.requestFullscreen && el.requestFullscreen().catch(()=>{}) }
    }

    function dayNum(offset){ const d = new Date(); d.setDate(d.getDate()+offset); return String(d.getDate()).padStart(2,'0') }
    function dayWeek(offset){ const d = new Date(); d.setDate(d.getDate()+offset); return ['Dom','Seg','Ter','Qua','Qui','Sex','S√°b'][d.getDay()] }

// Estado GLOBAL para NetflixMovies (persiste entre remontagens)
if(typeof window.__netflixMoviesState === 'undefined') {
  window.__netflixMoviesState = {
    initialized: false,
    currentViewKey: null, // ===== NOVO: Rastreia qual view est√° carregada =====
    sectionsMovies: [],
    featuredMovieId: null,
    totalCategories: 0, // Total de categorias dispon√≠veis
    currentCategoryIndex: 0, // Categoria vis√≠vel atual
    loading: false,
    errorMsg: '',
    marginContent: {}, // ===== NOVO: Estado de scroll horizontal persistente =====
    collections: [],
    showCollectionsView: false,
    selectedCollectionMovies: [],
    viewingCollectionMovies: false,
    heroBackdrop: null
  }
}

// Listeners para notificar componentes de mudan√ßas no estado global
if(typeof window.__netflixMoviesListeners === 'undefined') {
  window.__netflixMoviesListeners = new Set()
}

// Cache GLOBAL de filmes enriquecidos (evita re-buscar dados TMDB)
if(typeof window.__enrichedMoviesCache === 'undefined') {
  window.__enrichedMoviesCache = {}
}

// Estado GLOBAL para trailer em hover (evita re-render dos cards)
window.__hoveredTrailer = {
  trailerUrl: null,
  movieData: null,
  updateCallback: null
}

// Fun√ß√£o GLOBAL para atualizar estado e notificar todos os componentes
window.updateNetflixMoviesState = (updates) => {
  Object.assign(window.__netflixMoviesState, updates)
  console.log('[GLOBAL] Estado atualizado:', updates)
  // Notificar todos os componentes montados
  window.__netflixMoviesListeners.forEach(listener => listener())
}

// Fun√ß√£o para resetar estado quando sair da view de filmes
window.resetNetflixMovies = () => {
  window.__netflixMoviesState = {
    initialized: false,
    currentViewKey: window.__netflixMoviesState.currentViewKey, // ===== N√ÉO RESETAR: Manter para cancelar timeouts antigos =====
    sectionsMovies: [],
    featuredMovieId: null,
    currentCategoryIndex: 0,
    loading: false,
    errorMsg: '',
    collections: [], // Adicionar collections ao estado global
    showCollectionsView: false,
    selectedCollectionMovies: [],
    viewingCollectionMovies: false,
    heroBackdrop: null, // Backdrop para mostrar no topo (cole√ß√£o ou filme)
    marginContent: {} // ===== NOVO: Resetar estado de scroll =====
  }
  // ===== LIMPAR CATEGORIAS FILTRADAS =====
  window.__allAvailableCategories = []
  window.__allCategoriesRaw = []
  console.log('[GLOBAL] Estado NetflixMovies resetado')
  window.__netflixMoviesListeners.forEach(listener => listener())
}

// Componente NetflixMovies com prote√ß√£o anti-loop
    function NetflixMovies({ contentType = 'vod', categoryFilter = null }){
      const isSeriesMode = contentType === 'series'
      const modeLabel = isSeriesMode ? 'S√âRIES' : 'FILMES'
      const filterLabel = categoryFilter ? ` (${categoryFilter})` : ''
      console.log(`üé¨ [NetflixMovies] COMPONENTE RENDERIZADO - Modo: ${modeLabel}${filterLabel}`)

      // Usar estado global + forceUpdate para re-renderizar
      const [, forceUpdate] = useState(0)
      const globalState = window.__netflixMoviesState

      // ===== SOLU√á√ÉO FINAL: useRef + callback para notificar componentes espec√≠ficos =====
      const marginContentRef = useRef(globalState.marginContent || {})
      const marginListenersRef = useRef({}) // Callbacks por sectionId

      const setMarginContent = (updater) => {
        const newValue = typeof updater === 'function' ? updater(marginContentRef.current) : updater
        marginContentRef.current = newValue
        // Salvar no global para persistir
        window.__netflixMoviesState.marginContent = newValue

        // ===== ATUALIZAR DOM DIRETAMENTE (sem re-render do componente pai) =====
        Object.keys(newValue).forEach(sectionId => {
          const container = document.querySelector(`[data-section-id="${sectionId}"]`)
          if (container) {
            container.style.transform = `translateX(${newValue[sectionId]}px)`
          }

          // ===== NOTIFICAR apenas o SectionMovies espec√≠fico =====
          if (marginListenersRef.current[sectionId]) {
            marginListenersRef.current[sectionId](newValue[sectionId])
          }
        })
      }

      // Fun√ß√£o para SectionMovies se registrar
      const registerMarginListener = (sectionId, callback) => {
        marginListenersRef.current[sectionId] = callback
        return () => {
          delete marginListenersRef.current[sectionId]
        }
      }

      const [focusedMovieIdx, setFocusedMovieIdx] = useState(0)
      const loadingCategoriesRef = useRef(new Set()) // M√∫ltiplas categorias carregando simultaneamente

      // Estados para cole√ß√µes (usar estado global para persistir)
      const collections = globalState.collections || []
      const setCollections = (value) => {
        console.log('[setCollections] Atualizando collections:', value.length, 'itens')
        window.updateNetflixMoviesState({ collections: value })
      }

      // Estados de visualiza√ß√£o de cole√ß√µes (tamb√©m usar estado global)
      const showCollectionsView = globalState.showCollectionsView || false
      const setShowCollectionsView = (value) => {
        console.log('[setShowCollectionsView]', value)
        window.updateNetflixMoviesState({ showCollectionsView: value })
      }

      const selectedCollectionMovies = globalState.selectedCollectionMovies || []
      const setSelectedCollectionMovies = (value) => {
        console.log('[setSelectedCollectionMovies]', value.length, 'filmes')
        window.updateNetflixMoviesState({ selectedCollectionMovies: value })
      }

      const viewingCollectionMovies = globalState.viewingCollectionMovies || false
      const setViewingCollectionMovies = (value) => {
        console.log('[setViewingCollectionMovies]', value)
        window.updateNetflixMoviesState({ viewingCollectionMovies: value })
      }

      const [loadingCollections, setLoadingCollections] = useState(false) // Carregando cole√ß√µes

      // Fun√ß√£o para carregar √≠ndice de cole√ß√µes pr√©-constru√≠do (INSTANT√ÇNEO)
      const loadCollectionsFromJSON = async (setCollections) => {
        console.log('[loadCollectionsFromJSON] üì• Carregando √≠ndice de cole√ß√µes...')
        setLoadingCollections(true)

        try {
          // URL do arquivo JSON (ajuste conforme necess√°rio)
          const jsonUrl = './collections.json' // Coloque o arquivo na raiz do projeto
          console.log('[loadCollectionsFromJSON] Tentando carregar:', jsonUrl)

          const response = await fetch(jsonUrl)
          console.log('[loadCollectionsFromJSON] Response status:', response.status)

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }

          const data = await response.json()
          console.log(`[loadCollectionsFromJSON] ‚úÖ Carregado: ${data.total_collections} cole√ß√µes com ${data.total_movies_with_collections} filmes`)
          console.log(`[loadCollectionsFromJSON] üìÖ Gerado em: ${data.generated_at}`)

          // Transformar para o formato esperado pelo componente
          const collections = data.collections.map(col => ({
            id: col.id,
            name: col.name,
            poster: col.poster_path ? `https://image.tmdb.org/t/p/w500${col.poster_path}` : null,
            backdrop: col.backdrop_path ? `https://image.tmdb.org/t/p/w1280${col.backdrop_path}` : null,
            overview: '', // Ser√° enriquecido a seguir
            movies: col.movies.map(m => ({
              stream_id: m.stream_id,
              name: m.name,
              category: m.category
            }))
          }))

          // Enriquecer primeiras 30 cole√ß√µes com overview do TMDB (em background)
          console.log('[loadCollectionsFromJSON] üîç Enriquecendo cole√ß√µes com TMDB...')
          const collectionsToEnrich = collections.slice(0, 30) // Limitar para performance

          Promise.all(
            collectionsToEnrich.map(async (col, idx) => {
              try {
                const tmdbData = await getTMDBCollection(col.id)
                if (tmdbData && tmdbData.overview) {
                  col.overview = tmdbData.overview
                }
              } catch (err) {
                console.warn(`[loadCollectionsFromJSON] Erro ao enriquecer cole√ß√£o ${col.name}:`, err.message)
              }
            })
          ).then(() => {
            console.log('[loadCollectionsFromJSON] ‚úÖ Enriquecimento TMDB conclu√≠do')
            setCollections([...collections]) // Atualizar estado com overviews
          })

          setCollections(collections)
          console.log(`[loadCollectionsFromJSON] üé¨ ${collections.length} cole√ß√µes prontas para uso!`)

          // Mostrar top 5 cole√ß√µes
          const top5 = collections
            .sort((a, b) => b.movies.length - a.movies.length)
            .slice(0, 5)
            .map(c => `${c.name} (${c.movies.length} filmes)`)
          console.log('[loadCollectionsFromJSON] Top 5:', top5)

        } catch (err) {
          console.error('[loadCollectionsFromJSON] ‚ùå ERRO AO CARREGAR COLE√á√ïES:', err)
          console.error('[loadCollectionsFromJSON] Mensagem:', err.message)
          console.error('[loadCollectionsFromJSON] Stack:', err.stack)
          setCollections([])
        } finally {
          setLoadingCollections(false)
        }
      }

      // Fun√ß√£o simplificada - cole√ß√µes s√£o carregadas do JSON no initMovies
      const loadCollections = () => {
        console.log('[loadCollections] ===== DEBUG =====')
        console.log('[loadCollections] Cole√ß√µes dispon√≠veis:', collections.length)
        console.log('[loadCollections] collections:', collections)
        console.log('[loadCollections] showCollectionsView:', showCollectionsView)
        console.log('[loadCollections] ==================')
        // As cole√ß√µes foram carregadas do collections.json
        // Esta fun√ß√£o agora apenas mostra informa√ß√µes
      }

      // IMPORTANTE: Usar estado global para persistir categoria entre re-renders
      const currentCategoryIndex = globalState.currentCategoryIndex || 0
      const setCurrentCategoryIndex = (value) => {
        const newValue = typeof value === 'function' ? value(currentCategoryIndex) : value
        console.log(`[NetflixMovies] üîÑ setCurrentCategoryIndex: ${currentCategoryIndex} -> ${newValue}`)
        window.updateNetflixMoviesState({
          currentCategoryIndex: newValue
        })
      }

      // ===== NOVO: Ref para rastrear a √∫ltima categoria e evitar resets desnecess√°rios =====
      const lastCategoryIndexRef = useRef(currentCategoryIndex)

      // Registrar listener para re-renderizar quando estado global mudar
      useEffect(() => {
        const listener = (skipRender) => {
          // Se skipRender === true, n√£o for√ßar re-render (usado para marginContent)
          if (skipRender) return

          // console.log('[NetflixMovies] üîÅ forceUpdate chamado, categoria atual:', globalState.currentCategoryIndex)
          forceUpdate(v => v + 1)
        }
        window.__netflixMoviesListeners.add(listener)
        // console.log('[NetflixMovies] Listener registrado')
        return () => {
          window.__netflixMoviesListeners.delete(listener)
          // console.log('[NetflixMovies] Listener removido')
        }
      }, [])

      // ‚úÖ Prote√ß√£o GLOBAL contra remontagem e loop infinito
      // ===== IMPORTANTE: Criar chave √∫nica baseada em contentType + categoryFilter =====
      const viewKey = `${contentType}-${categoryFilter || 'all'}`

      useEffect(() => {
        console.log('[NetflixMovies] useEffect executado - viewKey:', viewKey)

        // ===== CORRE√á√ÉO CR√çTICA: Atualizar currentViewKey IMEDIATAMENTE antes de qualquer async =====
        const previousViewKey = globalState.currentViewKey

        // Verificar se J√Å inicializou ESSA VIEW ESPEC√çFICA (antes de mudar currentViewKey)
        if(globalState.initialized && previousViewKey === viewKey) {
          console.log('[NetflixMovies] J√Å INICIALIZADO para esta view - abortando')
          return
        }

        // Agora sim, atualizar currentViewKey para a nova view
        globalState.currentViewKey = viewKey
        console.log(`[NetflixMovies] currentViewKey atualizado: ${previousViewKey} ‚Üí ${viewKey}`)

        globalState.initialized = true
        const ac = new AbortController()

        const initMovies = async () => {
          console.log('[initMovies] üé¨üé¨üé¨ INICIANDO CARREGAMENTO DE FILMES üé¨üé¨üé¨')
          console.log(`[initMovies] üîë ViewKey: ${viewKey}`)
          console.log(`[initMovies] üì∫ Modo: ${isSeriesMode ? 'S√âRIES' : 'FILMES'}`)
          console.log(`[initMovies] üîç Filtro: ${categoryFilter || 'NENHUM'}`)
          console.log(`[initMovies] üßπ Estado anterior limpo: ${globalState.sectionsMovies.length} se√ß√µes removidas`)
          if(ac.signal.aborted) return

          window.updateNetflixMoviesState({ loading: true, errorMsg: '', sectionsMovies: [] })

          try {
            // 1. Carregar categorias VOD ou SERIES dependendo do modo
            const categoryType = isSeriesMode ? 'S√âRIES' : 'VOD'
            const apiAction = isSeriesMode ? 'get_series_categories' : 'get_vod_categories'

            // ===== IMPORTANTE: SEMPRE carregar categorias para garantir filtro correto =====
            let categories = []

            // Sempre buscar da API para garantir que n√£o h√° cache incorreto
            console.log(`[initMovies] üîÑ Carregando categorias ${categoryType} da API... ${categoryFilter ? `(Filtro: ${categoryFilter})` : ''}`)
            console.log(`[DEBUG] üìû API action:`, apiAction)
            const raw = await apiCall(apiAction)
            console.log(`[DEBUG] üì¶ Resposta RAW da API:`, raw)
            const catsArray = toArray(raw)
            console.log(`[DEBUG] üìä Array de categorias ap√≥s toArray:`, catsArray.length, 'itens')

            if(!Array.isArray(catsArray) || catsArray.length === 0) {
              throw new Error(`Nenhuma categoria ${categoryType} dispon√≠vel`)
            }

            console.log(`[initMovies] ‚úÖ ${catsArray.length} categorias ${categoryType} carregadas da API`)
            console.log(`[DEBUG] üìã TODAS as categorias da API:`, catsArray.map(c => c.category_name).join(', '))
            categories = catsArray

            // 2. Filtrar categorias se houver filtro espec√≠fico
            let selectedCategories = categories

            // Aplicar filtro por nome de categoria se especificado
            if (categoryFilter) {
              const filterLower = categoryFilter.toLowerCase()
              console.log(`[DEBUG] üîç Aplicando filtro: "${filterLower}"`)
              selectedCategories = categories.filter(cat => {
                const catName = (cat.category_name || '').toLowerCase()
                const matches = catName.includes(filterLower)
                if (matches) {
                  console.log(`[DEBUG] ‚úÖ Match: "${cat.category_name}" cont√©m "${filterLower}"`)
                }
                return matches
              })
              console.log(`[initMovies] üîç Filtro "${categoryFilter}": ${selectedCategories.length}/${categories.length} categorias encontradas`)

              // Log das categorias filtradas
              if (selectedCategories.length > 0) {
                console.log(`[DEBUG] üìã Categorias filtradas (TODAS):`, selectedCategories.map(c => c.category_name).join(', '))
                console.log(`[DEBUG] üî¢ IDs das categorias filtradas:`, selectedCategories.map(c => c.category_id).join(', '))
              }

              if (selectedCategories.length === 0) {
                console.error(`[initMovies] ‚ùå ERRO: Nenhuma categoria encontrada com filtro "${categoryFilter}"`)
                console.log(`[initMovies] üìã Categorias dispon√≠veis:`, categories.slice(0, 10).map(c => c.category_name).join(', '))
                // ===== CORRE√á√ÉO: N√ÉO usar todas, mostrar erro =====
                window.updateNetflixMoviesState({
                  loading: false,
                  errorMsg: `Nenhuma categoria encontrada para "${categoryFilter}"`
                })
                return
              }
            } else {
              console.log(`[DEBUG] ‚ÑπÔ∏è SEM FILTRO - Usando todas as ${categories.length} categorias`)
            }

            console.log(`[initMovies] üìã Total de ${selectedCategories.length} categorias dispon√≠veis`)
            console.log(`[initMovies] üöÄ Carregando primeira categoria (lazy loading)...`)

            // ===== CORRE√á√ÉO: Guardar categorias com chave √∫nica por view =====
            const categoriesKey = `categories_${viewKey}`
            window[categoriesKey] = selectedCategories
            window[`${categoriesKey}_raw`] = categories
            console.log(`[initMovies] üíæ Categorias salvas em: ${categoriesKey}`)

            // Manter compatibilidade (mas ser√£o sobrescritas)
            window.__allAvailableCategories = selectedCategories
            window.__allCategoriesRaw = categories

            // 3. Carregar APENAS a PRIMEIRA categoria (lazy loading)
            const allSections = []

            // Carregar apenas a primeira categoria
            const firstCat = selectedCategories[0]
            const firstCategoryIndex = categories.indexOf(firstCat)

            try {
              console.log(`[initMovies] Carregando categoria 1/${selectedCategories.length}: ${firstCat.category_name}`)
              console.log(`[DEBUG] üî¢ firstCategoryIndex: ${firstCategoryIndex}, category_id: ${getCatId(firstCat)}`)

              // Carregar filmes da primeira categoria
              const section = await loadCategoryMovies(firstCategoryIndex, categories)

              if(section && section.movies.length > 0) {
                allSections.push(section)
                console.log(`[initMovies] ‚úÖ ${firstCat.category_name}: ${section.movies.length} filmes`)
                console.log(`[DEBUG] üì¶ Se√ß√£o criada - ID: ${section.id}, Name: ${section.name}`)
                console.log(`[DEBUG] üé¨ Primeiro filme da se√ß√£o: ${section.movies[0].name || section.movies[0].title}`)
              } else {
                console.warn(`[initMovies] ‚ö†Ô∏è ${firstCat.category_name}: sem filmes`)
              }
            } catch(err) {
              console.error(`[initMovies] ‚ùå Erro ao carregar ${firstCat.category_name}:`, err.message)
            }

            if(allSections.length === 0) {
              throw new Error('Nenhuma categoria com filmes dispon√≠vel')
            }

            console.log(`[initMovies] ‚úÖ Primeira categoria carregada (${selectedCategories.length} dispon√≠veis no total)`)

            // Atualizar estado com todas as se√ß√µes
            console.log(`[DEBUG] üíæ Atualizando estado com ${allSections.length} se√ß√£o(√µes)`)
            // ===== FIX: S√©ries usam series_id, filmes usam stream_id =====
            const firstMovie = allSections[0].movies[0]
            const firstMovieId = firstMovie.series_id || firstMovie.stream_id
            console.log(`[DEBUG] üé¨ Definindo featuredMovieId:`, firstMovieId, 'do filme:', firstMovie.name, '(series_id:', firstMovie.series_id, ', stream_id:', firstMovie.stream_id, ')')

            window.updateNetflixMoviesState({
              sectionsMovies: allSections,
              featuredMovieId: firstMovieId,
              totalCategories: selectedCategories.length
            })

            // Verificar o que foi salvo no estado
            console.log(`[DEBUG] ‚úÖ Estado atualizado - sectionsMovies.length:`, window.__netflixMoviesState.sectionsMovies.length)
            console.log(`[DEBUG] ‚úÖ Estado atualizado - featuredMovieId:`, window.__netflixMoviesState.featuredMovieId)
            if (window.__netflixMoviesState.sectionsMovies.length > 0) {
              const firstSection = window.__netflixMoviesState.sectionsMovies[0]
              console.log(`[DEBUG] üìã Primeira se√ß√£o no estado - ID: ${firstSection.id}, Name: ${firstSection.name}, Movies: ${firstSection.movies.length}`)
              console.log(`[DEBUG] üé¨ Primeiro filme no estado: ${firstSection.movies[0].name || firstSection.movies[0].title}`)
            }

            // 4. Carregar √≠ndice de cole√ß√µes pr√©-constru√≠do (instant√¢neo)
            console.log('[initMovies] üé¨ Carregando √≠ndice de cole√ß√µes...')
            await loadCollectionsFromJSON(setCollections)

            // ===== OTIMIZADO: Pr√©-carregar apenas pr√≥ximas 3 categorias (lazy loading on-demand) =====
            const PRELOAD_LIMIT = 3 // Reduzido de TODAS para apenas 3
            console.log(`[initMovies] üì¶ Pr√©-carregando pr√≥ximas ${PRELOAD_LIMIT} categorias...`)
            const totalCats = selectedCategories.length
            const categoriesToPreload = Math.min(PRELOAD_LIMIT, totalCats - 1)

            // ===== CORRE√á√ÉO: Armazenar timeout IDs para cancelar no cleanup =====
            const preloadTimeouts = []
            for (let i = 1; i <= categoriesToPreload; i++) {
              const timeoutId = setTimeout(() => {
                // Verificar se ainda estamos na mesma view antes de carregar
                console.log(`[TIMEOUT] Timeout ${i} disparou - currentViewKey: ${globalState.currentViewKey}, expectedViewKey: ${viewKey}`)
                if (globalState.currentViewKey === viewKey && !globalState.sectionsMovies[i]) {
                  console.log(`[initMovies] üì¶ Pr√©-carregando categoria ${i + 1}/${totalCats}... (viewKey: ${viewKey})`)
                  loadCategory(i, null, viewKey) // ‚Üê PASSAR viewKey!
                } else {
                  console.log(`[initMovies] ‚è≠Ô∏è Pr√©-carregamento cancelado - currentViewKey: ${globalState.currentViewKey} !== ${viewKey}`)
                }
              }, i * 1000) // Escalonar: 1s, 2s, 3s (mais espa√ßado)
              preloadTimeouts.push(timeoutId)
            }

            // Salvar timeouts no AbortController para cancelar no cleanup
            ac.signal.addEventListener('abort', () => {
              preloadTimeouts.forEach(id => clearTimeout(id))
              console.log(`[initMovies] üõë Pr√©-carregamentos cancelados para viewKey: ${viewKey}`)
            })

            console.log(`[initMovies] ‚ÑπÔ∏è Demais categorias (${totalCats - categoriesToPreload - 1}) ser√£o carregadas sob demanda`)

            console.log('[initMovies] ‚úÖ Inicializa√ß√£o completa')
          } catch(err) {
            console.error('[initMovies] ‚ùå Erro:', err.message)
            window.updateNetflixMoviesState({ errorMsg: err.message || 'Erro ao carregar categorias. Verifique a API/proxy.' })
          } finally {
            window.updateNetflixMoviesState({ loading: false })
          }
        }

        initMovies()

        return () => {
          ac.abort()
          console.log('[NetflixMovies] Componente desmontado - viewKey:', viewKey)
        }
      }, [viewKey]) // ===== CORRIGIDO: Depend√™ncia viewKey para reinicializar quando mudar =====

      // Resetar scroll horizontal quando mudar de categoria (APENAS quando categoria muda)
      useEffect(() => {
        // ===== NOVO: S√≥ resetar se a categoria REALMENTE mudou =====
        if (currentCategoryIndex === lastCategoryIndexRef.current) {
          return
        }

        lastCategoryIndexRef.current = currentCategoryIndex

        const currentSection = globalState.sectionsMovies[currentCategoryIndex]
        if (currentSection) {
          setMarginContent(prev => ({
            ...prev,
            [currentSection.id]: 0
          }))
        }
      }, [currentCategoryIndex]) // ===== CORRIGIDO: Removido globalState.sectionsMovies das depend√™ncias =====

      // Navega√ß√£o por teclado
      useEffect(() => {
        if(view !== 'netflix-movies' || globalState.sectionsMovies.length === 0) return

        const handleKeyDown = (e) => {
          const currentSection = globalState.sectionsMovies[currentCategoryIndex]
          if(!currentSection) return

          if(e.key === 'ArrowRight'){
            e.preventDefault()
            setFocusedMovieIdx(prev => Math.min(prev + 1, currentSection.movies.length - 1))
          } else if(e.key === 'ArrowLeft'){
            e.preventDefault()
            if(focusedMovieIdx === 0){
              // Se est√° no primeiro filme, volta para home
              setView('home')
            } else {
              setFocusedMovieIdx(prev => Math.max(prev - 1, 0))
            }
          } else if(e.key === 'ArrowDown'){
            e.preventDefault()
            // Mudar para pr√≥xima categoria
            const totalAvailable = globalState.totalCategories || window.__allAvailableCategories?.length || 0
            if (currentCategoryIndex < totalAvailable - 1) {
              const nextIndex = currentCategoryIndex + 1
              console.log(`[Keyboard] ‚¨áÔ∏è Mudando para categoria ${nextIndex + 1}`)

              // Atualizar filme em destaque ANTES de mudar categoria (para evitar piscar)
              const nextSection = globalState.sectionsMovies[nextIndex]
              if (nextSection && nextSection.movies.length > 0) {
                const firstMovie = nextSection.movies[0]
                const newFeaturedId = firstMovie.stream_id || firstMovie.id
                console.log(`[Keyboard] Atualizando featuredMovieId para: ${firstMovie.name}`)
                window.updateNetflixMoviesState({
                  featuredMovieId: newFeaturedId
                })
              }

              // Resetar scroll para 0 com o sectionId correto
              if (nextSection) {
                setMarginContent({ [nextSection.id]: 0 })
              }

              // Mudar categoria
              setCurrentCategoryIndex(nextIndex)
              setFocusedMovieIdx(0)

              // Se a categoria ainda n√£o foi carregada, carregar em background
              if (!nextSection) {
                loadCategory(nextIndex)
              }
            }
          } else if(e.key === 'ArrowUp'){
            e.preventDefault()
            // Mudar para categoria anterior
            if (currentCategoryIndex > 0) {
              const prevIndex = currentCategoryIndex - 1
              console.log(`[Keyboard] ‚¨ÜÔ∏è Mudando para categoria ${prevIndex + 1}`)

              // Atualizar filme em destaque ANTES de mudar categoria (para evitar piscar)
              const prevSection = globalState.sectionsMovies[prevIndex]
              if (prevSection && prevSection.movies.length > 0) {
                const firstMovie = prevSection.movies[0]
                const newFeaturedId = firstMovie.stream_id || firstMovie.id
                console.log(`[Keyboard] Atualizando featuredMovieId para: ${firstMovie.name}`)
                window.updateNetflixMoviesState({
                  featuredMovieId: newFeaturedId
                })
              }

              // Resetar scroll para 0 com o sectionId correto
              if (prevSection) {
                setMarginContent({ [prevSection.id]: 0 })
              }

              // Mudar categoria
              setCurrentCategoryIndex(prevIndex)
              setFocusedMovieIdx(0)

              // Se a categoria ainda n√£o foi carregada, carregar em background
              if (!prevSection) {
                loadCategory(prevIndex)
              }
            }
          } else if(e.key === 'Enter'){
            e.preventDefault()
            const movie = currentSection.movies[focusedMovieIdx]
            if(movie && movie.stream_id){
              setView('player')
              setCurrent({
                name: movie.name || movie.title,
                url: buildURL(cfg.server, ['movie', cfg.username, cfg.password, `${movie.stream_id}.${movie.container_extension || 'mp4'}`])
              })
            }
          } else if(e.key === 'Escape'){
            e.preventDefault()
            window.resetNetflixMovies()  // Resetar flag ao sair
            setView('home')
          }
        }

        window.addEventListener('keydown', handleKeyDown)
        return () => window.removeEventListener('keydown', handleKeyDown)
      }, [view, globalState.sectionsMovies, currentCategoryIndex, focusedMovieIdx])

      // Auto-scroll para o item focado
      useEffect(() => {
        if(view === 'netflix-movies' && globalState.sectionsMovies.length > 0){
          const currentSection = globalState.sectionsMovies[currentCategoryIndex]
          if(currentSection){
            const movie = currentSection.movies[focusedMovieIdx]
            if(movie){
              const el = document.getElementById(`movie-${currentCategoryIndex}-${focusedMovieIdx}`)
              if(el) el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' })
            }
          }
        }
      }, [currentCategoryIndex, focusedMovieIdx, view, globalState.sectionsMovies])

      // Carregar filmes de uma categoria (retorna objeto se√ß√£o)
      // Carrega TODOS os filmes da categoria de uma vez
      const loadCategoryMovies = async (categoryIndex, categoriesArray) => {
        const cats = categoriesArray
        const cat = cats[categoryIndex]

        if(!cat || !cat.category_name) {
          console.error(`[loadCategoryMovies] Categoria inv√°lida no √≠ndice ${categoryIndex}`)
          return null
        }

        try {
          // Buscar APENAS os filmes/s√©ries desta categoria (performance otimizada)
          const contentLabel = isSeriesMode ? 's√©ries' : 'filmes'
          const apiAction = isSeriesMode ? 'get_series' : 'get_vod_streams'

          console.log(`[loadCategoryMovies] üì• Buscando ${contentLabel} da categoria ${cat.category_name}...`)
          console.log(`[DEBUG] üìû API action: ${apiAction}, category_id: ${getCatId(cat)}`)
          const data = await apiCall(apiAction, { category_id: getCatId(cat) })
          const allMoviesInCategory = toArray(data)

          console.log(`[loadCategoryMovies] "${cat.category_name}": ${allMoviesInCategory.length} ${contentLabel} totais`)
          if (allMoviesInCategory.length > 0) {
            console.log(`[DEBUG] üé¨ Primeiros 5 ${contentLabel} em "${cat.category_name}":`, allMoviesInCategory.slice(0, 5).map(m => m.name || m.title).join(', '))
            console.log(`[DEBUG] üÜî Primeiro item completo (verificar tmdb_id):`, allMoviesInCategory[0])
          }

          if(allMoviesInCategory.length === 0) {
            console.warn(`[loadCategoryMovies] "${cat.category_name}" sem filmes`)
            return null
          }

          // Guardar TODOS os filmes mas renderizar inicialmente apenas 10 (performance)
          const INITIAL_LOAD = 10

          console.log(`[loadCategoryMovies] Retornando ${allMoviesInCategory.length} filmes (renderiza√ß√£o sob demanda)`)

          // ===== ENRIQUECIMENTO TMDB: Primeiro filme IMEDIATO, resto em background =====
          console.log(`[loadCategoryMovies] üé¨ Enriquecendo filme em destaque...`)

          const PRIORITY_COUNT = 10

          // Enriquecer APENAS o primeiro filme (featured) IMEDIATAMENTE para backdrop instant√¢neo
          const contentTypeParam = isSeriesMode ? 'series' : 'movie'
          console.log(`[DEBUG LOAD] üì• Filme original antes de enriquecer: "${allMoviesInCategory[0].name}" (tipo: ${contentTypeParam})`)
          const firstEnriched = await enrichMovieWithTMDB(allMoviesInCategory[0], contentTypeParam)
          console.log(`[DEBUG LOAD] üé¨ Filme enriquecido retornado: "${firstEnriched.name || firstEnriched.title}"`)

          // Enriquecer filmes 2-10 em background (n√£o bloquear)
          if (allMoviesInCategory.length > 1) {
            Promise.all(
              allMoviesInCategory.slice(1, PRIORITY_COUNT).map(movie => enrichMovieWithTMDB(movie, contentTypeParam))
            ).then(enrichedMovies => {
              console.log(`[loadCategoryMovies] ‚úÖ ${enrichedMovies.length} filmes secund√°rios enriquecidos (background)`)
            }).catch(err => {
              console.error(`[loadCategoryMovies] ‚ùå Erro no enriquecimento background:`, err)
            })
          }

          // Retornar com primeiro filme enriquecido + resto sem enriquecer
          const finalMovies = [firstEnriched, ...allMoviesInCategory.slice(1)]
          console.log(`[DEBUG LOAD] üì¶ finalMovies[0]: "${finalMovies[0].name || finalMovies[0].title}"`)

          // Retornar TODOS os filmes da categoria
          // A renderiza√ß√£o ser√° feita sob demanda (scroll infinito)
          return {
            id: categoryIndex,
            name: cat.category_name,
            movies: finalMovies,
            totalMovies: finalMovies.length,
            visibleCount: INITIAL_LOAD  // Quantos renderizar inicialmente
          }
        } catch(err) {
          console.error(`[loadCategoryMovies] Erro ao carregar "${cat.category_name}":`, err.message)
          return null
        }
      }

      // Carregar uma categoria espec√≠fica (usa loadCategoryMovies e atualiza estado)
      const loadCategory = async (categoryIndex, categoriesArray = null, forceViewKey = null) => {
        // ===== CORRE√á√ÉO: Usar categorias espec√≠ficas do viewKey PASSADO ou atual =====
        const useViewKey = forceViewKey || viewKey
        const categoriesKey = `categories_${useViewKey}`
        const cats = categoriesArray || window[`${categoriesKey}_raw`] || window.__allCategoriesRaw || vodCats
        const availableCategories = window[categoriesKey] || window.__allAvailableCategories || []

        console.log(`[loadCategory] üîë Usando categorias de: ${categoriesKey} (forceViewKey: ${forceViewKey}, currentViewKey: ${globalState.currentViewKey})`)
        console.log(`[loadCategory] üìã Total dispon√≠vel: ${availableCategories.length}`)

        // ===== VERIFICA√á√ÉO CR√çTICA: Abortar se n√£o √© mais a view correta =====
        if (useViewKey !== globalState.currentViewKey) {
          console.log(`[loadCategory] üõë ABORTADO - View mudou de ${useViewKey} para ${globalState.currentViewKey}`)
          return
        }

        if(categoryIndex < 0 || categoryIndex >= availableCategories.length) {
          console.error(`[loadCategory] ‚ùå √çndice inv√°lido: ${categoryIndex} (dispon√≠vel: 0-${availableCategories.length - 1})`)
          return
        }

        // Verificar se j√° est√° carregada
        if(globalState.sectionsMovies[categoryIndex]) {
          console.log(`[loadCategory] ‚ö° Categoria ${categoryIndex} j√° est√° carregada`)
          return
        }

        // ===== CORRIGIDO: Permitir m√∫ltiplos carregamentos simult√¢neos =====
        // Verificar se esta categoria espec√≠fica j√° est√° sendo carregada
        if(loadingCategoriesRef.current.has(categoryIndex)) {
          console.log(`[loadCategory] ‚è≥ Categoria ${categoryIndex} j√° est√° em carregamento`)
          return
        }

        const cat = availableCategories[categoryIndex]
        if(!cat) {
          console.error(`[loadCategory] ‚ùå Categoria ${categoryIndex} n√£o encontrada em availableCategories`)
          return
        }

        console.log(`[loadCategory] üîÑ Carregando: ${cat.category_name} (√≠ndice: ${categoryIndex})`)

        // Adicionar ao Set de categorias em carregamento
        loadingCategoriesRef.current.add(categoryIndex)

        try {
          const catInRawArray = cats.indexOf(cat)
          const section = await loadCategoryMovies(catInRawArray, cats)

          if(section) {
            // Adicionar a nova se√ß√£o na posi√ß√£o correta (n√£o substituir)
            const newSections = [...globalState.sectionsMovies]
            newSections[categoryIndex] = section

            // ===== CORRIGIDO: N√ÉO mudar featuredMovieId em pr√©-carregamento =====
            // S√≥ atualizar sectionsMovies, preservar featuredMovieId atual
            window.updateNetflixMoviesState({
              sectionsMovies: newSections
            })
            console.log(`[loadCategory] ‚úÖ ${cat.category_name}: ${section.movies.length} filmes`)
          } else {
            console.warn(`[loadCategory] ‚ö†Ô∏è ${cat.category_name}: sem filmes`)
          }
        } catch(err){
          console.error(`[loadCategory] ‚ùå Erro ao carregar ${cat.category_name}:`, err.message)
        } finally {
          // Remover do Set de categorias em carregamento
          loadingCategoriesRef.current.delete(categoryIndex)
        }
      }

      const loadMoviesRef = useRef(false)

      const loadMovies = async () => {
        console.log('üöÄ [loadMovies] INICIADO')

        // Prote√ß√£o: se j√° carregou, n√£o carrega de novo
        if(loadMoviesRef.current) {
          console.log('‚ö†Ô∏è [loadMovies] J√Å FOI CARREGADO, ABORTANDO')
          return
        }

        loadMoviesRef.current = true
        window.updateNetflixMoviesState({ loading: true })

        if(vodCats.length === 0){
          console.log('‚ö†Ô∏è [loadMovies] vodCats vazio, abortando')
          window.updateNetflixMoviesState({ loading: false })
          loadMoviesRef.current = false
          return
        }

        console.log(`üìã [loadMovies] vodCats tem ${vodCats.length} categorias`)

        // Carregar apenas a primeira categoria
        await loadCategory(0)

        console.log('‚úÖ [loadMovies] CONCLU√çDO')
        window.updateNetflixMoviesState({ loading: false })
      }

      // Scroll handler - PART 1: Netflix-style scroll (6 cards visible)
      const handleScrollMovies = (sectionId, direction) => {
        // console.log(`[handleScrollMovies] üé¨ INICIANDO - sectionId: ${sectionId}, direction: ${direction}`)

        setMarginContent(state => {
          const currentMargin = state[sectionId] || 0
          const cardWidth = 280 // Largura de cada card (260px + 20px gap)
          const padding = 80 // 40px cada lado
          const viewportWidth = window.innerWidth - padding

          // Calcula quantos cards cabem na tela (6 cards)
          const cardsVisible = Math.floor(viewportWidth / cardWidth)

          // Previne scroll excessivo
          const section = globalState.sectionsMovies.find(s => s.id === sectionId)
          const totalMovies = section?.movies.length || 0
          const totalWidth = totalMovies * cardWidth
          const maxScroll = Math.min(0, -(totalWidth - viewportWidth))

          // Se n√£o h√° necessidade de scroll (tudo cabe na tela), n√£o faz nada
          if (totalWidth <= viewportWidth) {
            console.log(`[SCROLL] Section ${sectionId}: n√£o precisa scroll (${totalMovies} cards cabem na tela)`)
            return state
          }

          // Scroll din√¢mico baseado em cards vis√≠veis (scroll de 1 p√°gina por vez)
          const scrollAmount = cardsVisible * cardWidth
          let newValue = currentMargin + (direction === 'left' ? -scrollAmount : scrollAmount)

          // Limita o scroll SEM loop circular (scroll normal)
          let finalValue = newValue
          if (direction === 'left') {
            // Scrollando para direita (mostrando mais filmes)
            finalValue = Math.max(newValue, maxScroll)
            console.log(`[SCROLL] Section ${sectionId}: scrollando √† direita, margin: ${finalValue}`)
          } else {
            // Scrollando para esquerda (voltando)
            finalValue = Math.min(newValue, 0)
            console.log(`[SCROLL] Section ${sectionId}: scrollando √† esquerda, margin: ${finalValue}`)
          }

          // console.log(`[SCROLL] Section ${sectionId}, dir: ${direction}, cardsVisible: ${cardsVisible}, scrollAmount: ${scrollAmount}px, margin: ${currentMargin} -> ${finalValue}, max: ${maxScroll}`)

          // ===== NOVO: Log do estado completo que ser√° retornado =====
          const newState = {
            ...state,
            [sectionId]: finalValue
          }
          // console.log(`[handleScrollMovies] ‚úÖ RETORNANDO novo estado:`, newState)

          // ===== DESABILITADO: N√£o atualizar featured movie durante scroll horizontal =====
          // Isso causava re-renders (piscadas) a cada clique na seta
          // O featured movie s√≥ muda ao trocar de categoria (teclas ‚Üë‚Üì)
          // if (section && section.movies.length > 0) {
          //   const centerPosition = Math.abs(finalValue) + (viewportWidth / 2)
          //   const centerMovieIndex = Math.floor(centerPosition / cardWidth)
          //   if (centerMovieIndex >= 0 && centerMovieIndex < section.movies.length) {
          //     const newFeaturedMovie = section.movies[centerMovieIndex]
          //     const newFeaturedId = newFeaturedMovie.stream_id || newFeaturedMovie.id
          //     if (newFeaturedId !== globalState.featuredMovieId) {
          //       window.updateNetflixMoviesState({ featuredMovieId: newFeaturedId })
          //     }
          //   }
          // }

          // ===== CORRIGIDO: Retornar o estado que j√° criamos =====
          return newState
        })
      }

      // COMPONENTE: Loading
      const Loading = () => {
        return e('div', {
          style: {
            display: 'flex',
            width: '100%',
            height: '100vh',
            background: '#111'
          }
        },
          e('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              margin: 'auto',
              width: '200px',
              height: '200px',
              position: 'relative'
            }
          },
            // Spinner
            e('span', {
              style: {
                position: 'absolute',
                top: '100px',
                left: '100px',
                transform: 'translate(-50%, -50%)',
                background: 'transparent',
                borderTop: '2px solid transparent',
                borderLeft: '2px solid #e50914',
                borderBottom: '2px solid transparent',
                borderRight: '2px solid transparent',
                borderRadius: '50%',
                width: '200px',
                height: '200px',
                transformOrigin: 'center center',
                animation: 'rotation 1s linear infinite'
              }
            }),
            // Letra N
            e('strong', {
              style: {
                color: '#e50914',
                fontSize: '70px',
                zIndex: 1
              }
            }, 'N')
          )
        )
      }

      // COMPONENTE: FeaturedMovie
      const FeaturedMovie = React.memo(({ featuredMovieId }) => {
        console.log('[FeaturedMovie] üé¨ Renderizado com featuredMovieId:', featuredMovieId)

        const [movie, setMovie] = useState(null)
        const [previousMovie, setPreviousMovie] = useState(null)
        const [showPrevious, setShowPrevious] = useState(false)
        const transitionTimeoutRef = useRef(null)
        const lastProcessedIdRef = useRef(null) // ===== NOVO: Evitar reprocessamento =====


        // Helper: Format runtime (minutes to "1h 33min")
        const formatRuntime = (minutes) => {
          if(!minutes) return null
          const h = Math.floor(minutes / 60)
          const m = minutes % 60
          return h > 0 ? `${h}h ${m}min` : `${m}min`
        }

        useEffect(() => {
          if(!featuredMovieId) return

          // ===== OTIMIZA√á√ÉO: Evitar loop de re-render =====
          if(lastProcessedIdRef.current === featuredMovieId) {
            console.log('[FeaturedMovie] ‚ö° ID j√° processado, ignorando:', featuredMovieId)
            return
          }
          lastProcessedIdRef.current = featuredMovieId

          // Buscar filme nas se√ß√µes
          console.log('[FeaturedMovie] üîç Buscando filme ID:', featuredMovieId, 'nas se√ß√µes:', globalState.sectionsMovies.length)
          let foundMovie = null
          for(let section of globalState.sectionsMovies){
            // ===== FIX: Buscar por series_id OU stream_id =====
            foundMovie = section.movies.find(m => (m.series_id || m.stream_id) === featuredMovieId)
            if(foundMovie) break
          }

          console.log('[FeaturedMovie] üéØ Filme encontrado:', foundMovie ? foundMovie.name : 'N√ÉO ENCONTRADO')

          if(foundMovie){
            // ===== FIX: Usar series_id para s√©ries, stream_id para filmes =====
            const movieId = foundMovie.series_id || foundMovie.stream_id

            // Verificar se j√° est√° no cache GLOBAL
            if(window.__enrichedMoviesCache[movieId]) {
              const cachedMovie = window.__enrichedMoviesCache[movieId]

              // ===== GUARD: Se √© o mesmo filme, N√ÉO atualizar (evita re-render) =====
              if(movie && movie.id === movieId) {
                console.log('[FeaturedMovie] ‚ö° Mesmo filme no cache, ignorando update:', foundMovie.name)
                return
              }

              console.log('[FeaturedMovie] ‚úÖ Crossfade para:', foundMovie.name)

              // ===== FIX: Preload da imagem antes de mostrar =====
              const preloadImage = (url) => {
                return new Promise((resolve) => {
                  if (!url) {
                    resolve();
                    return;
                  }
                  const img = new Image();
                  img.onload = () => {
                    console.log('[FeaturedMovie] üñºÔ∏è Imagem pr√©-carregada:', url);
                    resolve();
                  };
                  img.onerror = () => {
                    console.warn('[FeaturedMovie] ‚ö†Ô∏è Erro ao carregar imagem:', url);
                    resolve(); // Continua mesmo se falhar
                  };
                  img.src = url;
                });
              };

              // Preload imagem de forma async
              (async () => {
                await preloadImage(cachedMovie.imageUrl);

              // Guardar filme anterior para crossfade
              if(movie) {
                setPreviousMovie(movie)
                setShowPrevious(true)

                // Limpar timeouts anteriores
                if(transitionTimeoutRef.current) clearTimeout(transitionTimeoutRef.current)

                // Setar novo filme
                setMovie(cachedMovie)

                // Ap√≥s React renderizar, iniciar fade
                setTimeout(() => {
                  setShowPrevious(false)
                }, 50)

                // Limpar previousMovie ap√≥s transi√ß√£o completar
                transitionTimeoutRef.current = setTimeout(() => {
                  setPreviousMovie(null)
                }, 850) // 50ms + 800ms transition
              } else {
                // Primeiro filme, sem transi√ß√£o
                setMovie(cachedMovie)
              }
              })(); // Fechar async IIFE
              return
            }

            // Enriquecer este filme espec√≠fico com TMDB se ainda n√£o tiver dados
            const enrichAndSetMovie = async () => {
              let enrichedMovie = foundMovie

              // Se n√£o tem dados TMDB completos, buscar agora
              if(!foundMovie.tmdb_overview || !foundMovie.tmdb_genres) {
                const detectedType = foundMovie.series_id ? 'series' : 'movie'
                console.log(`[FeaturedMovie] üîç Enriquecendo com TMDB: ${foundMovie.name} (tipo: ${detectedType})`)
                enrichedMovie = await enrichMovieWithTMDB(foundMovie, detectedType)
              } else {
                console.log('[FeaturedMovie] ‚úÖ Filme j√° tem dados TMDB:', foundMovie.name)
              }

              console.log('[FeaturedMovie] üîç Dados enriquecidos:', {
                name: enrichedMovie.name,
                tmdb_backdrop: enrichedMovie.tmdb_backdrop,
                stream_icon: enrichedMovie.stream_icon,
                cover: enrichedMovie.cover,
                backdrop: enrichedMovie.backdrop,
                tmdb_poster: enrichedMovie.tmdb_poster,
                tmdb_overview: enrichedMovie.tmdb_overview,
                tmdb_genres: enrichedMovie.tmdb_genres
              })

              const movieData = {
                id: enrichedMovie.series_id || enrichedMovie.stream_id,
                name: enrichedMovie.name || enrichedMovie.title,
                // Prioridade: backdrop TMDB ‚Üí poster servidor ‚Üí backdrop servidor ‚Üí poster TMDB
                imageUrl: enrichedMovie.tmdb_backdrop ||
                          enrichedMovie.stream_icon || enrichedMovie.cover ||
                          enrichedMovie.backdrop_path || enrichedMovie.backdrop ||
                          enrichedMovie.tmdb_poster,
                rating: enrichedMovie.tmdb_rating ? (enrichedMovie.tmdb_rating * 10).toFixed(0) : '85',
                releaseDate: enrichedMovie.tmdb_year || enrichedMovie.year || '2024',
                runtime: enrichedMovie.tmdb_runtime || enrichedMovie.duration || '',
                overview: enrichedMovie.tmdb_overview || enrichedMovie.plot || enrichedMovie.description || 'Sem descri√ß√£o dispon√≠vel',
                genres: enrichedMovie.tmdb_genres || enrichedMovie.genre || 'Filme'
              }

              console.log('[FeaturedMovie] üì¶ movieData final imageUrl:', movieData.imageUrl)

              // Armazenar no cache GLOBAL
              window.__enrichedMoviesCache[movieId] = movieData
              console.log('[FeaturedMovie] üíæ Armazenado no cache:', foundMovie.name)

              // Guardar filme anterior para crossfade
              if(movie) {
                setPreviousMovie(movie)
                setShowPrevious(true)

                // Limpar timeouts anteriores
                if(transitionTimeoutRef.current) clearTimeout(transitionTimeoutRef.current)

                // Setar novo filme
                setMovie(movieData)

                // Ap√≥s React renderizar, iniciar fade
                setTimeout(() => {
                  setShowPrevious(false)
                }, 50)

                // Limpar previousMovie ap√≥s transi√ß√£o completar
                transitionTimeoutRef.current = setTimeout(() => {
                  setPreviousMovie(null)
                }, 850)
              } else {
                // Primeiro filme, sem transi√ß√£o
                setMovie(movieData)
              }
            }

            enrichAndSetMovie()
          }
        }, [featuredMovieId])

        // IMPORTANTE: Sempre mostrar algo, nunca retornar null
        const displayMovie = movie || previousMovie
        if(!displayMovie || !displayMovie.id) return null

        return e('div', {
          style: {
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            width: '100%',
            overflow: 'hidden'
          }
        },
          // Previous background (fades out)
          previousMovie && e('div', {
            style: {
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundImage: previousMovie.imageUrl ? `url(${previousMovie.imageUrl})` : 'linear-gradient(to bottom, #111, #000)',
              backgroundSize: 'cover',
              backgroundPosition: '50% 0%',
              opacity: showPrevious ? 1 : 0,
              transition: 'opacity 0.8s ease-in-out',
              zIndex: 1
            }
          }),
          // Current background (fades in)
          movie && e('div', {
            style: {
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              // ===== FIX: Background s√≥lido escuro para evitar piscar branco =====
              backgroundColor: '#0a0a0a',
              backgroundImage: movie.imageUrl ? `url(${movie.imageUrl})` : 'linear-gradient(to bottom, #111, #000)',
              backgroundSize: 'cover',
              backgroundPosition: '50% 0%',
              opacity: showPrevious ? 0 : 1,
              transition: 'opacity 0.8s ease-in-out',
              zIndex: 2
            }
          }),
          // Container for gradient and content
          e('div', {
            style: {
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              zIndex: 3
            }
          },
            // Gradient overlay
            e('div', {
              style: {
                width: '100%',
                height: '100%',
                background: 'linear-gradient(to top, #111 25%, transparent 60%)'
              }
            },
              // Content com transi√ß√£o suave
              e('div', {
                style: {
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'flex-start',
                  justifyContent: 'flex-start', // Alinha no topo
                  padding: '20px 40px 0 40px', // Padding m√≠nimo no topo
                  width: '100%',
                  height: '100%',
                  background: 'linear-gradient(to right, rgba(0,0,0,0.6) 40%, transparent 60%)'
                }
              },
                // Title
                e('h1', {
                  style: {
                    fontSize: '42px',
                    marginBottom: '12px',
                    marginTop: '0',
                    color: '#fff',
                    fontWeight: 'bold',
                    textShadow: '2px 2px 8px rgba(0,0,0,0.8)',
                    maxWidth: '650px',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap'
                  }
                }, displayMovie.name || displayMovie.title),

                // MovieInfo (rating, year, runtime) - usa dados do TMDB quando dispon√≠vel
                e('div', {
                  style: {
                    display: 'flex',
                    flexDirection: 'row',
                    alignItems: 'center',
                    marginBottom: '10px',
                    gap: '12px'
                  }
                },
                  // Rating TMDB
                  (displayMovie.tmdb_rating || displayMovie.rating) && e('span', {
                    style: {
                      fontSize: '17px',
                      color: '#46d369',
                      fontWeight: 700
                    }
                  }, displayMovie.tmdb_rating ? `‚≠ê ${(displayMovie.tmdb_rating * 10).toFixed(0)}%` : `${displayMovie.rating}% relevante`),

                  // Ano
                  (displayMovie.tmdb_year || displayMovie.releaseDate) && e('span', {
                    style: {
                      fontSize: '17px',
                      color: '#fff'
                    }
                  }, displayMovie.tmdb_year || displayMovie.releaseDate),

                  // Runtime
                  (displayMovie.tmdb_runtime || displayMovie.runtime) && e('span', {
                    style: {
                      fontSize: '17px',
                      color: '#fff'
                    }
                  }, typeof (displayMovie.tmdb_runtime || displayMovie.runtime) === 'number'
                    ? formatRuntime(displayMovie.tmdb_runtime || displayMovie.runtime)
                    : (displayMovie.tmdb_runtime || displayMovie.runtime))
                ),

                // Overview (descri√ß√£o do TMDB √© priorizada)
                e('p', {
                  style: {
                    width: '650px',
                    fontSize: '17px',
                    lineHeight: '1.5',
                    textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                    marginBottom: '10px',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    display: '-webkit-box',
                    WebkitLineClamp: '3',
                    WebkitBoxOrient: 'vertical',
                    color: '#fff'
                  }
                }, displayMovie.tmdb_overview || displayMovie.overview),

                // Genres (prioriza TMDB)
                (displayMovie.tmdb_genres || displayMovie.genres) && e('span', {
                  style: {
                    fontSize: '15px',
                    color: '#ccc',
                    marginBottom: '12px',
                    fontWeight: '500'
                  }
                }, 'üé≠ ', displayMovie.tmdb_genres || displayMovie.genres),

                // Buttons
                e('div', {
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '10px'
                  }
                },
                  // Play button
                  e('a', {
                    href: '#',
                    onClick: (ev) => {
                      ev.preventDefault()
                      const foundMovie = globalState.sectionsMovies.flatMap(s => s.movies).find(m => m.stream_id === globalState.featuredMovieId)
                      if(foundMovie){
                        setView('player')
                        setCurrent({
                          name: foundMovie.name || foundMovie.title,
                          url: buildURL(cfg.server, ['movie', cfg.username, cfg.password, `${foundMovie.stream_id}.${foundMovie.container_extension || 'mp4'}`])
                        })
                      }
                    },
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      padding: '9px 24px',
                      borderRadius: '5px',
                      cursor: 'pointer',
                      textDecoration: 'none',
                      fontSize: '20px',
                      background: '#fff',
                      color: '#000',
                      border: 'none',
                      fontWeight: '600'
                    }
                  }, '‚ñ∂ Assistir'),

                  // More info button
                  e('a', {
                    href: '#',
                    onClick: (ev) => {
                      ev.preventDefault()
                      setView('home')
                    },
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      padding: '9px 24px',
                      borderRadius: '5px',
                      cursor: 'pointer',
                      textDecoration: 'none',
                      fontSize: '20px',
                      background: 'rgba(109,109,110,0.7)',
                      color: '#fff',
                      fontWeight: '600'
                    }
                  }, '‚ÑπÔ∏è Voltar')
                )
              )
            )
          )
        )
      }, (prevProps, nextProps) => {
        // Custom comparison: s√≥ re-render se featuredMovieId mudar
        return prevProps.featuredMovieId === nextProps.featuredMovieId
      })

      // COMPONENTE: CollectionCard (Card de cole√ß√£o para carrossel horizontal)
      const CollectionCard = React.memo(({ collection, onClick, sectionId, idx }) => {
        const [isHovered, setIsHovered] = useState(false)
        const isHoveredRef = useRef(false)
        const [fullCollection, setFullCollection] = useState(collection.overview ? collection : null)
        const [isLoading, setIsLoading] = useState(false)
        const hasEnrichedRef = useRef(false)

        // Sincronizar com a prop collection quando ela muda (j√° vem enriquecida)
        useEffect(() => {
          if (collection.overview && !fullCollection?.overview) {
            setFullCollection(collection)
            hasEnrichedRef.current = true
          }
        }, [collection.id])

        // Buscar detalhes completos da cole√ß√£o ao passar o mouse (s√≥ se n√£o tiver overview)
        useEffect(() => {
          if (isHovered && !hasEnrichedRef.current && !fullCollection?.overview && !isLoading) {
            hasEnrichedRef.current = true
            setIsLoading(true)
            getTMDBCollection(collection.id).then(data => {
              if(data) {
                setFullCollection(data)
              }
              setIsLoading(false)
            }).catch(() => {
              setIsLoading(false)
              hasEnrichedRef.current = false // Reset para tentar novamente
            })
          }
        }, [isHovered, collection.id])

        // Fun√ß√£o DESABILITADA para evitar flickering
        // (A atualiza√ß√£o do backdrop causava forceUpdate que re-renderizava tudo)
        const updateHeroBackdropFromCollection = async (coll) => {
          // Desabilitado - n√£o faz nada
          return
        }

        const displayCollection = fullCollection || collection
        const movieCount = collection.movies.length

        return e('div', {
          style: {
            flexShrink: 0,
            width: '260px',
            height: '390px',
            marginRight: '20px',
            position: 'relative',
            borderRadius: '8px',
            overflow: 'visible',
            cursor: 'pointer',
            transform: isHovered ? 'scale(1.15)' : 'scale(1)',
            transformOrigin: 'center center',
            transition: 'all 0.3s ease-out',
            boxShadow: isHovered ? '0 12px 32px rgba(0,0,0,0.9)' : '0 2px 8px rgba(0,0,0,0.3)',
            zIndex: isHovered ? 999999 : 'auto'
          },
          onMouseEnter: () => {
            isHoveredRef.current = true
            setIsHovered(true)
          },
          onMouseLeave: () => {
            isHoveredRef.current = false
            setIsHovered(false)
          },
          onClick: () => onClick(displayCollection, collection.movies)
        },
          // Poster/Backdrop
          e('img', {
            src: displayCollection.poster || displayCollection.backdrop || '',
            alt: displayCollection.name,
            loading: 'lazy',
            style: {
              width: '100%',
              height: '100%',
              objectFit: 'cover',
              filter: isHovered ? 'brightness(0.4)' : 'brightness(1)',
              transition: 'filter 0.3s ease',
              pointerEvents: 'none',
              borderRadius: '8px'
            }
          }),

          // Overlay com informa√ß√µes (aparece no hover)
          isHovered && e('div', {
            style: {
              position: 'absolute',
              top: '0',
              left: '0',
              width: '100%',
              height: '100%',
              background: 'rgba(0, 0, 0, 0.85)',
              backdropFilter: 'blur(6px)',
              WebkitBackdropFilter: 'blur(6px)',
              opacity: 1,
              transition: 'all 0.3s ease',
              padding: '14px 12px',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'flex-start',
              gap: '8px',
              pointerEvents: 'none',
              zIndex: 2,
              borderRadius: '8px'
            }
          },
            // T√≠tulo no topo
            e('div', {
              style: {
                fontSize: '15px',
                fontWeight: 'bold',
                color: '#fff',
                lineHeight: '1.2',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                display: '-webkit-box',
                WebkitLineClamp: '2',
                WebkitBoxOrient: 'vertical',
                marginBottom: '4px'
              }
            }, displayCollection.name),

            // Contador de filmes
            e('div', {
              style: {
                fontSize: '12px',
                color: '#4ade80',
                fontWeight: '600',
                marginBottom: '6px'
              }
            }, `üìö ${movieCount} ${movieCount === 1 ? 'filme' : 'filmes'}`),

            // Overview da cole√ß√£o (se dispon√≠vel)
            displayCollection.overview && e('p', {
              style: {
                fontSize: '11px',
                color: '#ccc',
                lineHeight: '1.4',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                display: '-webkit-box',
                WebkitLineClamp: '4',
                WebkitBoxOrient: 'vertical',
                marginBottom: 'auto',
                flex: '1'
              }
            }, displayCollection.overview),

            // Bot√£o visual (fixo no bottom)
            e('div', {
              style: {
                background: '#fff',
                color: '#000',
                padding: '8px 14px',
                borderRadius: '4px',
                fontSize: '13px',
                fontWeight: 'bold',
                textAlign: 'center',
                pointerEvents: 'auto',
                marginTop: '8px'
              }
            }, '‚ñ∂ Ver Cole√ß√£o')
          )
        )
      }, (prevProps, nextProps) => {
        // Custom comparison: s√≥ re-render se collection.id mudar
        return prevProps.collection.id === nextProps.collection.id &&
               prevProps.sectionId === nextProps.sectionId &&
               prevProps.idx === nextProps.idx
      })

      // COMPONENTE: Movie (Card individual) - PART 2: Enhanced hover with TMDB data
      const Movie = React.memo(({ movie, sectionId, idx }) => {
        const [isHovered, setIsHovered] = useState(false)
        const isHoveredRef = useRef(false) // Mant√©m estado durante re-renders
        const [enrichedMovie, setEnrichedMovie] = useState(movie)
        // Estados para trailer DENTRO do card (estilo Netflix)
        const [showTrailerInCard, setShowTrailerInCard] = useState(false)
        const [cardTrailerUrl, setCardTrailerUrl] = useState(null)
        const [isMuted, setIsMuted] = useState(false)
        const trailerContainerRef = useRef(null)
        const cardRef = useRef(null)
        // isFocused removido - apenas hover do mouse ativa o efeito

        // Sincronizar enrichedMovie com prop movie quando ela muda (j√° vem enriquecida do initMovies)
        useEffect(() => {
          if (movie.tmdb_rating && !enrichedMovie.tmdb_rating) {
            setEnrichedMovie(movie)
          }
        }, [movie.stream_id])

        // ===== AUTO-ENRIQUECIMENTO: Se o filme n√£o tem dados TMDB, buscar automaticamente =====
        useEffect(() => {
          if (!movie.tmdb_poster && !movie.tmdb_overview && movie.stream_id) {
            const detectedType = movie.series_id ? 'series' : 'movie'
            console.log(`[Movie] üîÑ Auto-enriquecendo "${movie.name}" (tipo: ${detectedType})...`)
            enrichMovieWithTMDB(movie, detectedType).then(enriched => {
              setEnrichedMovie(enriched)
              console.log(`[Movie] ‚úÖ "${movie.name}" enriquecido`)
            }).catch(err => {
              console.warn(`[Movie] ‚ö†Ô∏è Erro ao enriquecer "${movie.name}":`, err)
            })
          }
        }, [movie.stream_id])

        // Buscar e mostrar trailer DENTRO DO CARD (estilo Netflix)
        // ===== OTIMIZA√á√ÉO: Usar ref para evitar recria√ß√µes desnecess√°rias do timer =====
        const tmdbIdRef = useRef(enrichedMovie.tmdb_id)
        useEffect(() => {
          tmdbIdRef.current = enrichedMovie.tmdb_id
        }, [enrichedMovie.tmdb_id])

        useEffect(() => {
          let timeoutId = null

          if (isHoveredRef.current && tmdbIdRef.current) {
            // Delay de 1500ms (1.5s) como Netflix
            timeoutId = setTimeout(async () => {
              if (isHoveredRef.current) {
                const trailerUrl = await getTMDBTrailer(tmdbIdRef.current, 'movie')
                if (trailerUrl && isHoveredRef.current) {
                  console.log('[Movie] ‚úÖ Mostrando trailer no card')
                  setCardTrailerUrl(trailerUrl)
                  setShowTrailerInCard(true)
                }
              }
            }, 1500)
          } else if (!isHoveredRef.current) {
            // Limpar trailer quando sair do hover
            setShowTrailerInCard(false)
            setCardTrailerUrl(null)
            setIsMuted(false)
          }

          return () => {
            if (timeoutId) {
              clearTimeout(timeoutId)
              // console.log('[Movie] ‚èπÔ∏è Timer de trailer cancelado')
            }
          }
        }, [isHovered])

        // Helper: Format runtime (minutes to "1h 33min")
        const formatRuntime = (minutes) => {
          if(!minutes) return null
          const h = Math.floor(minutes / 60)
          const m = minutes % 60
          return h > 0 ? `${h}h ${m}min` : `${m}min`
        }

        return e('div', {
          ref: cardRef,
          id: `movie-${sectionId}-${idx}`,
          style: {
            flexShrink: 0,
            width: '260px',
            height: '390px',
            marginRight: '20px',
            position: 'relative',
            zIndex: isHovered ? 999999 : 'auto',
            cursor: 'pointer',
            borderRadius: '8px',
            overflow: 'visible',
            transform: isHovered ? 'scale(1.15)' : 'scale(1)',
            transformOrigin: 'center center',
            boxShadow: isHovered ? '0 12px 32px rgba(0,0,0,0.9)' : '0 2px 8px rgba(0,0,0,0.3)',
            transition: 'transform 0.3s ease-out, box-shadow 0.3s ease-out, z-index 0s',
            willChange: 'transform' // Otimiza√ß√£o para GPU
          },
          onClick: async (e) => {
            e.stopPropagation()

            // ===== NAVEGAR PARA P√ÅGINA DE DETALHES =====
            console.log('üé¨ Abrindo detalhes:', movie.name || movie.title)
            console.log('üì¶ Dados originais do movie:', movie)
            console.log('üì¶ Dados enriquecidos enrichedMovie:', enrichedMovie)

            // Preparar dados enriquecidos para p√°gina de detalhes
            const contentData = {
              ...enrichedMovie,
              ...movie,
              series_id: isSeriesMode ? (movie.series_id || movie.stream_id || movie.id) : null,
              stream_id: movie.stream_id || movie.id
            }

            console.log('üì¶ contentData FINAL que vai para SerieDetails:', contentData)

            // Se for s√©rie, buscar info adicional da API (epis√≥dios, temporadas)
            if (isSeriesMode) {
              try {
                const seriesId = movie.series_id || movie.stream_id || movie.id
                const seriesInfo = await apiCall('get_series_info', { series_id: seriesId })

                // Contar epis√≥dios e temporadas
                const seasons = seriesInfo.episodes || {}
                const seasonsCount = Object.keys(seasons).length
                let episodesCount = 0
                Object.values(seasons).forEach(seasonEps => {
                  if (Array.isArray(seasonEps)) episodesCount += seasonEps.length
                })

                contentData.episodes_count = episodesCount
                contentData.seasons_count = seasonsCount
                contentData.seriesInfo = seriesInfo // Guardar para uso posterior
              } catch(err) {
                console.error('Erro ao buscar info da s√©rie:', err)
              }
            }

            // Navegar para p√°gina de detalhes
            setSelectedContent(contentData)
            setView('serie-details')
          },
          onMouseEnter: () => {
            // Ao passar o mouse, atualiza backdrop (APENAS SE MUDOU)
            const movieId = movie.series_id || movie.stream_id || movie.id

            // ‚úÖ OTIMIZA√á√ÉO: S√≥ atualiza se for um filme DIFERENTE
            if (window.__netflixMoviesState?.featuredMovieId !== movieId) {
              if (window.updateNetflixMoviesState) {
                window.updateNetflixMoviesState({ featuredMovieId: movieId })
              }
            }

            isHoveredRef.current = true
            setIsHovered(true)
          },
          onMouseLeave: () => {
            isHoveredRef.current = false
            setIsHovered(false)
          }
        },
          // Poster ou placeholder (sempre vis√≠vel, mas escurecido no hover)
          (enrichedMovie.stream_icon || enrichedMovie.cover || enrichedMovie.tmdb_poster)
            ? e('img', {
                src: enrichedMovie.stream_icon || enrichedMovie.cover || enrichedMovie.tmdb_poster,
                alt: `Capa do filme ${enrichedMovie.name || enrichedMovie.title}`,
                loading: 'lazy',
                style: {
                  width: '100%',
                  height: '100%',
                  objectFit: 'cover',
                  display: 'block',
                  filter: isHovered ? 'brightness(0.4)' : 'brightness(1)',
                  transition: 'filter 0.3s ease',
                  pointerEvents: 'none',
                  borderRadius: '8px'
                }
              })
            : e('div', {
                style: {
                  width: '100%',
                  height: '100%',
                  background: 'linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  flexDirection: 'column',
                  gap: '10px',
                  borderRadius: '8px',
                  filter: isHovered ? 'brightness(0.4)' : 'brightness(1)',
                  transition: 'filter 0.3s ease'
                }
              },
                e('div', {
                  style: {
                    width: '60px',
                    height: '60px',
                    border: '4px solid rgba(244, 117, 33, 0.3)',
                    borderTop: '4px solid #f47521',
                    borderRadius: '50%',
                    animation: 'spin 1s linear infinite'
                  }
                }),
                e('div', {
                  style: {
                    color: '#888',
                    fontSize: '12px',
                    textAlign: 'center',
                    padding: '0 20px'
                  }
                }, 'Carregando...')
              ),

          // Badge "L" para legendado
          enrichedMovie.isLegendado && e('span', {
            className: 'lang-badge'
          }, 'L'),

          // Trailer NO TOPO do card (estilo Netflix)
          showTrailerInCard && cardTrailerUrl && e('div', {
            ref: trailerContainerRef,
            onClick: (ev) => {
              ev.stopPropagation()
              // Abrir em tela cheia
              const elem = trailerContainerRef.current
              if (elem) {
                if (elem.requestFullscreen) {
                  elem.requestFullscreen()
                } else if (elem.webkitRequestFullscreen) {
                  elem.webkitRequestFullscreen()
                } else if (elem.mozRequestFullScreen) {
                  elem.mozRequestFullScreen()
                } else if (elem.msRequestFullscreen) {
                  elem.msRequestFullscreen()
                }
              }
            },
            style: {
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '60%',
              overflow: 'hidden',
              zIndex: 1,
              cursor: 'pointer',
              backgroundColor: '#000'
            }
          },
            e('iframe', {
              src: cardTrailerUrl + `?autoplay=1&mute=${isMuted ? 1 : 0}&controls=1&rel=0&modestbranding=1&loop=1&playlist=` + cardTrailerUrl.split('/embed/')[1],
              allow: 'autoplay; encrypted-media; fullscreen',
              allowFullScreen: true,
              style: {
                width: '100%',
                height: '100%',
                border: 'none'
              }
            })
          ),

          // Overlay com informa√ß√µes (se tem trailer, fica embaixo; se n√£o, cobre tudo)
          isHovered && e('div', {
              onClick: async (ev) => {
                ev.stopPropagation()

                // ===== NAVEGAR PARA P√ÅGINA DE DETALHES (mesmo c√≥digo do onClick principal) =====
                console.log('üé¨ Abrindo detalhes (via overlay):', movie.name || movie.title)
                console.log('üì¶ [OVERLAY] Dados originais do movie:', movie)
                console.log('üì¶ [OVERLAY] Dados enriquecidos enrichedMovie:', enrichedMovie)

                const contentData = {
                  ...enrichedMovie,
                  ...movie,
                  series_id: isSeriesMode ? (movie.series_id || movie.stream_id || movie.id) : null,
                  stream_id: movie.stream_id || movie.id
                }

                console.log('üì¶ [OVERLAY] contentData FINAL que vai para SerieDetails:', contentData)

                if (isSeriesMode) {
                  try {
                    const seriesId = movie.series_id || movie.stream_id || movie.id
                    const seriesInfo = await apiCall('get_series_info', { series_id: seriesId })

                    const seasons = seriesInfo.episodes || {}
                    const seasonsCount = Object.keys(seasons).length
                    let episodesCount = 0
                    Object.values(seasons).forEach(seasonEps => {
                      if (Array.isArray(seasonEps)) episodesCount += seasonEps.length
                    })

                    contentData.episodes_count = episodesCount
                    contentData.seasons_count = seasonsCount
                    contentData.seriesInfo = seriesInfo
                  } catch(err) {
                    console.error('Erro ao buscar info da s√©rie:', err)
                  }
                }

                setSelectedContent(contentData)
                setView('serie-details')
              },
              style: {
                position: 'absolute',
                top: showTrailerInCard ? '60%' : '0',
                left: '0',
                width: '100%',
                height: showTrailerInCard ? '40%' : '100%',
                background: 'rgba(0, 0, 0, 0.85)',
                backdropFilter: 'blur(6px)',
                WebkitBackdropFilter: 'blur(6px)',
                opacity: 1,
                transition: 'opacity 0.2s ease, top 0.3s ease, height 0.3s ease',
                padding: showTrailerInCard ? '8px 12px' : '16px 12px 12px 12px',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'space-between',
                cursor: 'pointer', // ===== ADICIONADO: mostrar que √© clic√°vel =====
                pointerEvents: 'auto', // ===== CORRIGIDO: auto para permitir cliques nos bot√µes =====
                zIndex: 2,
                willChange: 'opacity, top, height' // Otimiza√ß√£o GPU
              }
            },
              // T√≠tulo no topo
              e('div', {
                style: {
                  fontSize: '14px',
                  fontWeight: 'bold',
                  color: '#fff',
                  lineHeight: '1.2',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  display: '-webkit-box',
                  WebkitLineClamp: '2',
                  WebkitBoxOrient: 'vertical',
                  pointerEvents: 'none' // Texto n√£o deve capturar cliques
                }
              }, `${enrichedMovie.name || enrichedMovie.title}${enrichedMovie.tmdb_year ? ` (${enrichedMovie.tmdb_year})` : ''}`),

              // Informa√ß√µes + Bot√µes na parte inferior
              e('div', {
                style: {
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '8px'
                }
              },
                // Porcentagem de relev√¢ncia + Metadados em linha
                e('div', {
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px',
                    fontSize: '11px',
                    color: '#ddd',
                    flexWrap: 'wrap',
                    pointerEvents: 'none' // Metadados n√£o devem capturar cliques
                  }
                },
                  // Porcentagem (vote_average * 10)
                  enrichedMovie.tmdb_rating && e('span', {
                    style: {
                      fontWeight: 'bold',
                      color: '#f47521',
                      background: 'rgba(244, 117, 33, 0.15)',
                      padding: '2px 6px',
                      borderRadius: '4px'
                    }
                  }, `${(enrichedMovie.tmdb_rating * 10).toFixed(0)}%`),

                  // Nota (com quantidade de votos)
                  enrichedMovie.tmdb_rating && e('span', {
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      gap: '3px'
                    },
                    title: enrichedMovie.tmdb_vote_count ? `${enrichedMovie.tmdb_vote_count.toLocaleString()} votos` : ''
                  },
                    e('span', null, '‚≠ê'),
                    e('span', { style: { fontWeight: '600' } }, enrichedMovie.tmdb_rating.toFixed(1)),
                    enrichedMovie.tmdb_vote_count && enrichedMovie.tmdb_vote_count > 1000 && e('span', {
                      style: {
                        fontSize: '9px',
                        opacity: 0.7,
                        marginLeft: '-1px'
                      }
                    }, `(${(enrichedMovie.tmdb_vote_count / 1000).toFixed(1)}k)`)
                  ),

                  // Tempo
                  enrichedMovie.tmdb_runtime && formatRuntime(enrichedMovie.tmdb_runtime) && e('span', {
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      gap: '3px'
                    }
                  },
                    e('span', null, '‚è±'),
                    e('span', null, formatRuntime(enrichedMovie.tmdb_runtime))
                  ),

                  // G√™nero
                  enrichedMovie.tmdb_genres && e('span', {
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      gap: '3px',
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      whiteSpace: 'nowrap',
                      maxWidth: '80px'
                    }
                  },
                    e('span', null, 'üé≠'),
                    e('span', null, enrichedMovie.tmdb_genres.split(', ')[0])
                  ),

                  // ===== NOVO: Idioma original (se diferente de PT/EN) =====
                  enrichedMovie.tmdb_language && !['PT', 'EN'].includes(enrichedMovie.tmdb_language) && e('span', {
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      gap: '3px',
                      background: 'rgba(59, 130, 246, 0.2)',
                      padding: '2px 6px',
                      borderRadius: '3px',
                      fontSize: '10px'
                    },
                    title: 'Idioma original'
                  },
                    e('span', null, 'üåç'),
                    e('span', null, enrichedMovie.tmdb_language)
                  )
                ),

                // Sinopse melhorada - 5 linhas com expans√£o no hover
                enrichedMovie.tmdb_overview && e('div', {
                  style: {
                    fontSize: '1.05rem',
                    color: '#fff',
                    lineHeight: '1.5',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    display: '-webkit-box',
                    WebkitLineClamp: isHovered ? '8' : '3',
                    WebkitBoxOrient: 'vertical',
                    marginTop: '8px',
                    maxHeight: isHovered ? '150px' : '80px',
                    transition: 'max-height 0.3s ease, -webkit-line-clamp 0.3s ease',
                    textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
                    pointerEvents: 'none' // Sinopse n√£o deve capturar cliques
                  }
                }, enrichedMovie.tmdb_overview),

                // ===== NOVO: Elenco e Diretor =====
                isHovered && (enrichedMovie.tmdb_cast || enrichedMovie.tmdb_director) && e('div', {
                  style: {
                    fontSize: '10px',
                    color: '#bbb',
                    marginTop: '6px',
                    lineHeight: '1.3',
                    pointerEvents: 'none'
                  }
                },
                  enrichedMovie.tmdb_director && e('div', null,
                    e('span', { style: { color: '#f47521', fontWeight: 'bold' } }, 'üé¨ '),
                    enrichedMovie.tmdb_director
                  ),
                  enrichedMovie.tmdb_cast && e('div', {
                    style: {
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      whiteSpace: 'nowrap',
                      marginTop: '2px'
                    }
                  },
                    e('span', { style: { color: '#f47521', fontWeight: 'bold' } }, 'üë• '),
                    enrichedMovie.tmdb_cast
                  )
                ),

                // Action buttons row - Estilo Crunchyroll mais compacto
                e('div', {
                  style: {
                    display: 'flex',
                    gap: '6px',
                    alignItems: 'center'
                  }
                },
                // Play button - Destaque laranja estilo Crunchyroll
                e('button', {
                  type: 'button',
                  onClick: async (ev) => {
                    ev.stopPropagation()
                    console.log('üé¨ Iniciando filme via bot√£o Play:', movie.name || movie.title)

                    try {
                      const id = movie.stream_id || movie.id
                      const ext = (movie.container_extension || 'mp4').replace(/\.+/,'')
                      const url = buildURL(cfg.server, ['movie', cfg.username, cfg.password, id + '.' + ext])
                      const isHls = /m3u8/i.test(ext)

                      setCurrent({ name: movie.name || movie.title || 'Filme', url, isHls })
                      setView('player')
                    } catch(err) {
                      console.error('Erro ao iniciar filme:', err)
                    }
                  },
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    background: '#f47521',
                    color: '#fff',
                    fontWeight: 'bold',
                    fontSize: '14px',
                    borderRadius: '50%',
                    height: '32px',
                    width: '32px',
                    border: 0,
                    cursor: 'pointer',
                    transition: 'all 0.2s',
                    boxShadow: '0 2px 8px rgba(244, 117, 33, 0.4)',
                    pointerEvents: 'auto'
                  },
                  onMouseEnter: (ev) => {
                    ev.target.style.transform = 'scale(1.15)'
                    ev.target.style.background = '#ff8c42'
                  },
                  onMouseLeave: (ev) => {
                    ev.target.style.transform = 'scale(1)'
                    ev.target.style.background = '#f47521'
                  }
                }, '‚ñ∂'),

                // Add button
                e('button', {
                  type: 'button',
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: '#fff',
                    height: '32px',
                    width: '32px',
                    borderRadius: '50%',
                    border: '2px solid rgba(255,255,255,0.5)',
                    background: 'rgba(0,0,0,0.6)',
                    cursor: 'pointer',
                    fontSize: '18px',
                    transition: 'all 0.2s',
                    pointerEvents: 'auto'
                  },
                  onMouseEnter: (ev) => {
                    ev.target.style.borderColor = '#fff'
                    ev.target.style.background = 'rgba(255,255,255,0.2)'
                    ev.target.style.transform = 'scale(1.15)'
                  },
                  onMouseLeave: (ev) => {
                    ev.target.style.borderColor = 'rgba(255,255,255,0.5)'
                    ev.target.style.background = 'rgba(0,0,0,0.6)'
                    ev.target.style.transform = 'scale(1)'
                  }
                }, '+'),

                // Trailer button (üé¨)
                e('button', {
                  type: 'button',
                  onClick: async () => {
                    if(enrichedMovie.tmdb_id) {
                      const trailerUrl = await getTMDBTrailer(enrichedMovie.tmdb_id, 'movie')
                      if(trailerUrl) {
                        setTrailerUrl(trailerUrl)
                        setShowTrailerModal(true)
                      } else {
                        setToast('‚ùå Trailer n√£o dispon√≠vel')
                        setTimeout(() => setToast(null), 3000)
                      }
                    }
                  },
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: '#fff',
                    height: '32px',
                    width: '32px',
                    borderRadius: '50%',
                    border: '2px solid rgba(255,255,255,0.5)',
                    background: 'rgba(0,0,0,0.6)',
                    cursor: 'pointer',
                    fontSize: '16px',
                    transition: 'all 0.2s',
                    pointerEvents: 'auto'
                  },
                  onMouseEnter: (ev) => {
                    ev.target.style.borderColor = '#e50914'
                    ev.target.style.color = '#e50914'
                    ev.target.style.background = 'rgba(229,9,20,0.2)'
                    ev.target.style.transform = 'scale(1.15)'
                  },
                  onMouseLeave: (ev) => {
                    ev.target.style.borderColor = 'rgba(255,255,255,0.5)'
                    ev.target.style.color = '#fff'
                    ev.target.style.background = 'rgba(0,0,0,0.6)'
                    ev.target.style.transform = 'scale(1)'
                  }
                }, 'üé¨'),

                // Favorite button (estrela)
                e('button', {
                  type: 'button',
                  style: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: '#fff',
                    height: '32px',
                    width: '32px',
                    borderRadius: '50%',
                    border: '2px solid rgba(255,255,255,0.5)',
                    background: 'rgba(0,0,0,0.6)',
                    cursor: 'pointer',
                    fontSize: '16px',
                    transition: 'all 0.2s',
                    pointerEvents: 'auto'
                  },
                  onMouseEnter: (ev) => {
                    ev.target.style.borderColor = '#ffd700'
                    ev.target.style.color = '#ffd700'
                    ev.target.style.background = 'rgba(255,215,0,0.2)'
                    ev.target.style.transform = 'scale(1.15)'
                  },
                  onMouseLeave: (ev) => {
                    ev.target.style.borderColor = 'rgba(255,255,255,0.5)'
                    ev.target.style.color = '#fff'
                    ev.target.style.background = 'rgba(0,0,0,0.6)'
                    ev.target.style.transform = 'scale(1)'
                  }
                }, '‚≠ê')
              )
            ) // End informa√ß√µes + bot√µes container
          ), // End overlay div

          // Bot√£o Mute/Unmute no canto do TRAILER (estilo Netflix)
          showTrailerInCard && e('button', {
            onClick: (ev) => {
              ev.stopPropagation()
              setIsMuted(!isMuted)
            },
            style: {
              position: 'absolute',
              top: '10px',
              right: '10px',
              width: '32px',
              height: '32px',
              borderRadius: '50%',
              border: '2px solid rgba(255,255,255,0.9)',
              background: 'rgba(0,0,0,0.7)',
              color: '#fff',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '14px',
              zIndex: 999999,
              pointerEvents: 'auto',
              transition: 'all 0.2s',
              boxShadow: '0 2px 8px rgba(0,0,0,0.4)'
            },
            onMouseEnter: (ev) => {
              ev.target.style.background = 'rgba(255,255,255,0.95)'
              ev.target.style.color = '#000'
              ev.target.style.transform = 'scale(1.1)'
            },
            onMouseLeave: (ev) => {
              ev.target.style.background = 'rgba(0,0,0,0.7)'
              ev.target.style.color = '#fff'
              ev.target.style.transform = 'scale(1)'
            }
          }, isMuted ? 'üîá' : 'üîä')
        ) // End card container
      }, (prevProps, nextProps) => {
        // Custom comparison: s√≥ re-render se movie.stream_id mudar
        return prevProps.movie.stream_id === nextProps.movie.stream_id &&
               prevProps.sectionId === nextProps.sectionId &&
               prevProps.idx === nextProps.idx
      })

      // COMPONENTE: CollectionsGrid (Grade de cole√ß√µes)
      // COMPONENTE: SectionMovies
      const SectionMovies = ({ name, movies, sectionId, categoryIndex, totalCategories, onNextCategory, onPrevCategory, isCollectionsMode }) => {
        // ===== STATE LOCAL apenas para currentMargin (para atualizar bot√µes) =====
        const [currentMargin, setCurrentMargin] = useState(marginContentRef.current[sectionId] || 0)
        const marginRef = useRef(currentMargin)
        const [visibleCount, setVisibleCount] = useState(30) // ===== AUMENTADO: 30 filmes iniciais =====
        const [hovering, setHovering] = useState(false)
        const [hoveringLeft, setHoveringLeft] = useState(false)
        const [hoveringRight, setHoveringRight] = useState(false)
        const verticalScrollTimeoutRef = useRef(null)

        // ===== Registrar listener para receber atualiza√ß√µes de margin =====
        useEffect(() => {
          const unregister = registerMarginListener(sectionId, (newMargin) => {
            setCurrentMargin(newMargin)
          })
          return unregister
        }, [sectionId])

        // ===== NOVO: Rastrear mudan√ßas de margin =====
        useEffect(() => {
          if (currentMargin !== marginRef.current) {
            marginRef.current = currentMargin
          }
        }, [currentMargin, sectionId])

        // Filmes vis√≠veis (renderizar apenas estes)
        const visibleMovies = movies.slice(0, visibleCount)
        const MAX_WIDTH_CONTENT = visibleMovies.length * 280

        // Calcula se os bot√µes devem aparecer
        const viewportWidth = window.innerWidth - 80
        const cardWidth = 280 // 260px card + 20px margin
        const totalWidth = visibleMovies.length * cardWidth
        const maxScroll = Math.min(0, -(totalWidth - viewportWidth))

        const showLeftButton = currentMargin < 0 // Tem conte√∫do scrollado para esquerda
        const showRightButton = true // SEMPRE MOSTRAR (como solicitado pelo usu√°rio)

        // Carregar mais filmes quando chegar perto do fim (com debounce)
        useEffect(() => {
          // maxScroll √© negativo (ex: -2000), ent√£o transformamos em positivo
          const maxScrollDistance = Math.abs(maxScroll)
          const LOAD_MORE_THRESHOLD = maxScrollDistance * 0.7 // Carregar quando estiver a 70% do fim (menos agressivo)

          // currentMargin tamb√©m √© negativo quando scrollado, ent√£o pegamos valor absoluto
          const currentScrollDistance = Math.abs(currentMargin)

          // Se rolou al√©m do threshold e ainda tem mais filmes
          if (currentScrollDistance >= LOAD_MORE_THRESHOLD && visibleCount < movies.length) {
            // ===== DEBOUNCE: Aguardar 300ms antes de carregar mais =====
            const timeoutId = setTimeout(() => {
              const newCount = Math.min(visibleCount + 20, movies.length) // Carregar 20 de uma vez (menos chamadas)
              // console.log(`[SectionMovies] üì¶ Carregando mais filmes: ${visibleCount} -> ${newCount}`)
              setVisibleCount(newCount)
            }, 300)

            return () => clearTimeout(timeoutId)
          }
        }, [currentMargin, maxScroll, visibleCount, movies.length])

        // ===== DESABILITADO: Atualizar filme em destaque durante scroll (causava piscadas) =====
        // useEffect(() => {
        //   const timeoutId = setTimeout(() => {
        //     if (movies.length === 0 || currentMargin === 0) return
        //     const viewportWidth = window.innerWidth - 80
        //     const cardWidth = 280
        //     const centerPosition = Math.abs(currentMargin) + (viewportWidth / 2)
        //     const centerMovieIndex = Math.floor(centerPosition / cardWidth)
        //     if (centerMovieIndex >= 0 && centerMovieIndex < movies.length) {
        //       const newFeaturedMovie = movies[centerMovieIndex]
        //       const newFeaturedId = newFeaturedMovie.stream_id || newFeaturedMovie.id
        //       if (newFeaturedId !== globalState.featuredMovieId) {
        //         window.updateNetflixMoviesState({ featuredMovieId: newFeaturedId })
        //       }
        //     }
        //   }, 300)
        //   return () => clearTimeout(timeoutId)
        // }, [currentMargin, movies])

        // Adicionar suporte para scroll com mouse wheel (horizontal ou vertical com Shift)
        const handleWheel = (e) => {
          // Detecta scroll horizontal direto OU scroll vertical com shift pressionado
          const isHorizontalScroll = Math.abs(e.deltaX) > Math.abs(e.deltaY) || e.shiftKey

          if (isHorizontalScroll) {
            e.preventDefault()
            // Se Shift est√° pressionado, usa deltaY como horizontal
            const scrollAmount = e.shiftKey ? e.deltaY : e.deltaX

            setMarginContent(state => {
              const currentValue = state[sectionId] || 0
              const cardWidth = 280
              const padding = 80
              const viewportWidth = window.innerWidth - padding
              const totalWidth = visibleMovies.length * cardWidth
              const maxScroll = Math.min(0, -(totalWidth - viewportWidth))

              // Se n√£o h√° necessidade de scroll (tudo cabe), retorna sem mudar
              if (totalWidth <= viewportWidth) return state

              // Aplica o scroll
              let newValue = currentValue - scrollAmount

              // Limita aos bounds
              newValue = Math.max(maxScroll, Math.min(0, newValue))

              return {
                ...state,
                [sectionId]: newValue
              }
            })
          } else {
            // Scroll vertical - mudar de categoria (com debounce para evitar m√∫ltiplas mudan√ßas)
            if (verticalScrollTimeoutRef.current) {
              return // Ignora scroll adicional durante o debounce
            }

            const isScrollingDown = e.deltaY > 0
            const isScrollingUp = e.deltaY < 0

            if (isScrollingDown && onNextCategory) {
              e.preventDefault()
              console.log('[SectionMovies] üîΩ Scroll para baixo - Pr√≥xima categoria')
              onNextCategory()

              // Debounce de 800ms para evitar mudan√ßas r√°pidas demais
              verticalScrollTimeoutRef.current = setTimeout(() => {
                verticalScrollTimeoutRef.current = null
              }, 800)
            } else if (isScrollingUp && onPrevCategory) {
              e.preventDefault()
              console.log('[SectionMovies] üîº Scroll para cima - Categoria anterior')
              onPrevCategory()

              // Debounce de 800ms
              verticalScrollTimeoutRef.current = setTimeout(() => {
                verticalScrollTimeoutRef.current = null
              }, 800)
            }
          }
        }

        return e('div', {
          style: {
            display: 'block',
            padding: '5px 40px 20px 40px',
            position: 'relative',
            height: '500px',
            width: '100%',
            maxWidth: '100vw',
            overflow: 'hidden',
            willChange: 'contents'
          },
          onMouseEnter: () => setHovering(true),
          onMouseLeave: () => setHovering(false),
          onWheel: handleWheel
        },
          // Title with category indicator - Transparente sem obstruir hover
          e('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              marginBottom: '10px',
              height: '40px',
              position: 'relative',
              zIndex: 1,
              background: 'transparent',
              boxShadow: 'none',
              border: 'none',
              pointerEvents: 'none',
              padding: '8px 0',
              marginLeft: '-40px',
              marginRight: '-40px',
              paddingLeft: '40px',
              paddingRight: '40px'
            }
          },
            e('div', {
              style: {
                display: 'flex',
                alignItems: 'center',
                gap: '15px'
              }
            },
              e('h1', {
                style: {
                  position: 'relative',
                  color: '#fff',
                  fontSize: '24px',
                  margin: 0,
                  textShadow: '2px 2px 4px rgba(0,0,0,0.8)'
                }
              }, name),

              // Indicador de filmes carregados - Sempre vis√≠vel
              e('span', {
                style: {
                  fontSize: '14px',
                  color: '#ccc',
                  background: 'rgba(255,255,255,0.15)',
                  padding: '6px 12px',
                  borderRadius: '6px',
                  fontWeight: '500'
                }
              }, `${visibleCount}/${movies.length}`)
            ),

            // Category indicator com total real - Destacado
            categoryIndex !== undefined && e('div', {
              style: {
                display: 'flex',
                alignItems: 'center',
                gap: '10px'
              }
            },
              // Contador de categorias com fundo destacado - usa total real
              e('span', {
                style: {
                  fontSize: '14px',
                  fontWeight: '600',
                  color: '#fff',
                  background: 'rgba(244, 117, 33, 0.2)',
                  border: '2px solid #f47521',
                  padding: '6px 12px',
                  borderRadius: '6px',
                  textShadow: '1px 1px 2px rgba(0,0,0,0.8)'
                }
              }, `Categoria ${categoryIndex + 1} / ${globalState.totalCategories || totalCategories || '?'}`),

              // Dica de navega√ß√£o
              e('span', {
                style: {
                  fontSize: '12px',
                  color: '#aaa',
                  background: 'rgba(255,255,255,0.1)',
                  padding: '5px 10px',
                  borderRadius: '4px'
                }
              }, '‚Üë‚Üì')
            )
          ),

          // Left button - Scroll para esquerda no carrossel
          e('button', {
            id: 'btnScrollLeft',
            type: 'button',
            onClick: () => {
              // Rolar carrossel para a esquerda
              const cardWidth = 240 + 12 // largura do card + gap
              const scrollAmount = cardWidth * 6 // Rolar 6 cards por vez
              const newMargin = Math.min(currentMargin + scrollAmount, 0)

              setMarginContent(prev => ({
                ...prev,
                [sectionId]: newMargin
              }))
            },
            onMouseEnter: () => setHoveringLeft(true),
            onMouseLeave: () => setHoveringLeft(false),
            style: {
              position: 'absolute',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              flexDirection: 'column',
              gap: '4px',
              height: '100%',
              zIndex: 6,
              background: hoveringLeft ? 'rgba(20,20,20,0.95)' : 'rgba(20,20,20,0.75)',
              border: 0,
              left: 0,
              width: '80px',
              opacity: currentMargin < 0 ? '0.9' : '0', // S√≥ vis√≠vel se pode rolar
              pointerEvents: currentMargin < 0 ? 'auto' : 'none',
              transition: 'opacity 0.3s ease, background 0.2s ease',
              cursor: 'pointer',
              paddingTop: '8px',
              paddingBottom: '8px'
            }
          },
            e('span', {
              style: {
                fontSize: '36px',
                color: '#fff',
                transform: hoveringLeft ? 'scale(1.2)' : 'scale(1)',
                transition: 'transform 0.2s ease'
              }
            }, '‚óÄ')
          ),

          // Movies container
          e('div', {
            'data-section-id': sectionId, // ===== NOVO: ID para manipula√ß√£o direta =====
            style: {
              display: 'flex',
              flexDirection: 'row',
              alignItems: 'flex-start',
              transform: `translateX(${currentMargin}px)`,
              transition: 'transform 0.6s cubic-bezier(0.5, 0, 0.1, 1)',
              width: `${MAX_WIDTH_CONTENT}px`,
              willChange: 'transform',
              height: '420px', // Fixed height prevents pushing categories below
              position: 'relative',
              zIndex: 2
            }
          },
            visibleMovies.map((item, idx) =>
              isCollectionsMode
                ? e(CollectionCard, {
                    key: `collection-${item.id}-${idx}`,
                    collection: item,
                    sectionId,
                    idx,
                    onClick: async (collection, movies) => {
                      console.log('[CollectionCard] Abrindo cole√ß√£o:', collection.name, 'com', movies.length, 'filmes')

                      // 1. ABRIR INSTANTANEAMENTE com dados que j√° temos
                      const quickMovies = movies.map(movie => ({
                        stream_id: movie.stream_id,
                        name: movie.name,
                        stream_icon: null,
                        container_extension: 'mp4',
                        loading: true // Flag para mostrar skeleton
                      }))

                      setSelectedCollectionMovies(quickMovies)
                      setViewingCollectionMovies(true)
                      setShowCollectionsView(false)

                      // 2. DEPOIS carregar dados completos em background (sem bloquear UI)
                      console.log('[CollectionCard] Enriquecendo dados em background...')

                      const fetchPromises = movies.map(async (movie, index) => {
                        // Tentar encontrar nos filmes j√° carregados
                        for (const section of globalState.sectionsMovies) {
                          const found = section.movies.find(m => m.stream_id === movie.stream_id)
                          if (found) {
                            return { index, movie: found }
                          }
                        }

                        // ===== DESABILITADO: get_vod_info muito lento =====
                        // Retornar apenas dados b√°sicos, enriquecimento TMDB acontece depois
                        // try {
                        //   const info = await apiCall('get_vod_info', { vod_id: movie.stream_id })
                        //   ...
                        // } catch (err) {
                        //   console.warn('[CollectionCard] ‚ö†Ô∏è Erro ao buscar info:', movie.name, err)
                        // }

                        // Fallback
                        return {
                          index,
                          movie: {
                            stream_id: movie.stream_id,
                            name: movie.name,
                            stream_icon: null,
                            container_extension: 'mp4'
                          }
                        }
                      })

                      // Atualizar filmes conforme v√£o chegando
                      const results = await Promise.all(fetchPromises)
                      let fullMovies = results.map(r => r.movie)

                      // ORDENAR por ano de lan√ßamento (do mais antigo para o mais recente)
                      fullMovies = fullMovies.sort((a, b) => {
                        const yearA = a.releasedate || a.tmdb_year || '0'
                        const yearB = b.releasedate || b.tmdb_year || '0'

                        // Extrair apenas o ano (pode vir como "2024" ou "2024-01-15")
                        const getYear = (dateStr) => {
                          if (!dateStr) return 0
                          const yearMatch = String(dateStr).match(/(\d{4})/)
                          return yearMatch ? parseInt(yearMatch[1]) : 0
                        }

                        return getYear(yearA) - getYear(yearB) // Ordem crescente (mais antigo primeiro)
                      })

                      console.log('[CollectionCard] ‚úÖ Dados completos carregados e ordenados por ano')
                      setSelectedCollectionMovies(fullMovies)
                    }
                  })
                : e(Movie, {
                    key: `movie-${sectionId}-${item.stream_id || item.id || `idx-${idx}`}`,
                    movie: item,
                    sectionId,
                    idx
                  })
            )
          ),

          // Right button (avan√ßar) - SEMPRE VIS√çVEL
          showRightButton ? e('button', {
            id: 'btnScrollRight',
            type: 'button',
            onClick: (e) => {
              e.stopPropagation() // Evita que o clique propague e cause blur nos cards
              console.log('[btnScrollRight] Clicado! sectionId:', sectionId, 'movies.length:', movies.length)

              // Vers√£o local do handleScrollMovies que usa movies diretamente
              setMarginContent(prevState => {
                const currentMargin = prevState[sectionId] || 0
                const cardWidth = 280
                const padding = 80
                const viewportWidth = window.innerWidth - padding
                const cardsVisible = Math.floor(viewportWidth / cardWidth)

                const totalMovies = movies.length
                const totalWidth = totalMovies * cardWidth
                const maxScroll = Math.min(0, -(totalWidth - viewportWidth))

                if (totalWidth <= viewportWidth) {
                  console.log(`[SCROLL] Section ${sectionId}: n√£o precisa scroll`)
                  return prevState
                }

                const scrollAmount = cardsVisible * cardWidth
                let newValue = currentMargin - scrollAmount // left = avan√ßar para direita
                let finalValue = newValue < maxScroll ? 0 : Math.max(newValue, maxScroll)

                console.log(`[SCROLL] Section ${sectionId}: ${currentMargin} -> ${finalValue}, maxScroll: ${maxScroll}`)
                return { ...prevState, [sectionId]: finalValue }
              })
            },
            onMouseEnter: () => setHoveringRight(true),
            onMouseLeave: () => setHoveringRight(false),
            style: {
              position: 'absolute',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              flexDirection: 'column',
              gap: '4px',
              height: '420px',
              top: '50px',
              zIndex: 999,
              background: hoveringRight ? 'rgba(20,20,20,0.95)' : 'rgba(20,20,20,0.75)',
              border: 0,
              right: 0,
              width: '80px',
              opacity: '0.9',
              transition: 'opacity 0.3s ease, background 0.2s ease',
              cursor: 'pointer',
              paddingTop: '8px',
              paddingBottom: '8px',
              pointerEvents: 'auto'
            }
          }, e('span', {
            style: {
              fontSize: '36px',
              color: '#fff',
              transform: hoveringRight ? 'scale(1.2)' : 'scale(1)',
              transition: 'transform 0.2s ease'
            }
          }, '‚Ä∫')) : null
        )
      }

      // RENDER PRINCIPAL
      // console.log('[NetflixMovies] RENDER - loading:', globalState.loading, 'sectionsMovies.length:', globalState.sectionsMovies.length, 'errorMsg:', globalState.errorMsg)

      // Mostrar loading enquanto carrega
      if(globalState.loading && globalState.sectionsMovies.length === 0){
        return e(Loading)
      }

      // Mostrar erro se falhou
      if(globalState.errorMsg && globalState.sectionsMovies.length === 0){
        return e('div', {
          style: {
            background: '#111',
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            color: 'white',
            padding: '40px'
          }
        },
          e('h2', {
            style: {
              color: '#e50914',
              fontSize: '24px',
              marginBottom: '16px'
            }
          }, 'Erro ao Carregar'),
          e('p', {
            style: {
              fontSize: '16px',
              color: '#999',
              textAlign: 'center',
              maxWidth: '500px'
            }
          }, globalState.errorMsg),
          e('button', {
            onClick: () => {
              window.resetNetflixMovies()
              setView('home')
            },
            style: {
              marginTop: '24px',
              padding: '12px 24px',
              background: '#e50914',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '16px'
            }
          }, 'Voltar para Home')
        )
      }

      // Se n√£o tem filmes carregados e n√£o est√° loading nem com erro, mostra tela vazia
      if(globalState.sectionsMovies.length === 0){
        return e('div', {
          style: {
            background: '#111',
            minHeight: '100vh'
          }
        },
          e(TopBar)
        )
      }

      return e('div', {
        style: {
          background: '#111',
          height: '100vh',
          width: '100%',
          overflow: 'hidden',
          display: 'flex',
          flexDirection: 'column'
        }
      },
        // NavBar (TopBar do projeto) - Fixo no topo
        e(TopBar),

        // Container principal com FeaturedMovie de fundo e carross√©is sobrepostos
        e('div', {
          style: {
            flex: 1,
            position: 'relative',
            overflow: 'hidden',
            width: '100%'
          }
        },
          // Featured Movie (fundo completo) ou Hero Backdrop (cole√ß√µes)
          (() => {
            console.log('[RENDER] üé¨ Estado atual:', {
              heroBackdrop: globalState.heroBackdrop,
              featuredMovieId: globalState.featuredMovieId,
              sectionsMovies: globalState.sectionsMovies.length
            })

            if (globalState.heroBackdrop) {
              const imageUrl = `https://image.tmdb.org/t/p/w1280${globalState.heroBackdrop.backdrop_path}`
              console.log('[RENDER] heroBackdrop:', globalState.heroBackdrop, 'URL:', imageUrl)
            }
            return globalState.heroBackdrop ? e('div', {
              style: {
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                // ===== FIX: Background s√≥lido antes da imagem carregar =====
                backgroundColor: '#0a0a0a',
                backgroundImage: globalState.heroBackdrop.backdrop_path
                  ? `url(https://image.tmdb.org/t/p/w1280${globalState.heroBackdrop.backdrop_path})`
                  : 'none',
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                zIndex: 1,
                // ===== FIX: Transi√ß√£o suave para evitar piscar =====
                opacity: 1,
                transition: 'opacity 0.5s ease-in-out, background-image 0.5s ease-in-out',
                animation: 'fadeIn 0.5s ease-in-out'
              }
            },
            // Gradient overlay
            e('div', {
              style: {
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                background: 'linear-gradient(to top, #111 25%, transparent 60%)',
                zIndex: 2
              }
            }),

            // Informa√ß√µes do filme
            e('div', {
              style: {
                position: 'absolute',
                top: '20px',
                left: '40px',
                zIndex: 3,
                maxWidth: '650px'
              }
            },
              e('h1', {
                style: {
                  color: '#fff',
                  fontSize: '42px',
                  fontWeight: 'bold',
                  marginBottom: '12px',
                  textShadow: '2px 2px 8px rgba(0,0,0,0.8)'
                }
              }, globalState.heroBackdrop.name),

              globalState.heroBackdrop.overview ? e('p', {
                style: {
                  color: '#fff',
                  fontSize: '17px',
                  lineHeight: '1.5',
                  textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                  marginBottom: '10px',
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  display: '-webkit-box',
                  WebkitLineClamp: '3',
                  WebkitBoxOrient: 'vertical'
                }
              }, globalState.heroBackdrop.overview) : null
            )
          ) : e(FeaturedMovie, { featuredMovieId: globalState.featuredMovieId })
          })(),

          // Sections - Alterna entre 3 MODOS: Categorias / Lista de Cole√ß√µes / Filmes de Cole√ß√£o
          // Posicionado absolutamente na parte inferior
          e('div', {
            style: {
              position: 'absolute',
              bottom: '-30px',
              left: 0,
              right: 0,
              zIndex: 10,
              paddingBottom: '0px'
            }
          },
          // MODO 3: Visualizando filmes de uma cole√ß√£o
          viewingCollectionMovies && selectedCollectionMovies.length > 0 ? e(SectionMovies, {
            key: 'collection-movies',
            name: 'üé¨ Filmes da Cole√ß√£o',
            movies: selectedCollectionMovies,
            sectionId: 'collection-movies',
            categoryIndex: undefined, // Sem navega√ß√£o de categorias
            totalCategories: 0,
            onNextCategory: () => {},
            onPrevCategory: () => {}
          }) :
          // MODO 2: Lista de cole√ß√µes (carrossel horizontal)
          showCollectionsView && loadingCollections ? e('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              padding: '60px 40px',
              color: '#fff',
              fontSize: '18px'
            }
          },
            e('div', {
              style: {
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: '16px'
              }
            },
              e('div', {
                style: {
                  width: '40px',
                  height: '40px',
                  border: '4px solid rgba(244, 117, 33, 0.3)',
                  borderTop: '4px solid #f47521',
                  borderRadius: '50%',
                  animation: 'spin 1s linear infinite'
                }
              }),
              e('span', null, 'Buscando cole√ß√µes...')
            )
          ) :
          showCollectionsView && collections.length > 0 ? e(SectionMovies, {
            key: 'collections-list',
            name: `üé¨ Cole√ß√µes (${collections.length})`,
            movies: collections, // Passando cole√ß√µes como "movies" para reusar SectionMovies
            sectionId: 'collections',
            categoryIndex: undefined, // Sem navega√ß√£o de categorias
            totalCategories: 0,
            onNextCategory: () => {},
            onPrevCategory: () => {},
            isCollectionsMode: true // Flag para SectionMovies saber que est√° renderizando cole√ß√µes
          }) :
          showCollectionsView && collections.length === 0 && !loadingCollections ? e('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              padding: '60px 40px',
              color: '#999',
              fontSize: '16px'
            }
          }, 'Nenhuma cole√ß√£o encontrada nesta categoria') :
          // MODO 1: Renderiza a categoria atual OU loading se ainda n√£o carregou
          globalState.sectionsMovies[currentCategoryIndex] ? e(SectionMovies, {
            key: globalState.sectionsMovies[currentCategoryIndex].id,
            name: globalState.sectionsMovies[currentCategoryIndex].name,
            movies: globalState.sectionsMovies[currentCategoryIndex].movies,
            sectionId: globalState.sectionsMovies[currentCategoryIndex].id,
            categoryIndex: currentCategoryIndex,
            totalCategories: globalState.totalCategories || globalState.sectionsMovies.length,
            onNextCategory: () => {
              const totalAvailable = globalState.totalCategories || window.__allAvailableCategories?.length || 0
              if (currentCategoryIndex < totalAvailable - 1) {
                const nextIndex = currentCategoryIndex + 1

                // Atualizar filme em destaque ANTES de mudar categoria (para evitar piscar)
                const nextSection = globalState.sectionsMovies[nextIndex]
                if (nextSection && nextSection.movies.length > 0) {
                  const firstMovie = nextSection.movies[0]
                  const newFeaturedId = firstMovie.stream_id || firstMovie.id
                  console.log(`[onNextCategory] Atualizando featuredMovieId para: ${firstMovie.name}`)
                  window.updateNetflixMoviesState({
                    featuredMovieId: newFeaturedId
                  })
                }

                // Resetar scroll para 0 com o sectionId correto
                if (nextSection) {
                  setMarginContent({ [nextSection.id]: 0 })
                }

                // Mudar imediatamente para a pr√≥xima categoria
                setCurrentCategoryIndex(nextIndex)
                setFocusedMovieIdx(0)

                // Se a categoria ainda n√£o foi carregada, carregar IMEDIATAMENTE
                if (!nextSection) {
                  console.log(`[onNextCategory] üîÑ Carregando categoria ${nextIndex + 1}...`)
                  loadCategory(nextIndex)
                }
              }
            },
            onPrevCategory: () => {
              if (currentCategoryIndex > 0) {
                const prevIndex = currentCategoryIndex - 1

                // Atualizar filme em destaque ANTES de mudar categoria (para evitar piscar)
                const prevSection = globalState.sectionsMovies[prevIndex]
                if (prevSection && prevSection.movies.length > 0) {
                  const firstMovie = prevSection.movies[0]
                  const newFeaturedId = firstMovie.stream_id || firstMovie.id
                  console.log(`[onPrevCategory] Atualizando featuredMovieId para: ${firstMovie.name}`)
                  window.updateNetflixMoviesState({
                    featuredMovieId: newFeaturedId
                  })
                }

                // Resetar scroll para 0 com o sectionId correto
                if (prevSection) {
                  setMarginContent({ [prevSection.id]: 0 })
                }

                // Mudar imediatamente para a categoria anterior
                setCurrentCategoryIndex(prevIndex)
                setFocusedMovieIdx(0)

                // Se a categoria ainda n√£o foi carregada, carregar IMEDIATAMENTE
                if (!prevSection) {
                  console.log(`[onPrevCategory] üîÑ Carregando categoria ${prevIndex + 1}...`)
                  loadCategory(prevIndex)
                }
              }
            }
          }) : e('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              padding: '60px 40px',
              color: '#fff',
              fontSize: '18px'
            }
          },
            e('div', {
              style: {
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: '16px'
              }
            },
              e('div', {
                style: {
                  width: '40px',
                  height: '40px',
                  border: '4px solid rgba(244, 117, 33, 0.3)',
                  borderTop: '4px solid #f47521',
                  borderRadius: '50%',
                  animation: 'spin 1s linear infinite'
                }
              }),
              e('span', null, `Carregando categoria ${currentCategoryIndex + 1}...`)
            )
          )
        ) // End sections div
        ) // End FeaturedMovie container
      ) // End main container
    }
    function Channels(){
      const [focusedItemIdx, setFocusedItemIdx] = useState(0)
      const gridCols = 6 // lg:grid-cols-6

      useEffect(()=>{
        if(view!=='channels' || !filtered || filtered.length===0) return

        const handleKeyDown = (e)=>{
          if(e.key==='ArrowRight'){
            e.preventDefault()
            setFocusedItemIdx(prev=> Math.min(prev + 1, filtered.length - 1))
          }else if(e.key==='ArrowLeft' || e.key==='Escape'){
            e.preventDefault()
            if(focusedItemIdx === 0 || e.key==='Escape'){
              // Se estiver no primeiro item OU pressionar ESC, voltar para categorias
              setView(selectedCat.type==='live'?'live-categories': selectedCat.type==='vod'?'movie-categories':'series-categories')
            }else{
              setFocusedItemIdx(prev=> Math.max(prev - 1, 0))
            }
          }else if(e.key==='ArrowDown'){
            e.preventDefault()
            setFocusedItemIdx(prev=> Math.min(prev + gridCols, filtered.length - 1))
          }else if(e.key==='ArrowUp'){
            e.preventDefault()
            setFocusedItemIdx(prev=> Math.max(prev - gridCols, 0))
          }else if(e.key==='Enter'){
            e.preventDefault()
            const item = filtered[focusedItemIdx]
            if(item) playStream(item)
          }
        }

        window.addEventListener('keydown', handleKeyDown)
        return ()=> window.removeEventListener('keydown', handleKeyDown)
      }, [view, filtered, focusedItemIdx, selectedCat])

      useEffect(()=>{
        if(view==='channels' && filtered && filtered.length>0){
          const item = filtered[focusedItemIdx]
          if(item){
            const el = document.getElementById('item-' + (item.stream_id||item.series_id||item.id))
            if(el) el.scrollIntoView({ behavior:'smooth', block:'nearest' })
          }
        }
      }, [focusedItemIdx, view, filtered])

      return e('div', { className:'star-bg h-screen p-6 overflow-hidden' },
        e(TopBar),
        e('div', { className:'flex flex-wrap items-center gap-3 mb-4' },
          e('button', { onClick:()=> setView(selectedCat.type==='live'?'live-categories': selectedCat.type==='vod'?'movie-categories':'series-categories'), className:'text-white text-xl hover:text-purple-400' }, '‚Üê'),
          e('h2', { className:'text-white text-2xl font-bold' }, selectedCat?.category_name || 'Categoria'),
          e('div', { className:'grow' }),
          e('input', { value:query, onChange:(ev)=>setQuery(ev.target.value), placeholder:'Pesquisar...', className:'w-full md:w-72 frost rounded-lg px-4 py-2 text-white placeholder:text-gray-400' })
        ),
        error && e('div', { className:'text-red-300 mb-3' }, 'Erro: ', error),
        e('div', { className:'grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4' },
          filtered && filtered.length>0 ?
            [
              ...filtered.map((item, idx)=> {
                const isFocused = idx === focusedItemIdx
                return e('button', {
                  key:item.stream_id || item.series_id || item.id || item.title,
                  id: 'item-' + (item.stream_id||item.series_id||item.id),
                  onClick:()=>{ setFocusedItemIdx(idx); playStream(item) },
                  className:'rounded-lg frost p-3 text-left card transition-all ' + (isFocused ? 'ring-2 ring-purple-400 bg-purple-500/20 scale-105' : '')
                },
                  item.stream_icon ? e('img', { src:item.stream_icon, alt:item.name, loading:'lazy', className:'w-full h-32 object-cover rounded mb-3' })
                                    : e('div', { className:'w-full h-32 bg-gradient-to-br from-purple-500 to-blue-500 rounded mb-3 grid place-items-center text-3xl' }, '‚ñ∂Ô∏è'),
                  e('div', { className:'text-white text-sm font-medium truncate' }, item.name || item.title || 'Sem t√≠tulo')
                )
              }),
              e('div', { key:'hint', className:'col-span-full text-center text-xs text-gray-400 mt-3 py-2' }, '‚Üë ‚Üì ‚Üê ‚Üí Navegar | Enter Reproduzir | ESC Voltar')
            ]
          : e('div', { className:'text-center text-gray-400 col-span-full mt-12' }, 'Nenhum conte√∫do nesta categoria')
        )
      )
    }

    // ============================================================
    // PLAYER HUD - Controles sobre o v√≠deo
    // ============================================================
    function PlayerHUD({ visible, videoRef, hlsObj, channelInfo, onHide }) {
      const [currentTime, setCurrentTime] = useState(new Date())
      const [resolution, setResolution] = useState('-- x --')
      const [levels, setLevels] = useState([])
      const [currentLevel, setCurrentLevel] = useState(-1)
      const [isAuto, setIsAuto] = useState(true)
      const [isFavorite, setIsFavorite] = useState(false)
      const hideTimerRef = useRef(null)

      // Atualizar hora atual a cada segundo
      useEffect(() => {
        const interval = setInterval(() => setCurrentTime(new Date()), 1000)
        return () => clearInterval(interval)
      }, [])

      // Detectar n√≠veis de qualidade do HLS
      useEffect(() => {
        if (!hlsObj) return
        const onManifestParsed = () => {
          const levelsData = hlsObj.levels.map((level, index) => ({
            index,
            height: level.height,
            width: level.width,
            bitrate: level.bitrate
          }))
          setLevels(levelsData)
          setCurrentLevel(hlsObj.currentLevel)
        }

        const onLevelSwitch = (event, data) => {
          setCurrentLevel(data.level)
          setIsAuto(hlsObj.currentLevel === -1)
        }

        hlsObj.on(Hls.Events.MANIFEST_PARSED, onManifestParsed)
        hlsObj.on(Hls.Events.LEVEL_SWITCHED, onLevelSwitch)

        return () => {
          hlsObj.off(Hls.Events.MANIFEST_PARSED, onManifestParsed)
          hlsObj.off(Hls.Events.LEVEL_SWITCHED, onLevelSwitch)
        }
      }, [hlsObj])

      // Atualizar resolu√ß√£o atual do v√≠deo
      useEffect(() => {
        const video = videoRef?.current
        if (!video) return

        const updateResolution = () => {
          if (video.videoWidth && video.videoHeight) {
            setResolution(`${video.videoWidth} x ${video.videoHeight}`)
          }
        }

        video.addEventListener('loadedmetadata', updateResolution)
        video.addEventListener('resize', updateResolution)

        return () => {
          video.removeEventListener('loadedmetadata', updateResolution)
          video.removeEventListener('resize', updateResolution)
        }
      }, [videoRef])

      // Auto-hide ap√≥s 4 segundos
      useEffect(() => {
        if (visible) {
          if (hideTimerRef.current) clearTimeout(hideTimerRef.current)
          hideTimerRef.current = setTimeout(() => {
            if (onHide) onHide()
          }, 4000)
        }
        return () => {
          if (hideTimerRef.current) clearTimeout(hideTimerRef.current)
        }
      }, [visible, onHide])

      // Mapear altura para categoria
      const getQualityLabel = (height) => {
        if (height >= 1080) return 'FHD'
        if (height >= 720) return 'HD'
        return 'SD'
      }

      // Agrupar n√≠veis por qualidade
      const groupedLevels = useMemo(() => {
        const groups = { FHD: [], HD: [], SD: [] }
        levels.forEach(level => {
          const label = getQualityLabel(level.height)
          groups[label].push(level)
        })
        return groups
      }, [levels])

      // Trocar qualidade
      const switchQuality = (quality, variant = 0) => {
        if (!hlsObj) return
        const group = groupedLevels[quality]
        if (!group || group.length === 0) return
        const level = group[variant] || group[0]
        if (level) {
          hlsObj.currentLevel = level.index
          setCurrentLevel(level.index)
          setIsAuto(false)
          console.log(`‚úÖ Qualidade alterada: ${quality} (${level.width}x${level.height})`)

          // Salvar prefer√™ncia
          if (channelInfo?.stream_id) {
            localStorage.setItem(`quality:channel:${channelInfo.stream_id}`, JSON.stringify({ quality, variant }))
          }
        }
      }

      // Ativar modo AUTO
      const switchToAuto = () => {
        if (!hlsObj) return
        hlsObj.currentLevel = -1
        setIsAuto(true)
        setCurrentLevel(-1)
        console.log('‚úÖ Modo AUTO ativado')
      }

      // Toggle favorito
      const toggleFavorite = () => {
        setIsFavorite(prev => !prev)
        // TODO: Salvar em localStorage ou backend
      }

      // Fullscreen
      const toggleFullscreen = async () => {
        const video = videoRef?.current
        if (!video) return

        try {
          if (!document.fullscreenElement) {
            if (video.requestFullscreen) await video.requestFullscreen()
            else if (video.webkitRequestFullscreen) await video.webkitRequestFullscreen()
            else if (video.mozRequestFullScreen) await video.mozRequestFullScreen()
          } else {
            if (document.exitFullscreen) await document.exitFullscreen()
            else if (document.webkitExitFullscreen) await document.webkitExitFullscreen()
            else if (document.mozCancelFullScreen) await document.mozCancelFullScreen()
          }
        } catch (err) {
          console.warn('Erro ao alternar fullscreen:', err)
        }
      }

      // PlayerHUD desabilitado - overlay n√£o deve aparecer em VOD
      return null

      if (!visible) return null

      const now = channelInfo?.epg?.now || { title: channelInfo?.name || 'Sem informa√ß√£o', start: '--:--', end: '--:--', isLive: false }
      const next = channelInfo?.epg?.next || null
      const currentHour = currentTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })

      return e('div', {
        className: 'fixed inset-0 z-50 pointer-events-none flex flex-col items-center justify-end pb-20',
        'data-testid': 'player-hud'
      },
        // Faixa principal
        e('div', { className: 'pointer-events-auto bg-black/80 backdrop-blur-md rounded-2xl p-6 w-full max-w-6xl mx-4 mb-4 shadow-2xl' },
          e('div', { className: 'flex items-center gap-6' },
            // Canal
            e('div', { className: 'flex items-center gap-3' },
              e('div', { className: 'text-4xl font-bold text-purple-400' }, channelInfo?.num || '--'),
              channelInfo?.stream_icon && e('img', { src: channelInfo.stream_icon, className: 'w-16 h-16 rounded-lg object-cover' })
            ),

            // Programa atual
            e('div', { className: 'flex-1' },
              e('div', { className: 'flex items-center gap-2 mb-1' },
                e('h3', { className: 'text-xl font-semibold text-white' }, now.title),
                now.isLive && e('span', { className: 'bg-red-600 text-white text-xs font-bold px-2 py-1 rounded-full' }, 'AO VIVO')
              ),
              e('div', { className: 'flex items-center gap-3 mb-2' },
                e('span', { className: 'text-sm text-gray-300' }, `${now.start} ‚Äì ${now.end}`),
                // Barra de progresso (exemplo fixo - voc√™ pode calcular o progresso real)
                e('div', { className: 'flex-1 h-1 bg-gray-700 rounded-full overflow-hidden' },
                  e('div', { className: 'h-full bg-red-600', style: { width: '45%' } })
                )
              )
            ),

            // Pr√≥ximo programa
            next && e('div', { className: 'w-64' },
              e('div', { className: 'text-xs text-gray-400 mb-1' }, 'NEXT'),
              e('h4', { className: 'text-sm font-medium text-white truncate' }, next.title),
              e('span', { className: 'text-xs text-gray-400' }, `${next.start} ‚Äì ${next.end}`)
            ),

            // Hora e resolu√ß√£o
            e('div', { className: 'text-right' },
              e('div', { className: 'text-3xl font-bold text-white' }, currentHour),
              e('div', { className: 'text-xs text-gray-400' }, resolution)
            )
          )
        ),

        // Faixa de controles (chips)
        e('div', { className: 'pointer-events-auto flex items-center gap-2 bg-black/60 backdrop-blur-md rounded-full px-4 py-2 shadow-xl' },
          // Favoritar
          e('button', {
            onClick: toggleFavorite,
            className: `px-4 py-2 rounded-full transition-all ${isFavorite ? 'bg-yellow-500 text-black' : 'bg-white/10 text-white hover:bg-white/20'}`
          }, isFavorite ? '‚òÖ' : '‚òÜ'),

          // Separador
          e('div', { className: 'w-px h-6 bg-white/20' }),

          // Qualidades FHD
          groupedLevels.FHD.length > 0 && [
            e('button', {
              key: 'fhd1',
              onClick: () => switchQuality('FHD', 0),
              className: `px-3 py-1 rounded-full text-sm font-semibold transition-all ${
                !isAuto && levels[currentLevel]?.height >= 1080 && groupedLevels.FHD[0]?.index === currentLevel
                  ? 'bg-purple-500 text-white ring-2 ring-purple-400'
                  : 'bg-white/10 text-white hover:bg-white/20'
              }`
            }, 'FHD'),
            groupedLevels.FHD.length > 1 && e('button', {
              key: 'fhd2',
              onClick: () => switchQuality('FHD', 1),
              className: `px-3 py-1 rounded-full text-sm font-semibold transition-all ${
                !isAuto && levels[currentLevel]?.height >= 1080 && groupedLevels.FHD[1]?.index === currentLevel
                  ? 'bg-purple-500 text-white ring-2 ring-purple-400'
                  : 'bg-white/10 text-white hover:bg-white/20'
              }`
            }, 'FHD¬≤')
          ],

          // Qualidades HD
          groupedLevels.HD.length > 0 && [
            e('button', {
              key: 'hd1',
              onClick: () => switchQuality('HD', 0),
              className: `px-3 py-1 rounded-full text-sm font-semibold transition-all ${
                !isAuto && levels[currentLevel]?.height >= 720 && levels[currentLevel]?.height < 1080 && groupedLevels.HD[0]?.index === currentLevel
                  ? 'bg-blue-500 text-white ring-2 ring-blue-400'
                  : 'bg-white/10 text-white hover:bg-white/20'
              }`
            }, 'HD'),
            groupedLevels.HD.length > 1 && e('button', {
              key: 'hd2',
              onClick: () => switchQuality('HD', 1),
              className: `px-3 py-1 rounded-full text-sm font-semibold transition-all ${
                !isAuto && levels[currentLevel]?.height >= 720 && levels[currentLevel]?.height < 1080 && groupedLevels.HD[1]?.index === currentLevel
                  ? 'bg-blue-500 text-white ring-2 ring-blue-400'
                  : 'bg-white/10 text-white hover:bg-white/20'
              }`
            }, 'HD¬≤')
          ],

          // Qualidades SD
          groupedLevels.SD.length > 0 && [
            e('button', {
              key: 'sd1',
              onClick: () => switchQuality('SD', 0),
              className: `px-3 py-1 rounded-full text-sm font-semibold transition-all ${
                !isAuto && levels[currentLevel]?.height < 720 && groupedLevels.SD[0]?.index === currentLevel
                  ? 'bg-green-500 text-white ring-2 ring-green-400'
                  : 'bg-white/10 text-white hover:bg-white/20'
              }`
            }, 'SD'),
            groupedLevels.SD.length > 1 && e('button', {
              key: 'sd2',
              onClick: () => switchQuality('SD', 1),
              className: `px-3 py-1 rounded-full text-sm font-semibold transition-all ${
                !isAuto && levels[currentLevel]?.height < 720 && groupedLevels.SD[1]?.index === currentLevel
                  ? 'bg-green-500 text-white ring-2 ring-green-400'
                  : 'bg-white/10 text-white hover:bg-white/20'
              }`
            }, 'SD¬≤')
          ],

          // Separador
          e('div', { className: 'w-px h-6 bg-white/20' }),

          // Original (AUTO)
          e('button', {
            onClick: switchToAuto,
            className: `px-4 py-2 rounded-full text-sm font-semibold transition-all ${
              isAuto
                ? 'bg-yellow-500 text-black ring-2 ring-yellow-400'
                : 'bg-white/10 text-white hover:bg-white/20'
            }`
          }, 'Original'),

          // Fullscreen
          e('button', {
            onClick: toggleFullscreen,
            className: 'px-6 py-2 rounded-full text-sm font-semibold bg-green-500 text-white ring-2 ring-green-400 hover:bg-green-600 transition-all'
          }, 'Full Screen')
        )
      )
    }

    // ===== COMPONENTE: LISTAGEM DE EPIS√ìDIOS =====
    function EpisodesList({ seriesData }) {
      const [selectedSeason, setSelectedSeason] = useState(1)
      const [seasonsData, setSeasonsData] = useState([])
      const [loading, setLoading] = useState(true)
      const [error, setError] = useState(null)

      // Buscar informa√ß√µes completas da s√©rie (temporadas + epis√≥dios)
      useEffect(() => {
        const fetchSeriesInfo = async () => {
          if (!seriesData || !seriesData.series_id) {
            setError('ID da s√©rie n√£o dispon√≠vel')
            setLoading(false)
            return
          }

          try {
            setLoading(true)
            console.log('[EpisodesList] Buscando informa√ß√µes da s√©rie ID:', seriesData.series_id)

            const data = await apiCall('get_series_info', { series_id: seriesData.series_id })
            console.log('[EpisodesList] Dados recebidos:', data)

            if (data && data.seasons) {
              // Converter object de temporadas em array e ordenar
              const seasonsArray = Object.entries(data.seasons || {})
                .map(([seasonNum, episodes]) => ({
                  seasonNumber: parseInt(seasonNum),
                  episodes: Array.isArray(episodes) ? episodes : []
                }))
                .sort((a, b) => a.seasonNumber - b.seasonNumber)

              console.log('[EpisodesList] Temporadas processadas:', seasonsArray.length)
              setSeasonsData(seasonsArray)

              // Selecionar primeira temporada por padr√£o
              if (seasonsArray.length > 0) {
                setSelectedSeason(seasonsArray[0].seasonNumber)
              }
            }
            setLoading(false)
          } catch (err) {
            console.error('[EpisodesList] Erro ao buscar:', err)
            setError('Erro ao carregar epis√≥dios')
            setLoading(false)
          }
        }

        fetchSeriesInfo()
      }, [seriesData])

      // Helpers
      const formatEpisodeTitle = (episode) => {
        const type = seriesData.type || 'serie'
        const season = episode.season || selectedSeason
        const epNum = episode.episode_num || episode.id

        if (type === 'novela') return `Cap. ${epNum}`
        if (type === 'anime') return `EP ${epNum.toString().padStart(2, '0')}`
        return `T${season.toString().padStart(2, '0')}:E${epNum.toString().padStart(2, '0')}`
      }

      const formatDuration = (seconds) => {
        if (!seconds) return 'N/A'
        const minutes = Math.floor(seconds / 60)
        if (minutes < 60) return `${minutes}min`
        const h = Math.floor(minutes / 60)
        const m = minutes % 60
        return `${h}h ${m}min`
      }

      const formatDate = (dateString) => {
        if (!dateString) return 'N/A'
        return new Date(dateString).toLocaleDateString('pt-BR')
      }

      const handleEpisodeClick = (episode) => {
        console.log('[EpisodesList] Epis√≥dio clicado:', episode)

        // Construir URL do epis√≥dio
        const ext = episode.container_extension || 'mp4'
        const url = buildURL(cfg.server, [
          'series',
          cfg.username,
          cfg.password,
          episode.id + '.' + ext
        ])

        setCurrent({
          name: `${seriesData.title || seriesData.name} - ${formatEpisodeTitle(episode)} - ${episode.title || ''}`,
          url,
          isHls: ext === 'm3u8'
        })
        setView('player')
      }

      // Temporada selecionada
      const currentSeasonData = seasonsData.find(s => s.seasonNumber === selectedSeason)
      const episodes = currentSeasonData?.episodes || []

      // Loading state
      if (loading) {
        return e('div', {
          style: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100vh',
            background: '#000',
            color: '#fff',
            fontSize: '24px'
          }
        }, 'Carregando epis√≥dios...')
      }

      // Error state
      if (error) {
        return e('div', {
          style: {
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100vh',
            background: '#000',
            color: '#fff',
            gap: '20px'
          }
        },
          e('div', { style: { fontSize: '24px' } }, error),
          e('button', {
            onClick: () => setView('netflix-movies'),
            style: {
              padding: '12px 24px',
              background: '#e50914',
              border: 'none',
              borderRadius: '4px',
              color: '#fff',
              fontSize: '16px',
              cursor: 'pointer'
            }
          }, '‚Üê Voltar')
        )
      }

      return e('div', {
        style: {
          background: '#000',
          minHeight: '100vh',
          color: '#fff',
          padding: '40px',
          fontFamily: 'system-ui, -apple-system, sans-serif'
        }
      },
        // Header
        e('div', {
          style: {
            marginBottom: '40px'
          }
        },
          // Bot√£o voltar
          e('button', {
            onClick: () => setView('serie-details'),
            style: {
              background: 'rgba(255,255,255,0.1)',
              border: 'none',
              color: '#fff',
              padding: '10px 20px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '16px',
              marginBottom: '20px',
              display: 'flex',
              alignItems: 'center',
              gap: '8px'
            }
          }, '‚Üê Voltar'),

          // T√≠tulo
          e('h1', {
            style: {
              fontSize: '48px',
              fontWeight: 'bold',
              marginBottom: '16px'
            }
          }, seriesData.title || seriesData.name),

          // Metadados
          e('div', {
            style: {
              display: 'flex',
              alignItems: 'center',
              gap: '16px',
              fontSize: '16px',
              color: '#b3b3b3',
              marginBottom: '12px'
            }
          },
            seriesData.tmdb_rating && e('span', {
              style: { color: '#fbbf24', fontWeight: 'bold' }
            }, `‚≠ê ${(seriesData.tmdb_rating * 10).toFixed(1)}%`),
            seriesData.tmdb_year && e('span', null, seriesData.tmdb_year),
            seriesData.ageRating && e('span', {
              style: {
                background: '#dc2626',
                padding: '2px 8px',
                borderRadius: '4px',
                fontSize: '14px',
                fontWeight: 'bold'
              }
            }, seriesData.ageRating || '16+')
          ),

          // Total epis√≥dios e temporadas
          e('div', {
            style: {
              fontSize: '18px',
              color: '#fff',
              marginBottom: '8px'
            }
          }, `${seasonsData.reduce((acc, s) => acc + s.episodes.length, 0)} Epis√≥dios (${seasonsData.length} ${seasonsData.length === 1 ? 'Temporada' : 'Temporadas'})`),

          // Tipo
          e('div', {
            style: {
              fontSize: '14px',
              color: '#b3b3b3'
            }
          }, `Tipo: ${seriesData.type === 'novela' ? 'Novela' : seriesData.type === 'anime' ? 'Anime' : seriesData.type === 'desenho' ? 'Desenho' : seriesData.type === 'show' ? 'Show' : 'S√©rie'}`)
        ),

        // Layout 2 colunas
        e('div', {
          style: {
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            gap: '32px',
            height: 'calc(100vh - 400px)'
          }
        },
          // COLUNA ESQUERDA: Temporadas
          e('div', {
            style: {
              overflowY: 'auto',
              paddingRight: '16px'
            }
          },
            e('h2', {
              style: {
                fontSize: '24px',
                fontWeight: 'bold',
                marginBottom: '20px'
              }
            }, 'Temporadas'),

            ...seasonsData.map(season =>
              e('div', {
                key: season.seasonNumber,
                onClick: () => setSelectedSeason(season.seasonNumber),
                style: {
                  display: 'flex',
                  gap: '16px',
                  padding: '16px',
                  background: '#141414',
                  borderRadius: '8px',
                  marginBottom: '16px',
                  cursor: 'pointer',
                  border: `2px solid ${selectedSeason === season.seasonNumber ? '#e50914' : '#333'}`,
                  transition: 'all 0.2s'
                },
                onMouseEnter: (e) => {
                  if (selectedSeason !== season.seasonNumber) {
                    e.currentTarget.style.background = '#1f1f1f'
                  }
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.background = '#141414'
                }
              },
                // Poster placeholder
                e('div', {
                  style: {
                    width: '120px',
                    height: '180px',
                    background: '#333',
                    borderRadius: '8px',
                    flexShrink: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: '48px',
                    color: '#666'
                  }
                }, season.seasonNumber),

                // Info
                e('div', {
                  style: {
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '8px'
                  }
                },
                  e('h3', {
                    style: {
                      fontSize: '20px',
                      fontWeight: 'bold'
                    }
                  }, `Temporada ${season.seasonNumber}`),

                  e('div', {
                    style: {
                      fontSize: '14px',
                      color: '#b3b3b3'
                    }
                  }, `${season.episodes.length} ${season.episodes.length === 1 ? 'Epis√≥dio' : 'Epis√≥dios'}`),

                  e('div', {
                    style: {
                      fontSize: '14px',
                      color: '#999',
                      lineHeight: '1.5',
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      display: '-webkit-box',
                      WebkitLineClamp: 3,
                      WebkitBoxOrient: 'vertical'
                    }
                  }, season.synopsis || `Temporada ${season.seasonNumber} com ${season.episodes.length} epis√≥dios.`)
                )
              )
            )
          ),

          // COLUNA DIREITA: Epis√≥dios
          e('div', {
            style: {
              overflowY: 'auto',
              paddingRight: '16px'
            }
          },
            e('h2', {
              style: {
                fontSize: '24px',
                fontWeight: 'bold',
                marginBottom: '20px'
              }
            }, `Epis√≥dios - Temporada ${selectedSeason}`),

            episodes.length === 0 ? e('div', {
              style: {
                textAlign: 'center',
                color: '#666',
                fontSize: '18px',
                marginTop: '40px'
              }
            }, 'Nenhum epis√≥dio dispon√≠vel') :

            episodes.map((episode, idx) =>
              e('div', {
                key: episode.id || idx,
                onClick: () => handleEpisodeClick(episode),
                style: {
                  display: 'flex',
                  gap: '16px',
                  padding: '16px',
                  background: '#141414',
                  borderRadius: '8px',
                  marginBottom: '16px',
                  cursor: 'pointer',
                  border: '2px solid #333',
                  transition: 'all 0.2s'
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.background = '#1f1f1f'
                  e.currentTarget.style.borderColor = '#666'
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.background = '#141414'
                  e.currentTarget.style.borderColor = '#333'
                }
              },
                // Thumbnail
                e('div', {
                  style: {
                    width: '240px',
                    height: '135px',
                    background: episode.info?.movie_image ? `url(${episode.info.movie_image}) center/cover` : '#333',
                    borderRadius: '8px',
                    flexShrink: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: '48px',
                    color: '#666',
                    position: 'relative'
                  }
                },
                  // Play overlay
                  e('div', {
                    style: {
                      position: 'absolute',
                      top: '50%',
                      left: '50%',
                      transform: 'translate(-50%, -50%)',
                      background: 'rgba(0,0,0,0.7)',
                      borderRadius: '50%',
                      width: '50px',
                      height: '50px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      fontSize: '24px'
                    }
                  }, '‚ñ∂')
                ),

                // Info
                e('div', {
                  style: {
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '8px'
                  }
                },
                  e('h3', {
                    style: {
                      fontSize: '18px',
                      fontWeight: 'bold'
                    }
                  }, `${formatEpisodeTitle(episode)} - ${episode.title || `Epis√≥dio ${episode.episode_num}`}`),

                  e('div', {
                    style: {
                      display: 'flex',
                      alignItems: 'center',
                      gap: '12px',
                      fontSize: '12px',
                      color: '#b3b3b3'
                    }
                  },
                    e('span', null, formatDate(episode.info?.releasedate || episode.added)),
                    e('span', null, '‚Ä¢'),
                    e('span', null, formatDuration(episode.info?.duration_secs || episode.info?.duration)),
                    episode.info?.rating && e('span', { style: { color: '#fbbf24' } }, `‚≠ê ${episode.info.rating}`)
                  ),

                  e('div', {
                    style: {
                      fontSize: '14px',
                      color: '#999',
                      lineHeight: '1.5',
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      display: '-webkit-box',
                      WebkitLineClamp: 2,
                      WebkitBoxOrient: 'vertical'
                    }
                  }, episode.info?.plot || `Epis√≥dio ${episode.episode_num} da temporada ${selectedSeason}.`)
                )
              )
            )
          )
        )
      )
    }

    // ===== COMPONENTE: P√ÅGINA DE DETALHES DE S√âRIE/FILME =====
    function SerieDetails({ contentData }) {
      const [isFavorite, setIsFavorite] = useState(false)
      const [showEpisodes, setShowEpisodes] = useState(false)

      if (!contentData) {
        return e('div', { className: 'serie-detail-page' },
          e('div', { className: 'serie-detail-content' },
            e('p', { style: { color: '#fff', fontSize: '24px' } }, 'Carregando detalhes...')
          )
        )
      }

      const {
        title,
        name,
        year,
        tmdb_year,
        episodes_count,
        seasons_count,
        rating,
        tmdb_rating,
        tmdb_vote_count,
        genre,
        tmdb_genres,
        synopsis,
        plot,
        tmdb_plot,
        tmdb_overview,
        backdrop,
        tmdb_backdrop,
        poster,
        tmdb_poster,
        stream_icon,
        cover,
        trailer_url,
        cast,
        tmdb_cast,
        tmdb_director,
        tmdb_runtime,
        series_id,
        stream_id
      } = contentData

      console.log('[SerieDetails] Dados recebidos:', {
        tmdb_backdrop,
        tmdb_overview,
        tmdb_rating,
        tmdb_genres,
        tmdb_cast,
        tmdb_director,
        backdrop,
        cover,
        stream_icon
      })

      // Dados processados - PRIORIZAR TMDB
      const displayTitle = title || name || 'Sem t√≠tulo'
      const displayYear = tmdb_year || year || '‚Äî'
      const displaySynopsis = tmdb_overview || tmdb_plot || synopsis || plot || 'Sinopse n√£o dispon√≠vel.'
      const displayBackdrop = tmdb_backdrop || backdrop || cover || stream_icon || 'https://via.placeholder.com/1920x1080/1a1a1a/ffffff?text=Sem+Imagem'
      const displayGenres = tmdb_genres || (genre ? genre.split(',').map(g => g.trim()).join(', ') : 'Drama')
      const displayRating = tmdb_rating ? `‚≠ê ${(tmdb_rating * 10).toFixed(0)}%` : (rating || '‚Äî')
      const displayDirector = tmdb_director || null
      const displayRuntime = tmdb_runtime ? `${tmdb_runtime} min` : null

      // ===== CORRE√á√ÉO: Garantir que cast seja sempre um array =====
      let displayCast = tmdb_cast || cast || []

      // Se cast √© string (vem do TMDB como "Nome1, Nome2, Nome3"), converter para array de objetos
      if (typeof displayCast === 'string') {
        console.log('[SerieDetails] Cast √© string, convertendo:', displayCast)
        displayCast = displayCast.split(',').map(name => ({
          name: name.trim(),
          profile_path: null
        }))
      } else if (!Array.isArray(displayCast)) {
        console.warn('[SerieDetails] Cast n√£o √© array nem string:', typeof displayCast, displayCast)
        displayCast = []
      }

      const displayEpisodes = episodes_count || '‚Äî'
      const displaySeasons = seasons_count || '‚Äî'

      // Handlers
      const handleWatch = () => {
        console.log('üé¨ Assistir:', displayTitle)
        // TODO: Navegar para player ou mostrar epis√≥dios
        if (series_id) {
          // √â s√©rie: mostrar epis√≥dios
          setShowEpisodes(true)
        } else {
          // √â filme: iniciar reprodu√ß√£o
          const id = stream_id || series_id
          const ext = 'mp4'
          const url = buildURL(cfg.server, ['movie', cfg.username, cfg.password, id + '.' + ext])
          setCurrent({ name: displayTitle, url, isHls: false })
          setView('player')
        }
      }

      const handleTrailer = () => {
        console.log('üéûÔ∏è Trailer:', displayTitle)
        if (trailer_url) {
          window.open(trailer_url, '_blank')
        } else {
          alert('Trailer n√£o dispon√≠vel')
        }
      }

      const handleFavorite = () => {
        setIsFavorite(!isFavorite)
        console.log(isFavorite ? 'üíî Removido dos favoritos' : '‚ù§Ô∏è Adicionado aos favoritos')
        // TODO: Salvar em localStorage ou API
      }

      const handleEpisodes = () => {
        console.log('üì∫ Mostrar epis√≥dios:', displayTitle)
        // Navegar para a view de epis√≥dios
        setView('episodes')
      }

      const handleCastClick = (actor) => {
        console.log('üë§ Ver detalhes do ator:', actor.name)
        // TODO: Modal com biografia do ator
      }

      return e('div', { className: 'serie-detail-page' },
        // Backdrop
        e('div', {
          className: 'serie-detail-backdrop',
          style: { backgroundImage: `url(${displayBackdrop})` }
        }),

        // Bot√£o Voltar
        e('button', {
          onClick: () => setView('netflix-movies'),
          style: {
            position: 'fixed',
            top: '20px',
            left: '20px',
            zIndex: 1000,
            background: 'rgba(0, 0, 0, 0.7)',
            border: 'none',
            color: '#fff',
            fontSize: '24px',
            width: '50px',
            height: '50px',
            borderRadius: '50%',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            transition: 'all 0.2s ease',
            backdropFilter: 'blur(10px)'
          },
          onMouseEnter: (e) => {
            e.target.style.background = 'rgba(244, 117, 33, 0.9)'
            e.target.style.transform = 'scale(1.1)'
          },
          onMouseLeave: (e) => {
            e.target.style.background = 'rgba(0, 0, 0, 0.7)'
            e.target.style.transform = 'scale(1)'
          }
        }, '‚Üê'),

        // Content
        e('div', { className: 'serie-detail-content' },
          // Header
          e('div', { className: 'serie-detail-header' },
            e('h1', null, displayTitle),

            // Metadados
            e('div', { className: 'serie-detail-metadata' },
              e('span', { className: 'serie-detail-rating-badge' }, displayRating),
              e('span', null, displayYear),
              series_id && e('span', null, `${displayEpisodes} Epis√≥dios (${displaySeasons} ${displaySeasons === 1 ? 'Temporada' : 'Temporadas'})`),
              displayRuntime && e('span', null, displayRuntime),
              e('span', null, displayGenres),
              displayDirector && e('span', null, `Dir: ${displayDirector}`)
            )
          ),

          // Sinopse
          e('p', { className: 'serie-detail-synopsis' }, displaySynopsis),

          // Bot√µes de a√ß√£o
          e('div', { className: 'serie-detail-actions' },
            e('button', {
              className: 'serie-detail-btn serie-detail-btn-watch',
              onClick: handleWatch
            },
              '‚ñ∂ Assistir'
            ),

            trailer_url && e('button', {
              className: 'serie-detail-btn serie-detail-btn-trailer',
              onClick: handleTrailer
            },
              'Trailer'
            ),

            e('button', {
              className: 'serie-detail-btn serie-detail-btn-favorite',
              onClick: handleFavorite
            },
              isFavorite ? 'üíî Remover dos Favoritos' : '‚ù§Ô∏è Adicionar aos Favoritos'
            )
          ),

          // Bot√£o Epis√≥dios (apenas para s√©ries)
          series_id && e('button', {
            className: 'serie-detail-btn serie-detail-btn-episodes',
            onClick: handleEpisodes
          },
            '‚â° Epis√≥dios e mais'
          ),

          // Se√ß√£o Elenco
          displayCast.length > 0 && e('div', { className: 'serie-detail-cast-section' },
            e('h2', null, 'Elenco'),

            e('div', { className: 'serie-detail-cast-carousel' },
              displayCast.map((actor, idx) =>
                e('div', {
                  key: `cast-${idx}`,
                  className: 'serie-detail-cast-card',
                  onClick: () => handleCastClick(actor)
                },
                  e('img', {
                    src: actor.photo || actor.profile_path
                      ? `https://image.tmdb.org/t/p/w185${actor.profile_path || actor.photo}`
                      : 'https://via.placeholder.com/140x200/333/fff?text=Sem+Foto',
                    alt: actor.name,
                    loading: 'lazy'
                  }),
                  e('p', null, actor.name)
                )
              )
            )
          )
        )
      )
    }

    function Player(){
      const videoRef = useRef(null)
      const [hlsObj,setHlsObj] = useState(null)
      const containerRef = useRef(null)
      const [showHUD, setShowHUD] = useState(true) // HUD vis√≠vel por padr√£o
      const [channelEPG, setChannelEPG] = useState(null)

      useEffect(()=>{ return ()=>{ if(hlsObj){ try{ hlsObj.destroy() }catch{} } } },[hlsObj])

      // Fullscreen autom√°tico no elemento de v√≠deo
      useEffect(() => {
        const enterFullscreen = async () => {
          const video = videoRef.current
          if (!video) return

          try {
            if (video.requestFullscreen) {
              await video.requestFullscreen()
            } else if (video.webkitRequestFullscreen) {
              await video.webkitRequestFullscreen()
            } else if (video.mozRequestFullScreen) {
              await video.mozRequestFullScreen()
            } else if (video.msRequestFullscreen) {
              await video.msRequestFullscreen()
            } else if (video.webkitEnterFullscreen) {
              // iOS Safari
              video.webkitEnterFullscreen()
            }
            console.log('‚úÖ Player de v√≠deo em fullscreen')
          } catch (err) {
            console.warn('‚ö†Ô∏è Fullscreen n√£o dispon√≠vel:', err.message)
          }
        }

        // Delay para garantir que o v√≠deo est√° carregado
        setTimeout(enterFullscreen, 300)
      }, [current])

      // Handler ESC - volta para netflix-movies
      useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            e.preventDefault()

            // Sair do fullscreen se estiver ativo
            if (document.fullscreenElement || document.webkitFullscreenElement ||
                document.mozFullScreenElement || document.msFullscreenElement) {
              if (document.exitFullscreen) {
                document.exitFullscreen()
              } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen()
              } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen()
              } else if (document.msExitFullscreen) {
                document.msExitFullscreen()
              }
            }

            // Voltar para netflix-movies
            setView('netflix-movies')
            console.log('‚¨ÖÔ∏è Voltando para categorias')
          }
        }

        window.addEventListener('keydown', handleEscape)
        return () => window.removeEventListener('keydown', handleEscape)
      }, [])

      useEffect(()=>{
        const v = videoRef.current
        if(!v || !current) return
        const isM3U8 = /\.m3u8($|\?)/i.test(current.url)
        const canNative = v.canPlayType('application/vnd.apple.mpegURL')
        if(isM3U8 && !canNative && window.Hls && window.Hls.isSupported()){
          const hls = new Hls({ maxBufferLength: 30 })
          hls.loadSource(current.url)
          hls.attachMedia(v)
          setHlsObj(hls)
        }else{ v.src = current.url }
        v.play().catch(()=>{})
      },[current])

      // Handlers para mostrar HUD
      useEffect(() => {
        const handleInteraction = () => setShowHUD(true)
        const handleKeyDown = (e) => {
          // OK/Enter - toggle HUD
          if (e.key === 'Enter' || e.key === 'OK') {
            e.preventDefault()
            setShowHUD(prev => !prev)
          }
          // F - Fullscreen (o pr√≥prio HUD tem o bot√£o)
          if (e.key === 'f' || e.key === 'F') {
            setShowHUD(true)
          }
          // Setas - mostrar HUD
          if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            setShowHUD(true)
          }
        }

        window.addEventListener('mousemove', handleInteraction)
        window.addEventListener('keydown', handleKeyDown)

        return () => {
          window.removeEventListener('mousemove', handleInteraction)
          window.removeEventListener('keydown', handleKeyDown)
        }
      }, [])

      return e('div', { ref: containerRef, className:'bg-black min-h-screen flex flex-col' },
        e(TopBar),
        e('div', { className:'bg-zinc-900/60 px-4 py-3 flex items-center justify-between' },
          e('button', { onClick:()=>setView('channels'), className:'text-white hover:text-purple-400 flex items-center gap-2' }, '‚Üê Voltar'),
          e('h2', { className:'text-white font-semibold truncate max-w-[60vw]' }, current?.name || 'Reprodu√ß√£o'),
          e('div', { className:'w-10' })
        ),
        e('div', { className:'flex-1 grid place-items-center p-4 relative' },
          e('video', { ref:videoRef, controls:false, playsInline:true, className:'w-full max-w-6xl rounded-lg bg-black' }),
          // PlayerHUD sobreposto
          e(PlayerHUD, {
            visible: showHUD,
            videoRef: videoRef,
            hlsObj: hlsObj,
            channelInfo: {
              num: current?.num || '---',
              name: current?.name || 'Canal',
              stream_icon: current?.stream_icon,
              stream_id: current?.stream_id,
              epg: channelEPG
            },
            onHide: () => setShowHUD(false)
          })
        )
      )
    }

    function Config(){
      // ===== DNS FIXO: http://infcsfortal.pro =====
      // Garante que o servidor est√° sempre configurado corretamente
      const [serverSet, setServerSet] = useState(false)
      React.useEffect(() => {
        if (!serverSet && cfg.server !== 'http://infcsfortal.pro') {
          setCfg(v => ({...v, server: 'http://infcsfortal.pro'}))
          setServerSet(true)
        }
      }, [serverSet])

      // Estados locais para os inputs - TOTALMENTE independentes de cfg
      const [localUsername, setLocalUsername] = useState('')
      const [localPassword, setLocalPassword] = useState('')

      // Inicializar valores apenas UMA VEZ
      const initialized = useRef(false)
      React.useEffect(() => {
        if (!initialized.current && (cfg.username || cfg.password)) {
          setLocalUsername(cfg.username || '')
          setLocalPassword(cfg.password || '')
          initialized.current = true
        }
      }, [])

      // Fun√ß√£o de conex√£o
      const handleConnect = () => {
        // Atualizar cfg com os valores locais
        setCfg(v => ({...v, username: localUsername, password: localPassword}))
        // Conectar ap√≥s breve delay para garantir que cfg foi atualizado
        setTimeout(() => onConnect(), 50)
      }

      return e('div', { className:'star-bg min-h-screen grid place-items-center p-4' },
        e('div', { className:'frost rounded-2xl p-6 w-full max-w-md' },
          e('h2', { className:'text-white text-2xl font-bold mb-4 text-center' }, 'Configura√ß√£o API Xtream Codes'),
          e('div', { className:'space-y-3' },
            // ===== CAMPO DNS REMOVIDO (fixo: http://infcsfortal.pro) =====
            e('div', null, e('label', { className:'text-white text-sm mb-2 block' }, 'Usu√°rio'),
              e('input', {
                type:'text',
                value:localUsername,
                onChange:(ev)=>setLocalUsername(ev.target.value),
                onKeyDown:(ev)=>{ if(ev.key==='Enter') handleConnect() },
                className:'w-full frost text-white px-4 py-3 rounded-lg focus:outline-none',
                placeholder:'Digite o usu√°rio'
              })
            ),
            e('div', null, e('label', { className:'text-white text-sm mb-2 block' }, 'Senha'),
              e('input', {
                type:'password',
                value:localPassword,
                onChange:(ev)=>setLocalPassword(ev.target.value),
                onKeyDown:(ev)=>{ if(ev.key==='Enter') handleConnect() },
                className:'w-full frost text-white px-4 py-3 rounded-lg focus:outline-none',
                placeholder:'Digite a senha'
              })
            ),
            // ===== CAMPO TMDB API KEY REMOVIDO (agora usa chave fixa interna) =====
            e('button', { onClick:handleConnect, disabled:loading, className:'w-full bg-gradient-to-r from-purple-500 to-blue-500 text-white py-3 rounded-lg font-semibold hover:shadow-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed mt-4' }, loading ? 'Conectando...' : 'Conectar'),
            error && e('div', { className:'text-red-300 text-xs mt-2' },
              e('div', null, error),
              debug? e('div', {className:'hint text-gray-400 mt-1'}, 'URL: ', maskUrlCredentials(debug.url||'')) : null
            )
          ),
          account && e('div', { className:'text-green-300 text-sm mt-3' }, 'Conectado como ', account.username)
        )
      )
    }

    function TrailerModal(){
      if(!showTrailerModal || !trailerUrl) return null

      return e('div', {
        onClick: () => {
          setShowTrailerModal(false)
          setTrailerUrl(null)
        },
        style: {
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0, 0, 0, 0.95)',
          zIndex: 999999,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          padding: '20px'
        }
      },
        // Bot√£o fechar (X)
        e('button', {
          onClick: (ev) => {
            ev.stopPropagation()
            setShowTrailerModal(false)
            setTrailerUrl(null)
          },
          style: {
            position: 'absolute',
            top: '20px',
            right: '20px',
            background: 'rgba(255, 255, 255, 0.2)',
            border: 'none',
            borderRadius: '50%',
            width: '50px',
            height: '50px',
            color: '#fff',
            fontSize: '24px',
            cursor: 'pointer',
            zIndex: 1000000,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            transition: 'all 0.2s'
          },
          onMouseEnter: (ev) => {
            ev.target.style.background = 'rgba(255, 255, 255, 0.3)'
            ev.target.style.transform = 'scale(1.1)'
          },
          onMouseLeave: (ev) => {
            ev.target.style.background = 'rgba(255, 255, 255, 0.2)'
            ev.target.style.transform = 'scale(1)'
          }
        }, '‚úï'),

        // Video container
        e('div', {
          onClick: (ev) => ev.stopPropagation(),
          style: {
            width: '100%',
            maxWidth: '1200px',
            aspectRatio: '16/9',
            backgroundColor: '#000'
          }
        },
          e('iframe', {
            src: trailerUrl + '?autoplay=1&rel=0&modestbranding=1',
            allow: 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture',
            allowFullScreen: true,
            style: {
              width: '100%',
              height: '100%',
              border: 'none'
            }
          })
        )
      )
    }

    function Toast(){
      if(!toast) return null
      return e('div', {
        className: 'fixed top-6 right-6 z-50 px-6 py-3 rounded-lg text-white font-semibold shadow-2xl animate-fade-in',
        style: { backgroundColor: 'rgba(0, 230, 118, 0.95)' }
      }, toast)
    }

    // ===== Bot√£o de Fullscreen =====
    function FullscreenButton(){
      const [isFullscreen, setIsFullscreen] = useState(false)

      // Detectar mudan√ßas de fullscreen (F11, ESC, etc)
      useEffect(() => {
        const handleFullscreenChange = () => {
          setIsFullscreen(!!document.fullscreenElement)
        }

        document.addEventListener('fullscreenchange', handleFullscreenChange)
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange)
        document.addEventListener('mozfullscreenchange', handleFullscreenChange)
        document.addEventListener('MSFullscreenChange', handleFullscreenChange)

        return () => {
          document.removeEventListener('fullscreenchange', handleFullscreenChange)
          document.removeEventListener('webkitfullscreenchange', handleFullscreenChange)
          document.removeEventListener('mozfullscreenchange', handleFullscreenChange)
          document.removeEventListener('MSFullscreenChange', handleFullscreenChange)
        }
      }, [])

      // Inicializar √≠cones Lucide quando o componente monta ou o estado muda
      useEffect(() => {
        if (window.lucide) {
          window.lucide.createIcons()
        }
      }, [isFullscreen])

      const toggleFullscreen = async () => {
        try {
          if (!document.fullscreenElement) {
            // Entrar em fullscreen
            const elem = document.documentElement
            if (elem.requestFullscreen) {
              await elem.requestFullscreen()
            } else if (elem.webkitRequestFullscreen) {
              await elem.webkitRequestFullscreen()
            } else if (elem.mozRequestFullScreen) {
              await elem.mozRequestFullScreen()
            } else if (elem.msRequestFullscreen) {
              await elem.msRequestFullscreen()
            }
          } else {
            // Sair de fullscreen
            if (document.exitFullscreen) {
              await document.exitFullscreen()
            } else if (document.webkitExitFullscreen) {
              await document.webkitExitFullscreen()
            } else if (document.mozCancelFullScreen) {
              await document.mozCancelFullScreen()
            } else if (document.msExitFullscreen) {
              await document.msExitFullscreen()
            }
          }
        } catch (err) {
          console.warn('Erro ao alternar fullscreen:', err)
        }
      }

      // N√£o mostrar na tela de config (login)
      if(view === 'config') return null

      return e('button', {
        onClick: toggleFullscreen,
        className: 'fixed top-6 right-6 z-50 w-12 h-12 rounded-full flex items-center justify-center transition-all hover:scale-110 hover:bg-purple-500/30 group',
        style: {
          backgroundColor: 'rgba(30, 30, 30, 0.8)',
          backdropFilter: 'blur(8px)',
          border: '1px solid rgba(168, 85, 247, 0.3)'
        },
        title: isFullscreen ? 'Sair da tela cheia (ESC)' : 'Tela cheia (F11)'
      },
        // √çcone usando lucide
        e('span', {
          className: 'text-white transition-colors group-hover:text-purple-400',
          'data-lucide': isFullscreen ? 'minimize-2' : 'maximize-2',
          style: { width: '20px', height: '20px' }
        })
      )
    }

    // ===== Router =====
    let content
    if(view==='config') content = e(Config)
    else if(view==='home') content = e(Home)
    else if(view==='netflix-movies'){
      content = e(NetflixMovies, { key: 'vod-all', contentType: 'vod' })
    }
    else if(view==='netflix-series'){
      content = e(NetflixMovies, { key: 'series-all', contentType: 'series' })
    }
    else if(view==='netflix-novelas'){
      content = e(NetflixMovies, { key: 'series-novela', contentType: 'series', categoryFilter: 'novela' })
    }
    else if(view==='netflix-animes'){
      content = e(NetflixMovies, { key: 'series-crunchyroll', contentType: 'series', categoryFilter: 'crunchyroll' })
    }
    else if(view==='netflix-desenhos'){
      content = e(NetflixMovies, { key: 'series-desenho', contentType: 'series', categoryFilter: 'desenho' })
    }
    else if(view==='netflix-show'){
      content = e(NetflixMovies, { key: 'series-show', contentType: 'series', categoryFilter: 'show' })
    }
    else if(view==='collections'){
      content = e(NetflixMovies, { key: 'vod-collections', contentType: 'vod' })
    }
    else if(view.endsWith('-categories')) content = e(Categories)
    else if(view==='channels' && selectedCat) content = e(Channels)
    else if(view==='serie-details' && selectedContent) content = e(SerieDetails, { contentData: selectedContent })
    else if(view==='episodes' && selectedContent) content = e(EpisodesList, { seriesData: selectedContent })
    else if(view==='player' && current) content = e(Player)
    else content = e('div', { className:'star-bg min-h-screen grid place-items-center text-white' }, 'Carregando...')

    // Se n√£o estiver na tela de config (login), mostrar sidebar
    const showSidebar = view !== 'config'

    // Adicionar classe ao body quando sidebar estiver vis√≠vel
    useEffect(() => {
      if (showSidebar) {
        document.body.classList.add('with-sidebar')
      } else {
        document.body.classList.remove('with-sidebar')
      }
    }, [showSidebar])

    return e('div', { className: 'app-container' },
      showSidebar && e(Sidebar, { view, setView }),
      e('div', {
        className: showSidebar ? 'main-content' : 'main-content',
        style: showSidebar ? {} : { marginLeft: 0, width: '100vw' }
      },
        content,
        e(TrailerModal),
        e(Toast),
        e(FullscreenButton),
        // Indicador de navega√ß√£o num√©rica (canal digitado)
        channelInput && e('div', { className: 'tv-channel-input' },
          e('div', { style: { fontSize: '24px', color: '#a855f7', marginBottom: '10px' } }, 'Canal'),
          channelInput
        )
      )
    )
  }

  const root = ReactDOM.createRoot(document.getElementById('app'))
  root.render(e(App))

  // ===== Pequenos testes =====
  ;(function runTests(){
    const tests = []
    function assert(name, cond){ tests.push([name, !!cond]) }
    try{
      assert('sanitizeServer adiciona http', sanitizeServer('example.com')==='http://example.com')
      assert('sanitizeServer remove barra final', sanitizeServer('http://a.com/')==='http://a.com')
      assert('sanitizeServer mant√©m https', sanitizeServer('https://a.com').startsWith('https://'))
      assert('buildURL concatena segmentos', buildURL('http://a.com', ['x','y'])==='http://a.com/x/y')
      assert('buildURL remove barras extras', buildURL('http://a.com/', ['/x/','/y/'])==='http://a.com/x/y')
      assert('formatEPGTime string HH:MM', formatEPGTime('08:30')==='08:30')
      const nowSec = Math.floor(Date.now()/1000)
      assert('formatEPGTime timestamp s/ms', /\d{2}:\d{2}/.test(formatEPGTime(nowSec)) && /\d{2}:\d{2}/.test(formatEPGTime(nowSec*1000)))
      assert('maskUrlCredentials oculta user/pass (qs)', /\*\*\*/.test(maskUrlCredentials('http://x/player_api.php?username=u&password=p')))
      // Normalizadores
      assert('toArray aceita array', Array.isArray(toArray([{a:1}])))
      assert('toArray aceita objeto-indexado', Array.isArray(toArray({0:{a:1},1:{a:2}})))
      assert('getCatId cobre v√°rios campos', getCatId({category_id:123})===123 && getCatId({id:9})===9)
      // Quality variants
      assert('extractBaseName remove qualidade', extractBaseName('Globo HD')==='Globo')
      assert('extractBaseName remove qualidade FHD¬≤', extractBaseName('SBT FHD¬≤')==='SBT')
      assert('detectQuality identifica HD', detectQuality('Globo HD')==='HD')
      assert('detectQuality retorna null sem sufixo', detectQuality('Globo')===null)
      // Extras
      assert('toArray(null) => []', Array.isArray(toArray(null)) && toArray(null).length===0)
      assert('getCatId CategoryID/categoryid', getCatId({CategoryID:7})===7 && getCatId({categoryid:8})===8)
      assert('maskUrlCredentials mascara path credenciais', !(/\/live\/[\w-]+\/[\w-]+\//.test(maskUrlCredentials('http://x/live/u/p/999.m3u8'))))
      assert('formatEPGTime inv√°lido => "--:--"', formatEPGTime('abc')==='--:--' && formatEPGTime(null)==='--:--')
      assert('getCatId null => null', getCatId(null)===null)
      // Novo: contagem de categorias
      const tmp={}; ['1','2','1'].forEach(id=> tmp[id]=(tmp[id]||0)+1)
      assert('agrupamento simples funciona', tmp['1']===2 && tmp['2']===1)
    }catch(err){ console.error('Tests crashed:', err) }
    const passed = tests.filter(t=>t[1]).length
    if(tests.length){ console.info(`// ===== Pequenos testes (DevTests) ===== ${passed}/${tests.length} passed`, tests) }
  })()
  </script>
</body>
</html>
